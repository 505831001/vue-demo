<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeJS基础：简介</title>
    <!-- CSS files -->
    <link rel="icon" href="https://v3.bootcss.com/favicon.ico">
    <link rel="stylesheet" href="./bootstrap-3.4.1-dist/css/bootstrap.min.css">
    <!-- JavaScript Files -->
    <script type="text/javascript" src="./js/jquery-3.6.4.js"></script>
    <script type="text/javascript" src="./js/jquery.validate.js"></script>
</head>

<body>
    <!-- JS 部分 -->

    <!-- JS 作用 -->
    <!-- 网页特效(监听用户的一些行为让网页作出对应的反馈) -->
    <!-- 表单验证(针对表单数据的合法性进行判断) -->
    <!-- 数据交互(获取后台的数据渲染到前端) -->
    <!-- 服务端编程(node.js) -->
    <!-- JS 组成 -->
    <!-- ECMAScript: 规定了js基础语法核心知识。比如：变量、分支语句、循环语句、对象等等。 -->
    <!-- Web APIs DOM: 操作文档。比如对页面元素进行移动、大小、添加删除等操作。 -->
    <!-- Web APIs BOM: 操作浏览器。比如页面弹窗，检测窗口宽度、存储数据到浏览器等等。 -->
    <!-- JS 用法 -->
    <!-- 使用 内联的 JavaScript 函数。 -->
    <!-- 使用 <head>或者<body>中的 JavaScript 函数。 -->
    <!-- 使用 外部的 JavaScript 函数。 -->
    <!-- JS 注释 -->
    <!-- 使用 //    开头的单行注释。快捷键：Ctrl + /。 -->
    <!-- 使用 /* */ 包裹的多行注释。快捷键：Shift + Ctrl + A。 -->
    <!-- JS 结束符 -->
    <!-- 使用 分号（;）为结束符。换行为默认结束符。 -->
    <!-- JS 字面量 -->
    <!-- 使用 3.14 为数字字面量。 -->
    <!-- 使用 双引号"白马王子" 单引号'黑马攻城狮' 为字符串字面量。 -->
    <!-- 使用 大括号对象 {} 中括号数组 [] 尖括号标签<> 等等字面量。 -->
    <!-- JS 输入/输出 -->
    <!-- 使用 window.prompt()   方法显示可提示用户输入的对话框。 -->
    <!-- 使用 element.innerHTML 属性写入到 HTML 元素。 -->
    <!-- 使用 window.alert()    方法弹出警告框。 -->
    <!-- 使用 document.write()  方法将内容写到 HTML 文档中。 -->
    <!-- 使用 console.log()     方法写入到浏览器的控制台。 -->
    <!-- JS 变量 -->
    <!-- 使用 var   关键字声明的变量。在函数外声明作用域是全局变量，在函数内声明作用域是局部变量。变量必须以字母开头，变量也能以（$）和（_）符号开头，变量名称对大小写敏感。 -->
    <!-- 使用 let   关键字定义的限定范围内作用域的变量。只在 let 命令所在的代码块内有效。 -->
    <!-- 使用 const 关键字来定义一个常量。一旦声明，常量的值就不能改变。 -->
    <!-- JS 数据类型 -->
    <!-- 使用 number    基础数据类型赋值的是数字类型。JS 中的正数、负数、小数等等统一称为数字类型。 -->
    <!-- 使用 string    基础数据类型赋值的是字符串类型。通过单引号（''）、双引号（""）或反引号（``）包裹的数据都叫字符串类型。 -->
    <!-- 使用 boolean   基础数据类型赋值的是布尔类型。布尔（逻辑）类型只能有两个值真（true）或假（false）。 -->
    <!-- 使用 undefined 基础数据类型返回值的是未定义类型。只声明变量，不赋值的情况下，变量的默认值为 undefined 这个值表示变量不含有值。 -->
    <!-- 使用 null      基础数据类型返回值的是空值类型。可以通过将变量的值设置为 null 来清空变量。 -->
    <!-- 使用 object    引用数据类型返回的值是对象。对象由花括号（{}）分隔，对象属性以名称和值对的形式（Key:Value）来定义，属性之间由逗号（,）分隔。 -->
    <!-- 使用 array     引用数据类型返回的值是数组。数组由中括号（[]）分隔，每个值之间由逗号（,）分隔。返回也是对象：object。 -->
    <!-- 使用 function  引用数据类型返回的值是函数。函数就是包裹在花括号中的代码块，前面使用了关键词 function。 -->
    <!-- JS 运算符 -->
    <!-- 使用 + - * / %            符号来表示数学运算符（算术运算符），主要包括加、减、乘、除、取余（求模）。 -->
    <!-- 使用 = += -= *= /= %=     符号来表示赋值运算符，对变量进行赋值的运算符。 -->
    <!-- 使用 > < >= <= == === !== 符号来表示比较运算符，比较两个数据大小、是否相等。 -->
    <!-- 使用 i++ ++i i-- --i      符号来表示一元运算符，能够使用一元运算符做自增（自减）运算。 -->
    <!-- 使用 && ||                符号来表示逻辑运算符，逻辑运算符用来解决多重条件判断。 -->
    <!-- JS 分支/循环 -->
    <!-- 使用 if (condition) { }                                   语句只有当指定条件为 true 时，使用该语句来执行代码。 -->
    <!-- 使用 if (condition) { } else { }                          语句当条件为 true 时执行代码，当条件为 false 时执行其他代码。 -->
    <!-- 使用 if (condition) { } else if (condition) else {}       语句使用该语句来选择多个代码块之一来执行。 -->
    <!-- 使用 switch (key) {case value: break; default: break;}    语句用于基于不同的条件来执行不同的动作。 -->
    <!-- 使用 while (condition) { }                                语句只要指定条件为 true，循环就可以一直执行代码块。 -->
    <!-- 使用 do { } while (condition);                            语句循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。 -->
    <!-- 使用 for (let i = 0; i < array.length; i++) { array[i]; } 语句循环代码块一定的次数。 -->
    <!-- 使用 array.forEach(element => { });                       语句循环代码块一定的次数。 -->
    <!-- 使用 for (const key in object) { object[key]; }           语句循环遍历对象的属性。 -->
    <!-- 使用 for (const iterator of object) { }                   语句循环遍历对象的属性。 -->
    <!-- JS 数组 -->
    <!-- 使用 array = new Array();                                 语句创建数组，基于 new 关键字。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- 使用 array = [];                                          语句创建数组，基于中括号 []。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- JS 操作符 -->
    <!-- 使用 typeof                                               操作符来检测变量的数据类型。 -->
    <!-- 使用 typeof                                               操作符来检测 null 是一个只有一个值的特殊类型。表示一个空对象引用。会返回 object。 -->
    <!-- 使用 typeof                                               操作检测一个没有设置值的变量。会返回 undefined。 -->
    <!-- JS 类型转换 -->
    <!-- 隐式转换：某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 -->
    <!-- 显式转换：为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 -->
    <!-- 使用 Number(x)                                            方法将字符串转换成数字类型。 -->
    <!-- 使用 parseInt(x)                                          方法将字符串转换成数字类型。 -->
    <!-- 使用 parseFloat(x)                                        方法将字符串转换成数字类型。 -->
    <!-- 使用 String(x)                                            方法将其他类型转换成字符串类型。 -->
    <!-- 使用 x.toString()                                         方法将其他类型转换成字符串类型。 -->
    <!-- JS 正则表达式 -->
    <!-- 语法 /正则表达式主体/修饰符(可选)                           正则表达式（Regular Expression）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 -->
    <!-- 使用 s.search(/RegExp/i)                                  正则表达式搜索 RegExp 字符串，且不区分大小写。 -->
    <!-- 使用 s.replace(/RegExp/i, "RegularExpression")            正则表达式且不区分大小写将字符串中的 RegExp 替换为 RegularExpression。 -->
    <!-- 使用 i                                                    修饰符执行对大小写不敏感的匹配。 -->
    <!-- 使用 g                                                    修饰符执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 -->
    <!-- 使用 m                                                    修饰符执行多行匹配。 -->
    <!-- 使用 [abc]                                                表达式查找方括号之间的任何字符。 -->
    <!-- 使用 [0-9]                                                表达式查找任何从 0 至 9 的数字。 -->
    <!-- 使用 (x|y)                                                表达式查找任何以 | 分隔的选项。 -->
    <!-- 使用 \d                                                   元字符查找数字。 -->
    <!-- 使用 \s                                                   元字符查找空白字符。 -->
    <!-- 使用 \b                                                   元字符匹配单词边界。 -->
    <!-- 使用 \uxxxx                                               元字符查找以十六进制数 xxxx 规定的 Unicode 字符。 -->
    <!-- 使用 n+                                                   量词匹配任何包含至少一个 n 的字符串。 -->
    <!-- 使用 n*                                                   量词匹配任何包含零个或多个 n 的字符串。 -->
    <!-- 使用 n?                                                   量词匹配任何包含零个或一个 n 的字符串。 -->
    <!-- 使用 RegExp                                               对象是一个预定义了属性和方法的正则表达式对象。 -->
    <!-- 使用 test()                                               方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 -->
    <!-- 使用 exec()                                               方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 -->
    <!-- JS 异常 -->
    <!-- 使用 try                                                  语句允许我们定义在执行时进行错误测试的代码块。 -->
    <!-- 使用 catch                                                语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 -->
    <!-- 使用 finally                                              语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 -->
    <!-- 使用 throw                                                语句创建自定义错误。或者叫做创建或者抛出异常（Exception）。 -->
    <!-- JS 关键字 -->
    <!-- 使用 break                                                关键字 -->
    <!-- 使用 continue                                             关键字 -->
    <!-- 使用 return                                               关键字 -->
    <!-- 使用 typeof                                               关键字 -->
    <!-- 使用 this                                                 关键字 -->
    <!-- 使用 var                                                  关键字 -->
    <!-- 使用 let                                                  关键字 -->
    <!-- 使用 const                                                关键字 -->
    <!-- 使用 void                                                 关键字 -->
    <!-- JS 异步编程 -->
    <!-- 同步 sync                                                 相对的概念。 -->
    <!-- 异步 async                                                相对的概念。 -->
    <!-- 使用 Promise                                              对象是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 -->
    <!-- 使用 new Promise(function(resolve, reject){setTimeout(function(){}, 1000);})     异步函数是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。 -->
    <!-- JS 函数 -->
    <!-- 使用 function functionname(parameters) { return parameters; }                    声明函数。函数声明后不会立即执行，会在我们需要的时候调用到。 -->
    <!-- 使用 x = function (a, b) { return a * b; };                                      匿名函数（函数表达式）。函数存储在变量中，不需要函数名称，通常通过变量名来调用。 -->
    <!-- 使用 new Function("a", "b", "return a * b");                                     构造函数。函数同样可以通过内置的 JavaScript 函数构造器 Function() 定义。 -->
    <!-- 使用 (function () { var x = "callback"; })();                                    自调用函数（立即执行函数）。函数表达式可以"自调用"，自调用表达式会自动调用。如果表达式后面紧跟 () 则会自动调用。不能自调用声明的函数。 -->
    <!-- 使用 (function () { var x = "callback"; }());                                    自调用函数（立即执行函数）。函数实际上是一个匿名自我调用的函数（没有函数名）。 -->
    <!-- 使用 (parameters) => { return x * y; }                                           箭头函数。ES6 新增了箭头函数。箭头函数表达式的语法比普通函数表达式更简洁。 -->
    <!-- 使用 function callback() { return a * b; } window.setInterval(callback(), 1000); 回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- 使用 window.addEventListener('click', function () { return a * b; });            回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- JS 闭包 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       x 变量可以作为一个函数使用。它 function () {return i += 1;} 可以访问函数上一层作用域的计数器。这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 -->
    <!-- JS 类 -->
    <!-- 使用 class Parent { property: "value", method: function () { } }                 使用 class 关键字来创建一个类，类是用于创建对象的模板。类体在一对大括号 {} 中，在大括号 {} 中定义类成员的位置，如方法或构造函数。每个类中包含了一个特殊的方法 constructor()，它是类的构造函数。这种方法用于创建和初始化一个由 class 创建的对象。 -->
    <!-- 使用 new Parent()                                                                使用 new 关键字来创建对象。创建对象时会自动调用构造函数方法 constructor()。 -->
    <!-- 使用 class Children extends Parent { }                                           使用 extends 关键字继承类。这个已有的类称为基类（父类），新建的类称为派生类（子类）。 -->
    <!-- 使用 static method() { }                                                         使用 static 关键字修改的方法是静态方法，又叫类方法，属于类的，但不属于对象。通过（类名.方法名）调用静态方法。静态方法不能在对象上调用，只能在类中调用。 -->
    <!-- JS 对象 -->
    <!-- 使用 Console 对象提供了浏览器控制台调试的接口。在不同浏览器上它的工作方式可能不一样，但通常都会提供一套共性的功能。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- DOM 部分 -->

    <!-- DOM 获取元素 -->
    <!-- 通过 document.getElementById()         方法通过 ID 找到 HTML 元素。 -->
    <!-- 通过 document.getElementsByTagName()   方法通过 标签名 找到 HTML 元素。 -->
    <!-- 通过 document.getElementsByClassName() 方法通过 类名 找到 HTML 元素。 -->
    <!-- 通过 document.querySelector()          方法返回文档中与指定的选择器匹配的第一个元素 Element 节点。 -->
    <!-- 通过 document.querySelectorAll()       方法返回包含文档中与指定的选择器匹配的所有元素 NodeList 节点的列表。 -->
    <!-- DOM 修改元素内容 -->
    <!-- 通过 document.write()                  方法可向文档写入文本内容，可以是 HTML 代码。 -->
    <!-- 通过 element.innerText                 属性设置或者返回元素的内容。 -->
    <!-- 通过 element.innerHTML                 属性设置或获取 HTML 语法表示的元素的后代。 -->
    <!-- DOM 修改元素属性 -->
    <!-- 通过 element.href                      属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.title                     属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.src                       属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.className                 属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.disabled                  属性规定应该启用或者禁用的 input 元素。 -->
    <!-- 通过 element.checked                   属性规定在页面加载时应该被预先选定的 input 元素。只针对 type="checkbox" 或者 type="radio"。 -->
    <!-- 通过 element.selected                  属性规定选项（在首次显示在列表中时）表现为选中状态。 -->
    <!-- DOM 修改元素样式 -->
    <!-- 通过 element.style.styleProperties     属性设置或者返回元素的样式属性。 -->
    <!-- DOM 定时器 -->
    <!-- 通过 window.setInterval(function, timeout)        方法按照指定的周期（毫秒）来无限循环调用，调用函数或计算表达式。 -->
    <!-- 通过 window.clearInterval(timer)                  方法取消由定时器设置的定时任务。 -->
    <!-- 通过 window.setTimeout(function, timeout)         方法在指定的毫秒数后仅此调用一次，调用函数或计算表达式。 -->
    <!-- 通过 window.clearTimeout(timer)                   方法取消由定时器设置的定时任务。 -->
    <!-- DOM 事件 -->
    <!-- 使用 window.onclick = function() { }                                      传统on注册事件（L0）。同一个对象，后面注册的事件会覆盖前面注册（同一个事件）。 -->
    <!-- 使用 window.addEventListener('event',  function () {})                    事件监听注册事件（L2）。后面注册的事件不会覆盖前面注册的事件（同一个事件）。 -->
    <!-- 使用 window.addEventListener('load',   function () {})                    事件监听注册事件（L2）。加载事件。加载外部资源（如图片、CSS和JavaScript等）加载完毕时触发的事件。 -->
    <!-- 使用 window.addEventListener('scroll', function () {})                    事件监听注册事件（L2）。滚动事件。页面进行滚动的时候触发的事件。监听某个元素的内部滚动直接给某个元素加即可。 -->
    <!-- DOM 事件流 -->
    <!-- 使用 window.addEventListener('event', function() {}, function callback()) 此方法若传入 false 代表冒泡阶段触发，默认就是 false。第三个参数传入 true 代表是捕获阶段触发（很少使用）。 -->
    <!-- 使用 window.stopPropagation()                                             此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有。当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段。 -->
    <!-- DOM 事件委托 -->
    <!-- 使用 window.target(Event.target)                                          此方法可以获得真正触发事件的元素。事件委托其实是利用事件冒泡的特点，给父元素添加事件，子元素（target）可以触发。 -->
    <!-- DOM 函数 -->
    <!-- 使用 function functionname(parameters) { return parameters; }             声明函数。 -->
    <!-- 使用 function (a, b) {return a * b};                                      匿名函数。 -->
    <!-- 使用 new Function("a", "b", "return a * b");                              构造函数。 -->
    <!-- 使用 (function () { var x = "callback"; })();                             自调用函数（立即执行函数）。 -->
    <!-- 使用 (function () { var x = "callback"; }());                             自调用函数（立即执行函数）。 -->
    <!-- 使用 (parameters) => { return x * y; }                                    箭头函数。 -->
    <!-- 使用 function callback() { return '回调函数'; } window.setInterval(callback(), 1000) 回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- 使用 window.addEventListener('click', function () { return '回调函数'; })            回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- DOM 节点操作 -->
    <!-- 使用 element.parentNode                    属性父节点查找。返回最近一级的父节点找不到返回为 null。 -->
    <!-- 使用 element.childNodes                    属性获得所有子节点，包括文本节点（空格、换行）注释节点等。 -->
    <!-- 使用 element.children                      属性仅获得所有元素节点。返回的还是一个伪数组。 -->
    <!-- 使用 element.nextElementSibling            属性查找下一个兄弟节点。 -->
    <!-- 使用 element.previousElementSibling        属性查找上一个兄弟节点。 -->
    <!-- 使用 document.createElement('elementName') 属性新建一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点。 -->
    <!-- 使用 element.appendChild('elementName')    属性要想在界面看到，还得插入到某个父元素中。插入到父元素的最后一个子元素。 -->
    <!-- 使用 element.cloneNode(boolean)            属性会克隆出一个跟原标签一样的元素，括号内传入布尔值。若为true，则代表克隆时会包含后代节点一起克隆，若为false，则代表克隆时不包含后代节点，默认false。 -->
    <!-- 使用 element.removeChild('elementName')    属性如不存在父子关系则删除不成功。 -->
    <!-- DOM 节点滚动 -->
    <!-- 使用 Element.scrollWidth                   返回类型为：Number，表示元素的滚动视图宽度。 -->
    <!-- 使用 Element.scrollHeight                  返回类型为：Number，表示元素的滚动视图高度。 -->
    <!-- 使用 Element.scrollLeft                    检测元素的内容左右和上下滚动的距离（被卷去的左侧scrollLeft），返回值不带单位。 -->
    <!-- 使用 Element.scrollTop                     检测元素的内容左右和上下滚动的距离（被卷去的头部scrollTop），返回值不带单位。 -->
    <!-- DOM 节点位置 -->
    <!-- 使用 element.offsetWidth                   返回元素的宽度，包括边框（border）和内边距（padding），但不包含外边距（margin）。 -->
    <!-- 使用 element.offsetHeight                  返回任何一个元素的高度包括边框（border）和内边距（padding），但不包含外边距（margin）。 -->
    <!-- 使用 element.offsetLeft                    检测元素相对于父级元素的左右偏移量位置，返回值不带单位。 -->
    <!-- 使用 element.offsetTop                     检测元素相对于父级元素的上下偏移量位置，返回值不带单位。 -->
    <!-- DOM 节点大小 -->
    <!-- 使用 Element.clientWidth                   检测元素的内容宽度（可见的区域大小（不包含滚动条和不包含超出的部分）），返回值不带单位。 -->
    <!-- 使用 Element.clientHeight                  检测元素的内容高度（可见的区域大小（不包含滚动条和不包含超出的部分）），返回值不带单位。 -->
    <!-- 使用 Element.clientLeft                    只读，返回 Number 表示该元素距离它左边界的宽度。 -->
    <!-- 使用 Element.clientTop                     只读，返回 Number 表示该元素距离它上边界的高度。 -->
    <!-- DOM 事件对象 -->
    <!-- 使用 o.addEventListener('event', function () {}) 事件监听对象。 -->
    <!-- 使用 MouseEvent.clientX                    鼠标指针在点击元素（DOM）中的 X 坐标。 -->
    <!-- 使用 MouseEvent.clientY                    鼠标指针在点击元素（DOM）中的 Y 坐标。 -->
    <!-- 使用 MouseEvent.offsetX                    鼠标指针相对于目标节点内边位置的 X 坐标。 -->
    <!-- 使用 MouseEvent.offsetY                    鼠标指针相对于目标节点内边位置的 Y 坐标。 -->
    <!-- 使用 MouseEvent.pageX                      鼠标指针相对于整个文档的 X 坐标。 -->
    <!-- 使用 MouseEvent.pageY                      鼠标指针相对于整个文档的 Y 坐标。 -->
    <!-- 使用 MouseEvent.screenX                    鼠标指针相对于全局（屏幕）的 X 坐标。 -->
    <!-- 使用 MouseEvent.screenY                    鼠标指针相对于全局（屏幕）的 Y 坐标。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- JQ 部分 -->

    <!-- 核心：$(function(){});                    页面加载事件。类似于window.load()页面加载事件。先ready()方法。 -->
    <!-- 函数：$(document).ready(function(){});    页面加载事件。类似于window.load()页面加载事件。先ready()方法。 -->
    <!-- 扩展：$(window).on('load', function(){}); 页面加载事件。类似于window.load()页面加载事件。后load()方法。 -->
    <!-- 原生：window.load(function(){});          页面加载事件。类似于window.load()页面加载事件。后load()方法。 -->
    <!-- 赋值：$("选择器").html('内容'); -->
    <!-- 赋值：$("选择器").text('内容'); -->
    <!-- 取值：$("选择器").html(); -->
    <!-- 取值：$("选择器").text(); -->
    <!-- 赋值：$("选择器").val('内容'); -->
    <!-- 取值：$("选择器").val(); -->
    <!-- 赋值：$("选择器").attr('属性名', '值'); -->
    <!-- 取值：$("选择器").attr('属性名'); -->
    <!-- 赋值：$("选择器").prop("checked", true);  设值（真True或者假False）。input标签checked属性是一个布尔属性。 -->
    <!-- 赋值：$("选择器").prop("disabled", true); 设值（真True或者假False）。button标签disabled属性是一个布尔属性。 -->
    <!-- 赋值：$("选择器").prop("selected", true); 设值（真True或者假False）。option元素selected属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("checked");        取值（真True或者假False）。input标签checked属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("disabled");       取值（真True或者假False）。button标签disabled属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("selected");       取值（真True或者假False）。option元素selected属性是一个布尔属性。 -->
    <!-- 删除：$("选择器").removeAttr('属性名'); -->
    <!-- 查找：$("选择器").eq(n);              获取第N个元素。 -->
    <!-- 查找：$("选择器").parent();           查询父级元素。 -->
    <!-- 查找：$("选择器").children();         查找子级元素。 -->
    <!-- 查找：$("选择器").siblings();         查找兄弟元素。 -->
    <!-- 查找：$("选择器").find();             查找后代元素。 -->
    <!-- 新增：$("选择器").append("element");  向每个匹配的元素内部追加内容。 -->
    <!-- 新增：$("选择器").prepend("element"); 向每个匹配的元素内部前置内容。 -->
    <!-- 删除：$("选择器").remove("element");  从DOM中删除所有匹配的元素。 -->
    <!-- 删除：$("选择器").empty();            所有删除匹配的元素集合中所有的子节点。 -->
    <!-- 样式：$("选择器").innerWidth();       获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。 -->
    <!-- 样式：$("选择器").innerHeight();      获取第一个匹配元素内部区域高度（包括补白、不包括边框）。 -->
    <!-- 样式：$("选择器").outerWidth();       获取第一个匹配元素外部宽度（默认包括补白和边框）。 -->
    <!-- 样式：$("选择器").outerHeight();      获取第一个匹配元素外部高度（默认包括补白和边框）。 -->
    <!-- 样式：$("选择器").css();              添加单个样式属性。 -->
    <!-- 样式：$("选择器").css({});            添加多个样式属性数组。 -->
    <!-- 样式：$("选择器").addClass();         添加已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").hasClass();         查找已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").removeClass();      删除已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").toggleClass();      有则删除，无则添加已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").offset();           获取匹配元素在当前视口的相对偏移。 -->
    <!-- 样式：$("选择器").position();         获取匹配元素相对父元素的偏移。 -->
    <!-- 样式：$("选择器").scrollTop();        获取匹配元素相对滚动条顶部的偏移。 -->
    <!-- 样式：$("选择器").scrollLeft();       获取匹配元素相对滚动条左侧的偏移。 -->
    <!-- 样式：$("选择器").show(1000);         显示隐藏的匹配元素。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").hide(1000);         隐藏显示的元素。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").toggle(1000);       用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的click事件。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeIn(1000);       通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeOut(1000);      通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeToggle(1000);   通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").slideDown(1000);    通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数。 -->
    <!-- 样式：$("选择器").slideUp(1000);      通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数。 -->
    <!-- 样式：$("选择器").slideToggle(1000);  通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数。 -->
    <!-- 动画：$("选择器").基础动画方法(回调函数); -->
    <!-- 动画：$("选择器").基础动画方法(持续时间, 回调函数); -->
    <!-- 动画：$("选择器").animate(params,speed,easing,function); 用于创建自定义动画的函数。 -->
    <!-- 动画：$("选择器").stop();                                停止所有在指定元素上正在运行的动画。 -->
    <!-- 动画：$("选择器").delay(duration,queueName);             设置一个延时来推迟执行队列中之后的项目。 -->
    <!-- 事件：$("选择器").click();                     点击事件。 -->
    <!-- 事件：$("选择器").mouseenter();                鼠标移入事件。 -->
    <!-- 事件：$("选择器").mouseleave();                鼠标移出事件。 -->
    <!-- 事件：$("选择器").focus();                     获取鼠标焦点事件。 -->
    <!-- 事件：$("选择器").blur();                      失去鼠标焦点事件。 -->
    <!-- 事件：$("选择器").on('click', function(){});   事件委托。减少事件注册。解决动态增加后代元素的事件绑定问题。原理是事件冒泡。 -->
    <!-- 事件：$("选择器").off('click', function(){});  移除事件。减少事件注册。解决动态增加后代元素的事件绑定问题。原理是事件冒泡。 -->
    <!-- 事件：$("选择器").off();                       移除所有事件。 -->
    <!-- 事件：$("选择器").one('click', function(){});  注册一次性事件。 -->
    <!-- 事件：$("选择器").bind("click", function(){}); 为每个匹配元素的特定事件绑定事件处理函数。 -->
    <!-- 事件：$("input").trigger("click"); -->
    <!-- 事件：$("input").triggerHandler("click"); -->
    <!-- 事件：$("p").unbind("click"); -->
    <!-- 事件：$("p").unbind(); -->
    <!-- 事件：$(window).scroll(function(){}); -->
    <!-- 事件：event.preventDefault();  阻止默认事件行为的触发。 -->
    <!-- 事件：event.stopPropagation(); 防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- AJAX 部分 -->

    <!-- 一、客户端与服务器 -->
    <!-- 1.1 上网的目的 -->
    <!-- 上网的本质目的：通过互联网的形式来获取和消费资源。 -->
    <!-- 1.2 服务器 -->
    <!-- 上网过程中，负责存放和对外提供资源的电脑，叫做服务器。 -->
    <!-- 1.3 客户端 -->
    <!-- 上网过程中，负责获取和消费资源的电脑，叫做客户端。 -->

    <!-- 二、URL地址 -->
    <!-- 2.1 URL概述 -->
    <!-- URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。 -->
    <!-- 常见的URL举例： -->
    <!-- http://www.baidu.com/ -->
    <!-- http://www.taobao.com/ -->
    <!-- http://www.cnblogs.com/liulongbinblogs/p/11649393.html/ -->
    <!-- 2.2 URL组成 -->
    <!-- URL地址一般由三部组成： -->
    <!-- (1).客户端与服务器之间的通信协议。 -->
    <!-- (2).存有该资源的服务器名称。 -->
    <!-- (3).资源在服务器上具体的存放位置。 -->
    <!-- 语法：http://www.cnblogs.com/liuweiweiblogs/ajax/url.html -->
    <!-- 语法：通信协议://服务器名称/资源路径一级目录/资源路径二级目录/具体的存放位置.html -->

    <!-- 三、分析网页的打开过程 -->
    <!-- 3.1 图解客户端与服务器的通信过程 -->
    <!-- (1).客户端请求服务器 -->
    <!-- (2).服务器处理这次请求 -->
    <!-- (3).服务器响应客户端 -->
    <!-- 客户端流程： -->
    <!-- (1).打开浏览器。 -->
    <!-- (2).输入要访问的网站地址。 -->
    <!-- (3).回车，向服务器发起资源请求。 -->
    <!-- 服务器流程： -->
    <!-- (1).服务器接收到客户端发来的资源请求。 -->
    <!-- (2).服务器在内部处理这次请求，找到相关的资源。 -->
    <!-- (3).服务器把找到的资源，响应（发送）给客户端。 -->
    <!-- 注意：客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤。 -->
    <!-- 注意：网页中的每一个资源，都是通过 请求 – 处理 – 响应 的方式从服务器获取回来的。 -->
    <!-- 3.2 基于浏览器的开发者工具分析通信过程 -->
    <!-- (1).打开 Chrome 浏览器。 -->
    <!-- (2).Ctrl+Shift+I 打开 Chrome 的开发者工具。 -->
    <!-- (3).切换到 Network 面板。 -->
    <!-- (4).选中 Doc 页签。 -->
    <!-- (5).刷新页面，分析客户端与服务器的通信过程。 -->

    <!-- 四、服务器对外提供了哪些资源 -->
    <!-- 4.1 例举网页中常见的资源 -->
    <!-- (1).字体。 -->
    <!-- (2).图片。 -->
    <!-- (3).音频。 -->
    <!-- (4).视频。 -->
    <!-- 4.2 数据也是资源 -->
    <!-- 网页中的数据，也是服务器对外提供的一种资源。例如股票数据、各行业排行榜等。 -->
    <!-- 4.3 数据是网页的灵魂 -->
    <!-- (1).HTML       是网页的骨架。 -->
    <!-- (1).CSS        是网页的颜值。 -->
    <!-- (1).Javascript 是网页的行为。 -->
    <!-- (1).Data       数据则是网页的灵魂。 -->
    <!-- 总结：骨架、颜值、行为皆为数据服务数据，在网页中无处不在。 -->
    <!-- 4.4 网页中如何请求数据 -->
    <!-- 数据，也是服务器对外提供的一种资源。只要是资源，必然要通过 请求、处理、响应的方式进行获取。 -->
    <!-- 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。 -->
    <!-- XMLHttpRequest（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。 -->
    <!-- 最简单的用法：var xhrObj = new XMLHttpRequest(); -->
    <!-- 4.5 资源的请求方式 -->
    <!-- 客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为 get 和 post 请求。 -->
    <!-- (1).GET  请求通常用于获取服务端资源（向服务器要资源）。例如：根据 URL 地址，从服务器获取 HTML 文件、css 文件、js文件、图片文件、数据资源等。 -->
    <!-- (2).POST 请求通常用于向服务器提交数据（往服务器发送资源）。例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。 -->

    <!-- 五、了解Ajax -->
    <!-- 5.1 Ajax概述 -->
    <!-- Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。 -->
    <!-- 通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。 -->
    <!-- 5.2 Ajax场景 -->
    <!-- 之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但是，Ajax能让我们轻松实现网页与服务器之间的数据交互。 -->
    <!-- 用户名检测：注册用户时，通过 ajax 的形式，动态检测用户名是否被占用。 -->
    <!-- 搜索提示：当输入搜索关键字时，通过 ajax 的形式，动态加载搜索提示列表。 -->
    <!-- 数据分页显示：当点击页码值的时候，通过 ajax 的形式，根据页码值动态刷新表格的数据。 -->
    <!-- 数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过 ajax 的形式，来实现数据的交互。 -->

    <!-- 四、防抖与节流 -->
    <!-- 4.1 什么是防抖 -->
    <!-- 防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 -->
    <!-- 4.2 防抖的应用场景 -->
    <!-- 用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源； -->
    <!-- 实现输入框的防抖： -->
    <!-- 4.1 什么是节流 -->
    <!-- 节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 -->
    <!-- 4.2 节流的应用场景 -->
    <!-- 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次； -->
    <!-- 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源； -->
    <!-- 节流案例：鼠标跟随效果？ -->
    <!-- 节流阀的概述？ -->
    <!-- 高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。 -->
    <!-- 假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。 -->
    <!-- 上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。 -->
    <!-- 下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。 -->
    <!-- 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。 -->
    <!-- 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。 -->
    <!-- 每次执行操作前，必须先判断节流阀是否为空。 -->
    <!-- 总结： -->
    <!-- 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效，前面 N 多次的触发都会被忽略。 -->
    <!-- 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件。 -->

    <!-- 一、HTTP 协议 -->
    <!-- 1.1 什么是通信 -->
    <!-- 通信，就是信息的传递和交换。 -->
    <!-- 通信三要素： -->
    <!-- 通信的主体 -->
    <!-- 通信的内容 -->
    <!-- 通信的方式 -->
    <!-- 案例：张三要把自己考上传智专修学院的好消息写信告诉自己的好朋友李四。 -->
    <!-- 其中： -->
    <!-- 通信的主体是张三和李四； -->
    <!-- 通信的内容是考上传智专修学院； -->
    <!-- 通信的方式是写信； -->
    <!-- 其中： -->
    <!-- 通信的主体是服务器和客户端浏览器； -->
    <!-- 通信的内容是传智专修学院的简介； -->
    <!-- 通信的方式是响应； -->
    <!-- 1.2 什么是通信协议 -->
    <!-- 通信协议（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。 -->
    <!-- 通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。 -->
    <!-- 互联网中的通信协议： -->
    <!-- 客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。 -->
    <!-- 网页内容又叫做超文本，因此网页内容的传输协议又叫做超文本传输协议（HyperText Transfer Protocol） ，简称 HTTP 协议。 -->
    <!-- 1.3 HTTP -->
    <!-- HTTP 协议即超文本传送协议 (HyperText Transfer Protocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。 -->
    <!-- 例如： -->
    <!-- (1).客户端要以HTTP协议要求的格式把数据提交到服务器。 -->
    <!-- (2).服务器要以HTTP协议要求的格式把内容响应给客户端。 -->
    <!-- HTTP 协议的交互模型: -->
    <!-- HTTP 协议采用了 请求/响应 的交互模型。 -->

    <!-- 二、HTTP 请求 -->
    <!-- 2.1 什么是HTTP请求消息 -->
    <!-- 由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 HTTP 请求，客户端发送到服务器的消息，叫做 HTTP 请求消息。 -->
    <!-- 注意：HTTP 请求消息又叫做 HTTP 请求报文。 -->
    <!-- HTTP 请求消息的组成分部： -->
    <!-- HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。 -->
    <!-- 1.请求行 -->
    <!-- 请求行由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。 -->
    <!-- 2.请求头部 -->
    <!-- 请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。 -->
    <!-- 请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。 -->
    <!-- 3.空行 -->
    <!-- 最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。 -->
    <!-- 请求消息中的空行，用来分隔请求头部与请求体。 -->
    <!-- 4.请求体 -->
    <!-- 请求体中存放的，是要通过 POST 方式提交到服务器的数据。 -->

    <!-- 三、HTTP 响应 -->
    <!-- 2.2 什么是HTTP响应消息 -->
    <!-- 响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。 -->
    <!-- HTTP 响应消息的组成部分： -->
    <!-- HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示： -->
    <!-- 1.状态行 -->
    <!-- 状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开。 -->
    <!-- 2.响应头部 -->
    <!-- 响应头部用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。 -->
    <!-- 3.空行 -->
    <!-- 在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。 -->
    <!-- 响应消息中的空行，用来分隔响应头部与响应体。 -->
    <!-- 4.响应体 -->
    <!-- 响应体中存放的，是服务器响应给客户端的资源内容。 -->

    <!-- 四、HTTP 请求方法 -->
    <!-- 4.1 什么是HTTP请求方法 -->
    <!-- HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。 -->
    <!-- GET     (查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。 -->
    <!-- POST    (新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。 -->
    <!-- PUT     (修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。 -->
    <!-- DELETE  (删除)请求服务器删除指定的资源。 -->
    <!-- HEAD    HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 -->
    <!-- OPTIONS 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 -->
    <!-- CONNECT 建立一个到由目标资源标识的服务器的隧道。 -->
    <!-- TRACE   沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 -->
    <!-- PATCH   是对 PUT 方法的补充，用来对已知资源进行局部更新 。 -->

    <!-- 五、HTTP 响应状态码 -->
    <!-- 5.1 什么是HTTP响应状态码 -->
    <!-- HTTP 响应状态码（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。 -->
    <!-- 响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。 -->
    <!-- HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。 -->
    <!-- HTTP 状态码共分为 5 种类型： -->
    <!-- 1xx 信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到 1** 类型的状态码） -->
    <!-- 2xx 成功，操作被成功接收并处理 -->
    <!-- 3xx 重定向，需要进一步的操作以完成请求 -->
    <!-- 4xx 客户端错误，请求包含语法错误或无法完成请求 -->
    <!-- 5xx 服务器错误，服务器在处理请求的过程中发生了错误 -->
    <!-- 完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- NodeJS 部分 -->




    <!-- 一、Node.js -->
    <!-- 1.1 回顾与思考 -->
    <!-- 1.2 Node.js 简介 -->
    <!-- 1.3 Node.js 环境的安装 -->

    <!-- 二、Node.js fs 模块（文件系统：FileSystem） -->
    <!-- 2.1 什么是 fs 文件系统模块 -->
    <!-- 2.2 读取指定文件中的内容 -->
    <!-- 2.6 fs 模块 - 路径动态拼接的问题 -->

    <!-- 三、Node.js path 模块（路径：Path） -->
    <!-- 3.1 什么是 path 路径模块 -->
    <!-- 3.2 路径拼接 -->
    <!-- 四、Node.js http 模块（超文本传输协议：Hyper Text Transfer Protocol） -->
    <!-- 4.1 什么是 http 模块 -->
    <!-- 4.2 进一步理解 http 模块的作用 -->
    <!-- 4.3 服务器相关的概念 -->
    <!-- 4.5 根据不同的 url 响应不同的 html 内容 -->
    <!-- 4.6 案例：实现 clock 时钟的 web 服务器 -->

    <!-- 五、Node.js 模块化 -->
    <!-- 5.1 什么是模块化 -->
    <!-- 5.2 模块化规范 -->
    <!-- 5.3 Node.js 中模块的分类 -->
    <!-- 5.4 Node.js 模块的加载 -->
    <!-- 5.7 Node.js 模块化规范 -->

    <!-- 六、npm 与 Package（包） -->
    <!-- 6.1 什么是包 -->
    <!-- 6.2 npm 初体验 -->
    <!-- 6.3 在项目中安装包的命令 -->
    <!-- 6.4 初次安装包的相关文件夹及文件 -->
    <!-- 6.5 包的语义人版本规范 -->
    <!-- 6.6 包管理配置文件 -->
    <!-- 6.7 devDependencies 节点 -->
    <!-- 6.8 解决下包速度慢的问题 -->
    <!-- 6.9 包的分类 -->
    <!-- 6.10 规范的包的结构 -->
    <!-- 6.11 开发属于自己的包 -->
    <!-- 6.12 发布包 -->

    <!-- 七、模块的加载机制 -->
    <!-- 7.1 优先从缓存中加载 -->
    <!-- 7.2 内置模块的加载机制 -->
    <!-- 7.3 自定义模块的加载机制 -->
    <!-- 7.4 第三方模块的加载机制 -->
    <!-- 7.5 目录作为模块 -->

    <!-- 八、Express -->
    <!-- 8.1 Express 初识 -->
    <!-- 8.2 Express 静态托管资源 -->
    <!-- 8.3 nodemon -->
    <!-- 8.4 Express 路由（Route） -->
    <!-- 8.6 Express 写接口 -->

    <!-- 九、数据库与身份认证 -->
    <!-- 9.1 Web 开发模式 -->
    <!-- 9.2 身份认证 -->
    <!-- 9.3 Session 认证机制 -->
    <!-- 9.4 在 Express 中使用 Session 认证 -->
    <!-- 9.5 JWT 认证机制 -->
    <!-- 9.6 在 Express 中使用 JWT -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- Vue2 部分 -->




    <!-- 一、webpack 前端化工程章节 -->
    <!-- 1. 小白眼中的前端开发 vs 实际的前端开发。 -->
    <!-- 小白眼中的前端开发： -->
    <!-- 1).会写 HTML + CSS + JavaScript 就会前端开发。 -->
    <!-- 2).需要美化页面样式，就拽一个 bootstrap 过来。 -->
    <!-- 3).需要操作 DOM 或发起 Ajax 请求，再拽一个 jQuery 过来。 -->
    <!-- 4).需要快速实现网页布局效果，就拽一个 Layui 过来。 -->
    <!-- 实际的前端开发： -->
    <!-- 1).模块化（js 的模块化、css 的模块化、资源的模块化）。 -->
    <!-- 2).组件化（复用现有的 UI 结构、样式、行为）。 -->
    <!-- 3).规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理）。 -->
    <!-- 4).自动化（自动化构建、自动部署、自动化测试）。 -->

    <!-- 2. 什么是前端工程化 -->
    <!-- 前端工程化指的是：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。 -->
    <!-- 企业中的 Vue 项目和 React 项目，都是基于工程化的方式进行开发的。 -->
    <!-- 优点：前端开发自成体系，有一套标准的开发方案和流程。 -->

    <!-- 3. 前端工程化的解决方案 -->
    <!-- 早期的前端工程化解决方案： -->
    <!-- 1).grunt（https://www.gruntjs.net/）。 -->
    <!-- 2).gulp（https://www.gulpjs.com.cn/）。 -->
    <!-- 目前主流的前端工程化解决方案： -->
    <!-- 1).webpack（https://www.webpackjs.com/）。 -->
    <!-- 2).parcel（https://zh.parceljs.org/）。 -->

    <!-- WebPack 基本使用 -->
    <!-- 1. 什么是 webpack -->
    <!-- 概念：webpack 是前端项目工程化的具体解决方案。 -->
    <!-- 主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能优化等强大的功能。 -->
    <!-- 好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。 -->
    <!-- 注意：目前Vue、React、Angular等等前端项目，基本上都是基于 webpack 进行工程化开发的。 -->

    <!-- 2. 创建列表隔行变色项目 -->
    <!-- 1).新建项目空白目录，并运行 npm init –y 命令，初始化包管理配置文件 package.json。 -->
    <!-- PS D:\workspace-vue\vue2> npm init -y -->
    <!-- 
    Wrote to D:\workspace-vue\vue2\package.json: 
    {                                                        
        "name": "vue2",                                        
        "version": "1.0.0",                                    
        "description": "",                                     
        "main": "index.js",                                    
        "scripts": {                                           
            "test": "echo \"Error: no test specified\" && exit 1"
        },
        "keywords": [],
        "author": "",
        "license": "ISC"
    }
    -->
    <!-- 2).新建 src 源代码目录。 -->
    <!-- 3).新建 src -> index.html 首页和 src -> index.js 脚本文件。 -->
    <!-- 4).初始化首页基本的结构。 -->
    <!-- 5).运行 npm install jquery –S 命令，安装 jQuery。 -->
    <!-- -S 是--save的简写。 -->
    <!-- -D 是--save-dev的简写。 -->
    <!-- 官网：https://www.npmjs.com/package/webpack -->
    <!-- 
    Install with npm: 
    npm install --save-dev webpack 
    Install with yarn: 
    yarn add webpack --dev 
    -->
    <!-- PS D:\workspace-vue\vue2> npm install jquery -S -->
    <!-- 
    Wrote to D:\workspace-vue\vue2\package.json: 
    {
        "name": "vue2",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "dependencies": {
            "jquery": "^3.7.0"
        }
    }
    -->
    <!-- 6).通过 ES6 模块化的方式导入 jQuery，实现列表隔行变色效果。 -->
    <!-- // 使用 ES6 导入语法，导入第三方 jQuery 模块 -->
    <!-- import $ from 'jquery'; -->

    <!-- 3. 在项目中安装 webpack -->
    <!-- 在终端运行如下的命令，安装 webpack 相关的两个包： -->
    <!-- 指定版本： -->
    <!-- # npm install webpack@5.42.1 webpack-cli@4.7.2 -D -->
    <!-- 不指定版本： -->
    <!-- # npm install webpack webpack-cli -D -->
    <!-- 
    Wrote to D:\workspace-vue\vue2\package.json: 
    {
        "name": "vue2",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
          "test": "echo \"Error: no test specified\" && exit 1"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "dependencies": {
          "jquery": "^3.7.0"
        },
        "devDependencies": {
          "webpack": "^5.88.0",
          "webpack-cli": "^5.1.4"
        }
    }
    -->

    <!-- 4. 在项目中配置 webpack -->
    <!-- 1).在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件，并初始化如下的基本配置。 -->
    <!-- // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
    module.exports = {
        mode: 'development'
    } -->
    <!-- 2).在 package.json 的 scripts 节点下，新增 dev 脚本如下。 -->
    <!-- {
        "name": "vue2",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
          "test": "echo \"Error: no test specified\" && exit 1",
          "dev": "webpack"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "dependencies": {
          "jquery": "^3.7.0"
        },
        "devDependencies": {
          "webpack": "^5.88.0",
          "webpack-cli": "^5.1.4"
        }
    } -->
    <!-- 3).在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包构建。 -->
    <!-- 
    PS D:\workspace-vue\vue2> npm run dev
    > vue2@1.0.0 dev
    > webpack
    asset main.js 319 KiB [emitted] (name: main)
    runtime modules 937 bytes 4 modules
    cacheable modules 279 KiB
      ./src/index.js 289 bytes [built] [code generated]
      ./node_modules/jquery/dist/jquery.js 278 KiB [built] [code generated]
    webpack 5.88.0 compiled successfully in 619 ms
    PS D:\workspace-vue\vue2>
    -->

    <!-- 4.1 mode 的可选值 -->
    <!-- mode 节点的可选值有两个，分别是： -->
    <!-- module.exports = {
        // 开发阶段
        mode: 'development'
    } -->
    <!-- 1).开发环境。 -->
    <!-- 2).不会对打包生成的文件进行代码压缩和性能优化。 -->
    <!-- 3).打包速度快，适合在开发阶段使用。 -->
    <!-- module.exports = {
        // 生产环境
        // mode: 'production'
    } -->
    <!-- 1).生产环境。 -->
    <!-- 2).会对打包生成的文件进行代码压缩和性能优化。 -->
    <!-- 3).打包速度很慢，仅适合在项目发布阶段使用。 -->

    <!-- 4.2 webpack.config.js 文件的作用 -->
    <!-- webpack.config.js 是 webpack 的配置文件。webpack 在真正开始打包构建之前，会先读取这个配置文件，从而基于给定的配置，对项目进行打包。 -->
    <!-- 注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关的语法和模块进行 webpack 的个性化配置。 -->

    <!-- 4.3 webpack 中的默认约定 -->
    <!-- 在 webpack 4.x 和 5.x 的版本中，有如下的默认约定： -->
    <!-- 1).默认的打包入口文件为：src -> index.js -->
    <!-- 2).默认的输出文件路径为：dist -> main.js -->
    <!-- 注意：可以在 webpack.config.js 中修改打包的默认约定。 -->

    <!-- 4.4 自定义打包的入口与出口 -->
    <!-- 在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。 -->
    <!-- 示例代码如下： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段
            mode: 'development',
            // 生产环境
            // mode: 'production',
            // 指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index222.js'),
            // 指定生成的文件要存放到哪里
            output: {
                path: path.join(__dirname, './dist'),
                filename: 'mainPlus.js'
            }
        }
    </script> -->

    <!-- webpack 插件  -->
    <!-- 1. webpack 插件的作用 -->
    <!-- 通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的 webpack 插件有如下两个： -->
    <!-- // webpack-dev-server -->
    <!-- 1).类似于 node.js 阶段用到的 nodemon 工具。 -->
    <!-- 2).每当修改了源代码，webpack 会自动进行项目的打包和构建。 -->
    <!-- // html-webpack-plugin -->
    <!-- 1).webpack 中的 HTML 插件（类似于一个模板引擎插件）。 -->
    <!-- 2).可以通过此插件自定制 index.html 页面的内容。 -->

    <!-- 2. webpack-dev-server 插件 -->
    <!-- 插件 webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。 -->
    <!-- 2.1 安装 webpack-dev-server 插件 -->
    <!-- 运行如下的命令，即可在项目中安装此插件： -->
    <!-- 指定版本： -->
    <!-- # npm install webpack-dev-server@3.11.2 -D -->
    <!-- 不指定版本： -->
    <!-- # npm install webpack-dev-server -D -->
    <!-- 2.2 配置 webpack-dev-server 插件 -->
    <!-- 1).修改 package.json -> scripts 中的 dev 命令如下： -->
    <!-- {
        "name": "vue2",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
          "test": "echo \"Error: no test specified\" && exit 1",
          "dev": "webpack serve"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "dependencies": {
          "jquery": "^3.7.0"
        },
        "devDependencies": {
          "webpack": "^5.88.0",
          "webpack-cli": "^5.1.4",
          "webpack-dev-server": "^4.15.1"
        }
    } -->
    <!-- 2).再次运行 npm run dev 命令，重新进行项目的打包。 -->
    <!-- 3).在浏览器中访问 http://localhost:8080 地址，查看自动打包效果。 -->
    <!-- 注意：webpack-dev-server 会启动一个实时打包的 http 服务器。 -->
    <!-- 2.3 打包生成的文件哪儿去了？ -->
    <!-- 1).不配置 webpack-dev-server 的情况下，webpack 打包生成的文件，会存放到实际的物理磁盘上。 -->
    <!-- 严格遵守开发者在 webpack.config.js 中指定配置。 -->
    <!-- 根据 output 节点指定路径进行存放。 -->
    <!-- 2).配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中。 -->
    <!-- 不再根据 output 节点指定的路径，存放到实际的物理磁盘上。 -->
    <!-- 提高了实时打包输出的性能，因为内存比物理磁盘速度快很多。 -->
    <!-- 2.4 生成到内存中的文件该如何访问？ -->
    <!-- webpack-dev-server 生成到内存中的文件，默认放到了项目的根目录中，而且是虚拟的、不可见的。 -->
    <!-- 可以直接用 / 表示项目根目录，后面跟上要访问的文件名称，即可访问内存中的文件。 -->
    <!-- 例如 /bundle.js 就表示要访问 webpack-dev-server 生成到内存中的 bundle.js 文件。 -->

    <!-- 3. html-webpack-plugin 插件 -->
    <!-- 插件 html-webpack-plugin 是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html 页面的内容。 -->
    <!-- 需求：通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份。 -->
    <!-- 3.1 安装 html-webpack-plugin 插件 -->
    <!-- 运行如下的命令，即可在项目中安装此插件： -->
    <!-- 指定版本： -->
    <!-- # npm install html-webpack-plugin@5.3.2 -D -->
    <!-- 未指定版本： -->
    <!-- # npm install html-webpack-plugin -D -->
    <!-- 3.2 配置 html-webpack-plugin 插件 -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段
            mode: 'development',
            // 生产环境
            // mode: 'production',
            // 通过 html-webpack-plugin 插件将 src 目录下的 index.html 首页复制到项目根目录中一份
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
        }
    </script> -->
    <!-- 3.3 解惑 html-webpack-plugin 插件 -->
    <!-- 1).通过 HTML 插件复制到项目根目录中的 index.html 页面，也被放到了内存中。 -->
    <!-- 2).通过 HTML 插件在生成的 index.html 页面，自动注入了打包的 bundle.js 文件。 -->

    <!-- 4. devServer 节点 -->
    <!-- 在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置，示例代码如下： -->
    <!-- D:\workspace-vue\vue2\webpack.config.js -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
            // 必须重启实时打包的服务器
            devServer: {
                // 初次打包完成后，自动打开浏览器
                open: true,
                // 实时打包所使用的主机地址
                host: "127.0.0.1",
                // 实时打包所使用的端口号
                port: 8080
            }
        }
    </script> -->
    <!-- 注意：凡是修改了 webpack.config.js 配置文件，或修改了 package.json 配置文件，必须重启实时打包的服务器，否则最新的配置文件无法生效。 -->

    <!-- webpack 加载插件 -->
    <!-- 1. loader 概述 -->
    <!-- 在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块，webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ -->
    <!-- 加载插件 loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如： -->
    <!-- 1).css-loader   可以打包处理 .css    相关的文件。 -->
    <!-- 3).less-loader  可以打包处理 .less   相关的文件。 -->
    <!-- 4).babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法。 -->

    <!-- 2. loader 的调用过程 -->
    <!-- 将要被 webpack 打包处理的文件模块。 -->
    <!-- 1).是否为 js 模块。 -->
    <!-- 2).是否包含高级 js 语法。 -->
    <!-- 2).1).是否配置了 bebel。 -->
    <!-- 2).1).1).调用 loader 处理。 -->
    <!-- 2).1).2).报错。 -->
    <!-- 2).2).webpack 进行处理。 -->
    <!-- 2).是否配置了对应 loader 加载插件。 -->
    <!-- 2).1).调用 loader 处理。 -->
    <!-- 2).2).报错。 -->

    <!-- 3. 打包处理 css 文件 -->
    <!-- 指定版本： -->
    <!-- 运行 npm install style-loader@3.0.0 css-loader@5.2.6 -D 命令，安装处理 css 文件的 loader。 -->
    <!-- 未指定版本： -->
    <!-- 运行 npm install style-loader -D 命令，安装处理 css 文件的 loader。 -->
    <!-- 运行 npm install css-loader -D 命令，安装处理 css 文件的 loader。 -->
    <!-- 再在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
            devServer: {
                open: true,
                host: "127.0.0.1",
                port: 8080
            },
            // 所有第三方文件模块的匹配规则
            module: {
                // 文件后缀名的匹配规则
                rules: [
                    {
                        test: /\.css$/,
                        use: ['style-loader', 'css-loader']
                    },
                ]
            }
        }
    </script> -->
    <!-- 其中：test 表示匹配的文件类型，use 表示对应要调用的 loader。 -->
    <!-- 注意： -->
    <!-- 1).use 数组中指定的 loader 顺序是固定的。 -->
    <!-- 2).多个 loader 的调用顺序是：从后往前调用。 -->
    <!-- 然后 index.js 脚本文件中引入样式文件即可： -->
    <!-- <script>
        // 1. 使用 ES6 导入语法，导入第三方jQuery模块。
        import $ from 'jquery';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import './index.css';
        // 2. 定义jQuery的入口函数。
        $(function () {
            // 3.实现奇偶行变色
            $("li:odd").css("background-color", "skyblue");
            $("li:even").css("background-color", "black");
        });
    </script> -->
    <!-- 注意： -->
    <!-- 默认webpack插件只能打包处理.js结尾的文件，处理不了其它后缀的文件。 -->
    <!-- 由于代码中包含了.css样式文件，因此webpack默认处理不了。 -->
    <!-- 如果webpack发现某个文件处理不了的时候，就会查找webpack.config.js配置文件，查看module.rules配置项中，是否配置了对应的loader加载器。 -->
    <!-- 然后webpack会把index.css样式文件，首先转交给最后一个loader加载器进行处理，然后再转交给css-loader加载器。 -->
    <!-- 再当css-loader加载器处理完毕之后，会把处理的结果转交给下一个loader加载器，转交给style-loader加载器。 -->
    <!-- 再当style-loader加载器处理完毕之后，发现没有下一个loader之后，于是把处理的结果转交给webpack。 -->
    <!-- 最后webpack会把style-loader加载器处理的结果，合并到/dist/bundle.js配置文件中，最终生成打包好的文件。 -->

    <!-- 4. 打包处理 less 文件 -->
    <!-- 指定版本： -->
    <!-- 1).运行 npm i less-loader@10.0.1 less@4.1.1 -D 命令。 -->
    <!-- 未指定版本： -->
    <!-- # npm install less-loader -D -->
    <!-- # npm install less -D -->
    <!-- 2).再在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
            devServer: {
                open: true,
                host: "127.0.0.1",
                port: 8080
            },
            // 所有第三方文件模块的匹配规则
            module: {
                // 文件后缀名的匹配规则
                rules: [
                    {
                        test: /\.css$/,
                        use: ['style-loader', 'css-loader']
                    },
                    {
                        test: /\.less$/,
                        use: ['style-loader', 'css-loader', 'less-loader']
                    }
                ]
            }
        }
    </script> -->

    <!-- 5. 打包处理样式表中与 url 路径相关的文件 -->
    <!-- 未指定版本： -->
    <!-- npm install url-loader -D -->
    <!-- npm install file-loader -D -->
    <!-- 1).运行 npm install url-loader@4.1.1 file-loader@6.2.0 -D 命令。 -->
    <!-- 2).再在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
            devServer: {
                open: true,
                host: "127.0.0.1",
                port: 8080
            },
            // 所有第三方文件模块的匹配规则
            module: {
                // 文件后缀名的匹配规则
                rules: [
                    {
                        test: /\.css$/,
                        use: ['style-loader', 'css-loader']
                    },
                    {
                        test: /\.less$/,
                        use: ['style-loader', 'css-loader', 'less-loader']
                    },
                    {
                        test: /\.jpg|png|gif$/,
                        use: ['url-loader?limit=22229']
                    }
                ]
            }
        }
    </script> -->
    <!-- <script>
        // 1. 使用 ES6 导入语法，导入第三方jQuery模块。
        import $ from 'jquery';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import './index.css';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import './index.less';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import logo from './images/logo.png';
        // 2. 定义jQuery的入口函数。
        $(function () {
            // 3.实现奇偶行变色
            $("li:odd").css("background-color", "skyblue");
            $("li:even").css("background-color", "black");
        });
        $(".box").attr('src', logo);
    </script> -->
    <!-- 其中问号（?）之后的是 loader 的参数项： -->
    <!-- 1).limit=22229 用来指定图片的大小，单位是字节（byte）。 -->
    <!-- 2).只有大于等于（<= limit）大小的图片，才会被转为 base64 格式的图片。 -->

    <!-- 6. 打包处理 js 文件中的高级语法 -->
    <!-- webpack 只能打包处理一部分高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借助于 babel-loader 进行打包处理。 -->
    <!-- 例如 webpack 无法处理下面的 JavaScript 代码： -->
    <!-- <script>
        function info(target) {
            target.info = 'person info'
        }
        @info class Person { }
        console.log(Person.info);
    </script> -->
    <!-- 6.1 安装 babel-loader 相关的包 -->
    <!-- 运行如下的命令安装对应的依赖包： -->
    <!-- # npm install @babel/core -D -->
    <!-- # npm install @babel/plugin-proposal-decorators -D -->
    <!-- # npm install babel-loader -D -->
    <!-- # npm install babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D -->
    <!-- 在 webpack.config.js 的 module -> rules 数组中，添加 loader 规则如下： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins],
            devServer: {
                open: true,
                host: "127.0.0.1",
                port: 8080
            },
            // 所有第三方文件模块的匹配规则
            module: {
                // 文件后缀名的匹配规则
                rules: [
                    {
                        test: /\.css$/,
                        use: ['style-loader', 'css-loader']
                    },
                    {
                        test: /\.less$/,
                        use: ['style-loader', 'css-loader', 'less-loader']
                    },
                    {
                        test: /\.jpg|png|gif$/,
                        use: ['url-loader?limit=22229']
                    },
                    {
                        test: /\.js$/,
                        use: ['babel-loader'],
                        exclude: /node_modules/
                    }
                ]
            }
        }
    </script> -->
    <!-- 6.2 配置 babel-loader -->
    <!-- 在项目根目录下，创建名为 babel.config.js 的配置文件，定义 Babel 的配置项如下： -->
    <!-- D:\workspace-vue\vue2\babel.config.js -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 将来webpack在调用babel-loader的时候会先加载plugins插件来使用。
            plugins: [['@babel/plugin-proposal-decorators', {legacy: true}]]
        }
    </script> -->
    <!-- 声明可用的插件 -->
    <!-- 详情请参考Babel的官网：https://babeljs.io/docs/en/babel-plugin-proposal-decorators -->

    <!-- 打包发布 -->
    <!-- 1. 为什么要打包发布 -->
    <!-- 项目开发完成之后，需要使用 webpack 对项目进行打包发布，主要原因有以下两点： -->
    <!-- 1).开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件。 -->
    <!-- 2).开发环境下，打包生成的文件不会进行代码压缩和性能优化。 -->
    <!-- 为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。 -->
    <!-- 2. 配置 webpack 的打包发布 -->
    <!-- 在 package.json 文件的 scripts 节点下，新增 build 命令如下： -->
    <!-- 参数：webpack    是前缀。 -->
    <!-- 参数：--model    是一个参数项，用来指定 webpack 的运行模式。 -->
    <!-- 参数：production 是代表生产环境，会对打包生成的文件进行代码压缩和性能优化。 -->
    <!-- 注意：通过 --model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项。 -->
    <!-- <script>
        {
        "name": "vue2",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1",
            // 运行开发（内存中serve）
            "dev": "webpack serve",
            // 构建打包（webpack类似于后端maven）
            "build": "webpack --mode production"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "dependencies": {
            "jquery": "^3.7.0"
        },
        "devDependencies": {
            "@babel/core": "^7.22.5",
            "@babel/plugin-proposal-decorators": "^7.22.5",
            "babel-loader": "^9.1.2",
            "css-loader": "^6.8.1",
            "file-loader": "^6.2.0",
            "html-webpack-plugin": "^5.5.3",
            "less": "^4.1.3",
            "less-loader": "^11.1.3",
            "style-loader": "^3.3.3",
            "url-loader": "^4.1.1",
            "webpack": "^5.88.0",
            "webpack-cli": "^5.1.4",
            "webpack-dev-server": "^4.15.1"
        }
        }
    </script> -->
    <!-- 3. 把 JavaScript 文件统一生成到 js 目录中 -->
    <!-- 在 webpack.config.js 配置文件的 output 节点中，进行如下的配置： -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                // 打包部署（脚本文件存放js目录中）
                filename: './js/main.js'
            },
        }
    </script> -->
    <!-- 4. 把图片文件统一生成到 image 目录中 -->
    <!-- 修改 webpack.config.js 中的 url-loader 配置项，新增 outputPath 选项即可指定图片文件的输出路径： -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 所有第三方文件模块的匹配规则
            module: {
                // 文件后缀名的匹配规则
                rules: [
                    {
                        test: /\.css$/,
                        use: ['style-loader', 'css-loader']
                    },
                    {
                        test: /\.less$/,
                        use: ['style-loader', 'css-loader', 'less-loader']
                    },
                    {
                        test: /\.jpg|png|gif$/,
                        // 打包部署（图片存放目录images）
                        use: ['url-loader?limit=22229&outputPath=images']
                    },
                    {
                        test: /\.js$/,
                        use: ['babel-loader'],
                        exclude: /node_modules/
                    }
                ]
            }
        }
    </script> -->
    <!-- 5. 自动清理 dist 目录下的旧文件 -->
    <!-- 第一步：官网搜索插件（https://www.npmjs.com/package/clean-webpack-plugin） -->
    <!-- 第二步：输入插件名称（clean-webpack-plugin） -->
    <!-- 第三步：Installation命令（npm install --save-dev clean-webpack-plugin） -->
    <!-- # npm install --save-dev clean-webpack-plugin -->
    <!-- # npm install -D clean-webpack-plugin -->
    <!-- 为了在每次打包发布时自动清理掉 dist 目录中的旧文件，可以安装并配置 clean-webpack-plugin 插件： -->
    <!-- <script>
        {
            "devDependencies": {
                "clean-webpack-plugin": "^4.0.0",
            }
        }
    </script> -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        const HtmlPlugin = require('html-webpack-plugin');
        // 解释：左侧花括号的意思是解构赋值
        const { CleanWebpackPlugin } = require('clean-webpack-plugin');
        // 1. 创建 HTML 插件的实例对象
        const htmlPlugins = new HtmlPlugin({
            // 指定原文件的存放路径
            template: './src/index.html',
            // 指定生成的文件的存放路径
            filename: './index.html'
        });
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins, new CleanWebpackPlugin()],
        }
    </script> -->

    <!-- Source Map -->
    <!-- 1. 生产环境遇到的问题 -->
    <!-- 前端项目在投入生产环境之前，都需要对 JavaScript 源代码进行压缩混淆，从而减小文件的体积，提高文件的加载效率。 -->
    <!-- 此时就不可避免的产生了另一个问题： -->
    <!-- 对压缩混淆之后的代码除错（debug）是一件极其困难的事情。 -->
    <!-- 1).变量被替换成没有任何语义的名称。 -->
    <!-- 2).空行和注释被剔除。 -->
    <!-- 2. 什么是 Source Map -->
    <!-- Source Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着压缩混淆后的代码，所对应的转换前的位置。 -->
    <!-- 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试。 -->
    <!-- 3. webpack 开发环境下的 Source Map -->
    <!-- 在开发环境下，webpack 默认启用了 Source Map 功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码： -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 在开发调试阶段，建议使用devtool的值设置为（eval-source-map）
            devtool: 'eval-source-map',
            // 开发阶段（开发环境mode: 'development',，生产环境mode: 'production',）
            mode: 'development',
            // 自定义打包入口：指定要处理的哪个文件
            entry: pathModule.join(__dirname, './src/index.js'),
            // 自定义打包出口：指定生成的文件要存放到哪里
            output: {
                path: pathModule.join(__dirname, './dist'),
                filename: './js/main.js'
            },
            // 通过plugins节点使用htmlPlugins插件生效
            plugins: [htmlPlugins, new CleanWebpackPlugin()],
            devServer: {
                open: true,
                host: "127.0.0.1",
                port: 8080
            },
        }
    </script> -->
    <!-- 3.1 默认 Source Map 的问题 -->
    <!-- 开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。示意图如下： -->
    <!-- 3.2 解决默认 Source Map 的问题 -->
    <!-- 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致： -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 开发阶段（开发环境mode: 'development',，生产环境mode: 'production',）
            mode: 'development',
            // 在开发调试阶段，建议使用devtool的值设置为（eval-source-map）
            devtool: 'eval-source-map',
            // 省略其它配置项...
        }
    </script> -->
    <!-- 4. webpack 生产环境下的 Source Map -->
    <!-- 在生产环境下，如果省略了 devtool 选项，则最终生成的文件中不包含 Source Map。这能够防止原始代码通过 Source Map 的形式暴露给别有所图之人。 -->
    <!-- 4.1 只定位行数不暴露源码 -->
    <!-- 在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以将 devtool 的值设置为nosources-source-map。实际效果如图所示： -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 在开发调试阶段，建议使用devtool的值设置为（eval-source-map）
            devtool: 'nosources-source-map',
            // 省略其它配置项...
        }
    </script> -->
    <!-- 4.2 定位行数且暴露源码 -->
    <!-- 在生产环境下，如果想在定位报错行数的同时，展示具体报错的源码。此时可以将 devtool 的值设置为source-map。实际效果如图所示： -->
    <!-- <script>
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            // 在开发调试阶段，建议使用devtool的值设置为（eval-source-map）
            devtool: 'source-map',
            // 省略其它配置项...
        }
    </script> -->
    <!-- 5. Source Map 的最佳实践 -->
    <!-- 开发环境下： -->
    <!-- 1).建议把 devtool 的值设置为（eval-source-map）。 -->
    <!-- 2).好处：可以精准定位到具体的错误行。 -->
    <!-- <script>
        module.exports = {
            devtool: 'eval-source-map',
            // 省略其它配置项...
        }
    </script> -->
    <!-- 生产环境下： -->
    <!-- 1).建议关闭 Source Map 或将 devtool 的值设置为（nosources-source-map）。 -->
    <!-- 2).好处：防止源码泄露，提高网站的安全性。 -->
    <!-- <script>
        module.exports = {
            devtool: 'nosources-source-map',
            // 省略其它配置项...
        }
    </script> -->
    <!-- 6. 配置艾特（@）符号代替指定目录 -->
    <!-- <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            resolve: {
                alias: {
                    // 告诉webpack指定代码中@艾特符号表示./src/这一层目录
                    '@': pathModule.join(__dirname, './src/')
                }
            }
        }
    </script> -->
    <!-- 其他文件引入可优化？ -->
    <!-- <script>
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import '@/css/index.css';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import '@/css/index.less';
        // 1. 使用 ES6 导入语法，导入自定义模块。
        import logo from '@/images/logo.png';
    </script> -->
    <!-- 7. 谷歌浏览器（Google Chrome）安装（vue-devtools）工具 -->
    <!-- 第一步：打开谷歌浏览器，点击右上角三个小点（自定义控制Google Chrome）。 -->
    <!-- 第二步：选择扩展程序，点击管理扩展程序。 -->
    <!-- 第三步：把插件拖进来即可，文件：vue_devtools_chrome_5.3.4.crx。 -->
    <!-- 第四步：点击此插件（Vue.js devtools 5.3.4）详情，进入详情页面。 -->
    <!-- 第五步：勾选（允许访问文件网址）打开。 -->

    <!-- 实际开发中需要自己配置 webpack 吗？ -->
    <!-- 答案：不需要。 -->
    <!-- 1).实际开发中会使命令行工具（俗称 CLI）一键生成带有 webpack 的项目。 -->
    <!-- 1).开箱即用，所有 webpack 配置项都是现成的。 -->
    <!-- 1).我们只需要知道 webpack 中的基本概念即可。 -->
    <!-- 能够掌握 webpack 的基本使用？ -->
    <!-- 回答：安装、webpack.config.js、修改打包入口。 -->
    <!-- 了解常用的 plugin 的基本使用？ -->
    <!-- 回答：webpack-dev-server、html-webpack-plugin。 -->
    <!-- 了解常用的 loader 的基本使用？ -->
    <!-- 回答：loader 的作用、loader 的调用过程。 -->
    <!-- 能够说出 Source Map 的作用？ -->
    <!-- 回答：精准定位到错误行并显示对应的源码。 -->
    <!-- 回答：方便开发者调试源码中的错误。 -->

    <!-- 二、vue 基础章节 -->
    <!-- 1. vue 概念 -->
    <!-- 官方给出的概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架。 -->
    <!-- 1.构建用户界面 -->
    <!-- 使用vue往html页面中填充数据，非常的方便。 -->
    <!-- 2.框架 -->
    <!-- 框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能。 -->
    <!-- 要学习vue，就是在学习vue框架中规定的用法。 -->
    <!-- vue的指令、组件（是对UI结构的复用）、路由、Vuex、Vue组件库。 -->

    <!-- 2. vue 特性 -->
    <!-- vue 框架的特性，主要体现在如下两方面： -->
    <!-- 1).数据驱动视图 -->
    <!-- 数据的变化会驱动视图自动更新。 -->
    <!-- 优点：程序员只管把数据维护好，那么页面结构会被vue自动渲染出来。 -->
    <!-- 2).双向数据绑定 -->
    <!-- 在网页中，form表单负责采集数据，ajax负责提交数据。 -->
    <!-- js数据的变化，会被自动渲染到页面上。 -->
    <!-- 页面上表单采集的数据发生变化的时候，会被vue自动获取到，并且更新到js数据中。 -->
    <!-- 2.1 数据驱动视图 -->
    <!-- 在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。示意图如下： -->
    <!-- 好处：当页面数据发生变化时，页面会自动重新渲染！ -->
    <!-- 注意：数据驱动视图是单向的数据绑定。 -->
    <!-- 2.2 双向数据绑定 -->
    <!-- 在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中。示意图如下： -->
    <!-- 好处：开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值！ -->
    <!-- 2.3 MVVM 概念 -->
    <!-- MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM 指的是（Model、View、ViewModel）。 -->
    <!-- 它把每个 HTML 页面都拆分成了这三个部分，如图所示：在 MVVM 概念中： -->
    <!-- 2).View      表示当前页面所渲染的 DOM 结构。 -->
    <!-- 3).ViewModel 表示 vue 的实例，它是 MVVM 的核心。 -->
    <!-- 1).Model     表示当前页面渲染时所依赖的数据源。 -->
    <!-- 2.4 MVVM 工作原理 -->
    <!-- ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。 -->
    <!-- 1).当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构。 -->
    <!-- 2).当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中。 -->
    <!-- 【View】<-自动更新<-【ViewModel】<-监听数据源变化<-【Model】。 -->
    <!-- 【View】->监听DOM变化->【ViewModel】->自动同步->【Model】。 -->

    <!-- 3. vue 版本 -->
    <!-- 当前，vue 共有 3 个大版本，其中： -->
    <!-- 2.x 版本的 vue 是目前企业级项目开发中的主流版本。 -->
    <!-- 3.x 版本的 vue 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广。 -->
    <!-- 1.x 版本的 vue 几乎被淘汰，不再建议学习与使用。 -->
    <!-- 总结： -->
    <!-- 3.x 版本的 vue 是未来企业级项目开发的趋势； -->
    <!-- 2.x 版本的 vue 在未来（1~2年内）会被逐渐淘汰； -->

    <!-- vue 基本使用 -->
    <!-- 1. 基本使用步骤 -->
    <!-- 1).导入 vue.js 的 script 脚本文件。 -->
    <!-- <script src="./lib/vue-2.6.12.js"></script> -->
    <!-- 2).在页面中声明一个将要被 vue 所控制的 DOM 区域。 -->
    <!-- <div id="app">
        {{ message }}
    </div> -->
    <!-- 3).创建 vm（ViewModule）实例对象（vue 实例对象）。 -->
    <!-- <script>
        const viewModule = new Vue({
            el: "#app",
            data: {
                message: "Hello World"
            }
        });
    </script> -->
    <!-- 4).查看谷歌浏览器（Google Chrome）Vue调试工具（Vue DevTools） -->
    <!-- 打开谷歌浏览器，点击右上角魔方图标（扩展程序），点击后弹出扩展程序，点击（固定）就会在左侧显示出（Vue DevTools）图标。 -->
    <!-- 启动Vue项目，打开浏览器页面，按F12进入调试窗口，在导航栏会多出（Vue）菜单。 -->
    <!-- 显示：Ready. Detected Vue 2.6.12.版本。 -->
    <!-- 菜单：Components、Vuex、Events、Routing、Performance、Settings、Refresh。 -->
    <!-- 对象：<Root> = #vm0对象。点击右侧显示对应el挂载点，data数据对象，methods函数列表。 -->

    <!-- 2. 基本代码与 MVVM 的对应关系 -->
    <!-- 第一步：导入vue.js的脚本（Script）文件。 -->
    <!-- <script src="./lib/vue-2.6.12.js"></script> -->
    <!-- 第二步：【View 视图区域】在页面中声明一个将要被vue对象所控制的DOM区域。 -->
    <!-- <div id="app">
        {{ message }}
    </div> -->
    <!-- 第三步：创建ViewModel实例对象（vue.js实例对象）。 -->
    <!-- <script>
        // 【ViewModel 实例对象vm】
        const viewModule = new Vue({
            // 【View 视图区域】
            el: "#app",
            // 【Model 数据源】
            data: {
                message: "Hello World"
            }
        });
    </script> -->

    <!-- vue 调试工具 -->
    <!-- 第四步：安装 vue-devtools 调试工具。 -->
    <!-- vue 官方提供的 vue-devtools 调试工具，能够方便开发者对 vue 项目进行调试与开发。 -->
    <!-- Chrome 浏览器在线安装 vue-devtools ： -->
    <!-- https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd -->
    <!-- FireFox 浏览器在线安装 vue-devtools ： -->
    <!-- https://addons.mozilla.org/zh-CN/firefox/addon/vue-js-devtools/ -->
    <!-- 2. 配置 Chrome 浏览器中的 vue-devtools -->
    <!-- 点击 Chrome 浏览器右上角的 按钮，选择更多工具 -> 扩展程序 -> Vue.js devtools 详细信息，并勾选如下的两个选项： -->
    <!-- 注意：修改完配置项，须重启浏览器才能生效。 -->
    <!-- 3. 使用 vue-devtools 调试 vue 页面 -->
    <!-- 在浏览器中访问一个使用了 vue 的页面，打开浏览器的开发者工具，切换到 Vue 面板，即可使用 vue-devtools 调试当前的页面。 -->
    <!-- 4).查看谷歌浏览器（Google Chrome）Vue调试工具（Vue DevTools） -->
    <!-- 打开谷歌浏览器，点击右上角魔方图标（扩展程序），点击后弹出扩展程序，点击（固定）就会在左侧显示出（Vue DevTools）图标。 -->
    <!-- 启动Vue项目，打开浏览器页面，按F12进入调试窗口，在导航栏会多出（Vue）菜单。 -->
    <!-- 显示：Ready. Detected Vue 2.6.12.版本。 -->
    <!-- 菜单：Components、Vuex、Events、Routing、Performance、Settings、Refresh。 -->
    <!-- 对象：<Root> = #vm0对象。点击右侧显示对应el挂载点，data数据对象，methods函数列表。 -->

    <!-- vue 指令与过滤器 -->
    <!-- 1. 指令的概念 -->
    <!-- 指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。 -->
    <!-- vue 中的指令按照不同的用途可以分为如下 6 大类： -->
    <!-- 1).内容渲染指令。 -->
    <!-- 2).属性绑定指令。 -->
    <!-- 3).事件绑定指令。 -->
    <!-- 4).双向绑定指令。 -->
    <!-- 5).条件渲染指令。 -->
    <!-- 6).列表渲染指令。 -->
    <!-- 注意：指令是 vue 开发中最基础、最常用、最简单的知识点。 -->

    <!-- 1.1 内容渲染指令 -->
    <!-- 内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个： -->
    <!-- 1). v-text 指令。 -->
    <!-- 2). {{ }}  指令。 -->
    <!-- 3). v-html 指令。 -->
    <!-- v-text -->
    <!-- 用法示例： -->
    <!-- 注意：v-text 指令会覆盖元素内默认的值。 -->
    <!-- {{ }} 语法 -->
    <!-- vue 提供的 {{ }} 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 {{ }} 语法的专业名称是插值表达式（英文名为：Mustache）。 -->
    <!-- 注意：相对于 v-text 指令来说，插值表达式在开发中更常用一些！因为它不会覆盖元素中默认的文本内容。 -->
    <!-- v-html -->
    <!-- v-text 指令和插值表达式只能渲染纯文本内容。如果要把包含 HTML 标签的字符串渲染为页面的 HTML 元素，则需要用到 v-html 这个指令： -->
    <!-- 最终渲染的结果为： -->
    <!-- 
    <div id="app">
        // 自定义属性表达式（会覆盖元素内部原有的内容，不建议使用。）
        <p v-text="username"></p>
        <p v-text="gender">2023</p>
        <hr>
        // 插值表达式（实际开发中用得最多，只是内容的占位符，不会覆盖原来的数据。注意：只能用在内容节点，不能用在元素的属性节点上。）
        <p>姓名：{{ username }}</p>
        <p>性别：{{ gender }}</p>
        <hr>
        <div v-text="info"></div>
        <div>{{ info }}</div>
        // v-html 指令的作用：可以把带有标签的字符串，渲染成真正的HTML内容。
        <div v-html="info"></div>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            el: "#app",
            data: {
                username: "LiuWeiWei",
                gender: "男士",
                info: '<h4 style="color:red;font-weight:bold;">欢迎光临</>',
                message: "Hello World"
            }
        });
    </script>
    -->

    <!-- 1.2 属性绑定指令 -->
    <!-- 如果需要为元素的属性动态绑定属性值，则需要用到 v-bind 属性绑定指令。用法示例如下： -->
    <!-- 属性绑定指令的简写形式。 -->
    <!-- 由于 v-bind 指令在开发中使用频率非常高，因此，vue 官方为其提供了简写形式，简写为英文的（:）。 -->
    <!-- <div id="app">
        // 01.自定义属性表达式（会覆盖元素内部原有的内容，不建议使用。）
        // 02.插值表达式（实际开发中用得最多，只是内容的占位符，不会覆盖原来的数据。）
        // 03.v-html 指令的作用：可以把带有标签的字符串，渲染成真正的HTML内容。
        // 04.插值表达式（实际开发中用得最多，只是内容的占位符，不会覆盖原来的数据。注意：只能用在内容节点，不能用在元素的属性节点上。）
        <input type="text" placeholder="{{ message }}"><br>
        // 04.如果需要为元素属性动态绑定值的时候，需要使用v-bind自定义指令（属性）。简写：英文冒号（:）即可。比如（:src="photo"）。
        <input type="text" v-bind:placeholder="message"><br>
        <img v-bind:src="photo" alt="" style="width: 300px;"><br>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            el: "#app",
            data: {
                username: "LiuWeiWei",
                gender: "男士",
                photo: "./images/logo.jpeg",
                info: '<h4 style="color:red;font-weight:bold;">欢迎光临</>',
                message: "Hello World"
            }
        });
    </script> -->
    <!-- 使用 Javascript 表达式。 -->
    <!-- 在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算，例如： -->
    <!-- <div id="app">
        // JS 表达式支持运算或者其它操作
        插值运算：{{ number + 10 }}<br>
        反转之前内容：{{ tips }}，反转之后内容：{{ tips.split('').reverse().join('') }}<br>
        <div :title="'索引或下标：' + index">鼠标悬浮上来看看动态数据源吧</div>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            el: "#app",
            data: {
                index: 1,
                number: 28,
                username: "LiuWeiWei",
                gender: "男士",
                photo: "./images/logo.jpeg",
                info: '<h4 style="color:red;font-weight:bold;">欢迎光临</>',
                message: "Hello World",
                tips: "请反转此段内容吧"
            }
        });
    </script> -->

    <!-- 1.3 事件绑定指令 -->
    <!-- vue 提供了 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听。 -->
    <!-- 语法格式如下： -->
    <!-- 注意：原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup。 -->
    <!-- 通过 v-on 绑定的事件处理函数，需要在 methods 节点中进行声明： -->
    <!-- 由于 v-on 指令在开发中使用频率非常高，因此，vue 官方为其提供了简写形式（简写为英文的 @ ）。 -->
    <!-- 在原生的 DOM 事件绑定中，可以在事件处理函数的形参处，接收事件参数对象 event。 -->
    <!-- 同理，在 v-on 指令（简写为 @ ）所绑定的事件处理函数中，同样可以接收到事件参数对象 event，示例代码如下： -->
    <!-- 在使用 v-on 指令绑定事件时，可以使用小括号 ( ) 进行传参，示例代码如下： -->
    <!-- <div id="app">
        <p>统计Count的值是：{{ count }}</p>
        // v-on指令：可以被简写为艾特符号（@click等于v-on:click）。就像之前绑定属性使用简写英文冒号（:src等于v-bind:src）。
        // vue提供了内置变量，名字叫做（$event）固定写法，它就是原生DOM的事件对象（Event）。
        <button v-on:click="vOnClickAddEvent()" class="btn-add">+1</button>
        <button @click="vOnClickSubEvent()" class="btn-sub">-1</button>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                count: 1,
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                vOnClickAddEvent: function () {
                    console.log(viewModule === this);
                    if (viewModule.count > 9) {
                        $(".btn-add").attr("disabled", "disabled");
                    } else {
                        viewModule.count++;
                        console.log(viewModule.count);
                    }
                },
                vOnClickSubEvent: function () {
                    console.log(viewModule === this);
                    if (viewModule.count < 1) {
                        $(".btn-sub").attr("disabled", "disabled");
                    } else {
                        viewModule.count--;
                        console.log(viewModule.count);
                    }
                }
            }
        });
    </script> -->

    <!-- $event 对象 -->
    <!-- $event 是 vue 提供的特殊变量，用来表示原生的事件参数对象 event。$event 可以解决事件参数对象 event 被覆盖的问题。 -->
    <!-- 示例用法如下： -->
    <!-- v-on指令：可以被简写为艾特符号（@click等于v-on:click）。就像之前绑定属性使用简写英文冒号（:src等于v-bind:src） -->
    <!-- vue提供了内置变量，名字叫做（$event）固定写法，它就是原生DOM的事件对象（Event）。 -->
    <!-- <div id="app">
        // $event应用场景，如果默认的事件对象event被覆盖了，则可以手动传递这个$evnet事件对象。
        <a href="https://www.baidu.com/" @click="baidu($event)">百度搜索</a>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                count: 1,
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                baidu: function (event) {
                    event.preventDefault();
                    console.log(`已经跳转`);
                }
            }
        });
    </script> -->

    <!-- 事件修饰符 -->
    <!-- 在事件处理函数中调用 event.preventDefault() 防止默认提交行为或 event.stopPropagation() 停止传播（冒泡）是非常常见的需求。 -->
    <!-- 因此，vue 提供了事件修饰符的概念，来辅助程序员更方便的对事件的触发进行控制。常用的 5 个事件修饰符如下： -->
    <!-- 修饰符    说明 -->
    <!-- .prevent 阻止默认行为。例如：阻止a链接的跳转，阻止表单的提交等等。 -->
    <!-- .stop    阻止事件冒泡。 -->
    <!-- .capture 以捕获模式触发当前的事件处理函数。 -->
    <!-- .once    绑定的事件只触发一次。 -->
    <!-- .self    只有在event.target是当前元素自身时触发事件处理函数。 -->
    <!-- 语法格式如下： -->
    <!-- <div id="app">
        // $event是vue提供的特殊变量，用来表示原生的事件参数对象event。$event可以解决事件参数对象event被覆盖的问题。
        // @click.prevent防止默认提交行为。
        // @click.stop停止传播（冒泡）。
        <a href="https://www.baidu.com/" @click="baidu($event)">百度搜索</a>
        <a href="https://www.baidu.com/" @click.prevent="google()">谷歌搜索</a>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                count: 1
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                baidu: function (event) {
                    event.preventDefault();
                    console.log(`百度已经跳转`);
                },
                google: function () {
                    console.log(`谷歌已经跳转`);
                }
            }
        });
    </script> -->

    <!-- 按键修饰符 -->
    <!-- 在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符，例如： -->
    <!-- <div id="app">
        // $event是vue提供的特殊变量，用来表示原生的事件参数对象event。$event可以解决事件参数对象event被覆盖的问题。
        // @click.prevent防止默认提交行为。
        // @click.stop停止传播（冒泡）。
        <a href="https://www.baidu.com/" @click="baidu($event)">原生DOM事件Event对象</a>
        <a href="https://www.baidu.com/" @click.prevent="google()">vue修饰符阻止默认提交行为</a>
        <a href="https://www.baidu.com/" @click.prevent="google()">vue修饰符停止传播冒泡</a>
        // @keyup.esc键盘事件。
        // @keyup.enter键盘事件。
        <input type="text" @keyup.esc="clearValue($event)"><br>
        <input type="text" @keyup.enter="clearValue($event)"><br>
    </div> -->

    <!-- 1.4 双向绑定指令 -->
    <!-- vue 提供了 v-model 双向数据绑定指令，用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。 -->
    <!-- <div id="app">
        // v-model指令：双向数据绑定指令，用来辅助开发者在不操作DOM的前提下，快速获取表单的数据。只有表单元素使用才有意义。
        <p>用户的名字：{{ username }}</p><br>
        <input type="text" v-model:value="username"><br>
        <select v-model="city">
            <option value="">请选择城市</option>
            <option value="1">北京市</option>
            <option value="2">上海市</option>
            <option value="3">广州市</option>
            <option value="4">深圳市</option>
        </select><br>
        // v-bind指令：单向数据绑定指令。
        <input type="text" v-bind:value="username">
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                username: "LiuWeiWei",
                city: "",
            }
        });
    </script> -->

    <!-- v-model 指令的修饰符 -->
    <!-- 为了方便对用户输入的内容进行处理，vue 为 v-model 指令提供了 3 个修饰符，分别是： -->
    <!-- 修饰符   作用 -->
    <!-- .number 自动将用户的输入值转为数值类型。比如：<input v-model.number="age"/> -->
    <!-- .trim   自动过滤用户输入的首尾空白字符。比如：<input v-model.trim="msg"/> -->
    <!-- .lazy   在[change]时而非[input]时更新。比如：<input v-model.lazy="msg"/> -->
    <!-- 示例用法如下： -->
    <!-- <div id="app">
        // v-model指令：双向数据绑定指令，加个修饰符。
        <input type="text" v-model.number="n1">+<input type="text" v-model.number="n2">=<span>{{n1+n2}}</span><br>
        <input type="text" v-model.trim:value="username"><br>
        <input type="text" v-model.lazy:value="username"><br>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                n1: 0,
                n2: 0,
                index: 1,
                count: 1,
                number: 28,
                username: "LiuWeiWei",
                gender: "男士",
                city: "",
            },
        });
    </script> -->

    <!-- 1.5 条件渲染指令 -->
    <!-- 条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是： -->
    <!-- 1).v-if   指令会动态地创建或移除（DOM）元素，从而控制元素在页面上的显示与隐藏； -->
    <!-- 1).v-show 指令会动态为元素添加或移除（style="display:none;"）样式，从而控制元素的显示与隐藏； -->
    <!-- 示例用法如下： -->

    <!-- v-if 和 v-show 的区别 -->
    <!-- 实现原理不同： -->
    <!-- 1).v-if   指令会动态地创建或移除 DOM 元素，从而控制元素在页面上的显示与隐藏； -->
    <!-- 2).v-show 指令会动态为元素添加或移除 style="display: none;" 样式，从而控制元素的显示与隐藏； -->
    <!-- 性能消耗不同： -->
    <!-- v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此： -->
    <!-- 如果需要非常频繁地切换，则使用 v-show 较好。 -->
    <!-- 如果在运行时条件很少改变，则使用 v-if 较好。 -->
    <!-- <div id="app">
        // v-if指令：指令会动态地创建或移除（DOM）元素。
        <p v-if="flag">这段文字是被v-if指令所控制的元素。</p>
        // v-show指令：指令会动态为元素添加或移除（style="display:none;"）样式。
        <p v-show="flag">这段文字是被v-show指令所控制的元素。</p>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                flag: true
            },
        });
    </script> -->

    <!-- v-else -->
    <!-- v-if 可以单独使用，或配合 v-else 指令一起使用： -->
    <!-- 注意：v-else 指令必须配合 v-if 指令一起使用，否则它将不会被识别。 -->
    <!-- v-else-if -->
    <!-- v-else-if 指令，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： -->
    <!-- 注意：v-else-if 指令必须配合 v-if 指令一起使用，否则它将不会被识别。 -->
    <!-- <div id="app">
        // v-if或者v-if与v-else指令：可以单独使用，或配合v-else指令一起使用。
        <div v-if="Math.random() > 0.5">随机数大于0.5哟</div>
        <div v-else>随机数小于或者等于0.5哟</div>
        // v-else-if指令，顾名思义充当v-if的else-if块，可以连续使用。
        <div v-if="type === 'A'">优秀</div>
        <div v-else-if="type === 'B'">良好</div>
        <div v-else-if="type === 'C'">及格</div>
        <div v-else>不及格</div>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                type: "A"
            },
        });
    </script> -->

    <!-- 1.6 列表渲染指令 -->
    <!-- vue 提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使用 item in items 形式的特殊语法，其中： -->
    <!-- 1).list  属性是待循环的数组。 -->
    <!-- 2).item  属性是被循环的每一项。 -->
    <!-- <div id="app">
        // v-for指令：列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。
        <ul style="list-style: none;">
            <li v-for="item in list">编号：{{ item.id }}，名称：{{ item.name }}</li>
        </ul>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                list: [
                    {id: 10086, name: '中国移动' },
                    {id: 10000, name: '中国联通' },
                    {id: 10010, name: '中国电信' },
                    {id: 12306, name: '中国铁路' },
                ]
            },
        });
    </script> -->

    <!-- v-for 中的索引 -->
    <!-- v-for 指令还支持一个可选的第二个参数，即当前项的索引。语法格式为 (item, index) in items，示例代码如下： -->
    <!-- 注意：v-for 指令中的 item 项和 index 索引都是形参，可以根据需要进行重命名。 -->
    <!-- 例如：(user, i) in userlist -->
    <!-- <div id="app">
        // v-for指令：列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。
        <ul style="list-style: none;">
            <li v-for="item in list">编号：{{ item.id }}，名称：{{ item.name }}</li>
        </ul>
        // v-for指令：指令还支持一个可选的第二个参数，即当前项的索引。语法格式为 (item, index) in items。
        <table style="border: thin solid black;">
            <thead>
                <th>索引</th>
                <th>编号</th>
                <th>名称</th>
            </thead>
            <tbody>
                // 官方建议：只要用到 v-for 指令，那么一定要绑定一个 :key 属性，而且尽量把 id 作为 key 的值。
                // 官方对 key 的值的类型，是有要求的，字符串类型，数字类型。
                // 而且 key 的值是不可以重复的哈，否则会报错：Duplicate keys detected: 'xxx'. This may cause an update error.
                <tr v-for="(item, index) in list" v-bind:key="item.id">
                    <td>{{ index }}</td>
                    <td>{{ item.id }}</td>
                    <td>{{ item.name }}</td>
                </tr>
            </tbody>
        </table>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                list: [
                    {id: 10086, name: '中国移动' },
                    {id: 10010, name: '中国联通' },
                    {id: 10000, name: '中国电信' },
                    {id: 12306, name: '中国铁路' },
                ]
            },
        });
    </script> -->
    <!-- 使用 key 维护列表的状态 -->
    <!-- 当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能。 -->
    <!-- 但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。 -->
    <!-- 为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲染的性能。 -->
    <!-- 此时，需要为每项提供一个唯一的 key 属性： -->
    <!-- 【key】注意事项： -->
    <!-- 1).key 的值只能是字符串或数字类型。 -->
    <!-- 2).key 的值必须具有唯一性（即：key 的值不能重复）。 -->
    <!-- 3).建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）。 -->
    <!-- 4).使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）。 -->
    <!-- 5).建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）。 -->
    <!-- <link rel="stylesheet" href="./lib/bootstrap.css">
    <style>
        body {
            padding: 15px;
            user-select: none;
        }
    </style>
    <script src="./lib/jquery/jquery-3.7.0.js"></script>
    <div id="app">
        // 卡片区域
        <div class="card">
            <div class="card-header">
                添加品牌
            </div>
            <div class="card-body">
                // 添加品牌的表单区域（form 表单元素对象自带 submit 提交事件哈）
                <form v-on:submit.prevent="additionBrand()">
                    <div class="form-row align-items-center">
                        <div class="col-auto">
                            <div class="input-group mb-2">
                                <div class="input-group-prepend">
                                    <div class="input-group-text">品牌名称</div>
                                </div>
                                <input type="text" class="form-control" placeholder="请输入品牌名称" v-model:trim="brand">
                            </div>
                        </div>
                        <div class="col-auto">
                            <button type="submit" class="btn btn-primary mb-2">添加</button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        // 表格区域
        <table class="table table-bordered table-hover table-striped">
            <thead>
            <tr>
                <th scope="col">#</th>
                <th scope="col">品牌名称</th>
                <th scope="col">状态</th>
                <th scope="col">创建时间</th>
                <th scope="col">操作</th>
            </tr>
            </thead>
            <tbody>
            <tr v-for="item in list" v-bind:key="item.id">
                <td>{{ item.id }}</td>
                <td>{{ item.name }}</td>
                <td>
                    <div class="custom-control custom-switch">
                        // 使用 v-bind 动态指定循环索引 label 元素对象
                        // 使用 v-model 双向数据绑定
                        <input type="checkbox" class="custom-control-input" v-bind:id="'customSwitch' + item.id" v-model="item.status">
                        // 使用 v-if 结合 v-else 实现按需求
                        <label class="custom-control-label" v-bind:for="'customSwitch' + item.id" v-if="item.status">已禁用</label>
                        <label class="custom-control-label" v-bind:for="'customSwitch' + item.id" v-else>已启用</label>
                    </div>
                </td>
                <td>{{ item.time }}</td>
                <td>
                    // v-on 绑定事件
                    <a href="javascript:;" v-on:click="remove(item.id)">删除</a>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                brand: '',
                nextId: 4,
                list: [
                    {id: '1001', name: '奔驰', time: '2023-06-26 21:30:14', status: true},
                    {id: '1002', name: '宝马', time: '2023-06-26 22:33:44', status: false},
                    {id: '1004', name: '奥迪', time: '2023-06-26 23:36:54', status: false}
                ]
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                additionBrand: function () {
                    console.log(this.brand);
                    const obj = {
                        id: this.nextId,
                        name: this.brand,
                        status: false,
                        time: new Date().getTime()
                    }
                    this.list.push(obj);
                    this.brand = '';
                    this.nextId++;
                },
                remove: function (id) {
                    console.log(id);
                    console.log(this.list);
                    console.log(viewModule.list);
                    this.list = this.list.filter(item => item.id !== id);
                }
            }
        });
    </script> -->

    <!-- 2. 过滤器 -->
    <!-- 过滤器（Filters）是 vue 为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式和 v-bind 属性绑定。 -->
    <!-- 过滤器应该被添加在 JavaScript 表达式的尾部，由管道符（|）进行调用，示例代码如下： -->
    <!-- // 在双花括号中通过管道符（|）调用 Capitalize 过滤器，对 Message 的值进行格式化 -->
    <!-- <p>{{ message | capitalize }}</p> -->
    <!-- // 在 v-bind 中通过管道符（|）调用 FormatId 过滤器，对 RawId 的值进行格式化 -->
    <!-- <div v-bind:id="rawId | formatId"></div> -->
    <!-- 2.1 定义过滤器 -->
    <!-- 在创建 vue 实例期间，可以在 filters 节点中定义过滤器，示例代码如下： -->
    <!-- <div id="app">
        // Filters 过滤器
        <p>Message的值是：{{ message | capitalize() }}</p>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                message: "Hello World",
            },
            // methods的作用，就是定义事件的处理函数
            methods: {    },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {
                capitalize: function (val) {
                    const first = val.charAt(0).toUpperCase();
                    const other = val.slice(1);
                    return val + ` - 2023`;
                }
            }
        });
    </script> -->

    <!-- 2.2 私有过滤器和全局过滤器 -->
    <!-- 在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。 -->
    <!-- 如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器： -->
    <!-- Vue.filter('capitalize', function (str) {return str.charAt(0).toUpperCase()+str.slice(1)+`Okay`;}); -->
    <!-- <div id="app">
        // Filters 过滤器
        <p>Message的值是：{{ message | capitalize() }}</p>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        Vue.filter('capitalize', function (str) {
            return str.charAt(0).toUpperCase() + str.slice(1) + `Okay`;
        });
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                message: "Hello World",
            },
            // methods的作用，就是定义事件的处理函数
            methods: {            },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {
                capitalize: function (val) {
                    const first = val.charAt(0).toUpperCase();
                    const other = val.slice(1);
                    return val + ` - 2023`;
                }
            }
        });
    </script> -->
    <!-- 注意：就近原则，私有过滤器优先级高于全局过滤器。 -->

    <!-- 2.3 连续调用多个过滤器 -->
    <!-- 过滤器可以串联地进行调用，例如： -->
    <!-- 2.3 连续调用多个过滤器 -->
    <!-- 示例代码如下： -->
    <!-- // 把 Message 的值交给 FilterA 进行处理 -->
    <!-- // 把 FilterA 处理的结果，再交给 FilterB 进行处理 -->
    <!-- // 最终把 FilterB 处理的结果，作为最终的的值渲染到页面上 -->
    <!-- {{ message | filterA | filterB }} -->

    <!-- 2.4 过滤器传参 -->
    <!-- 过滤器的本质是 JavaScript 函数，因此可以接收参数，格式如下： -->
    <!-- 2.4 过滤器传参 -->
    <!-- 示例代码如下： -->
    <!-- <p>{{ message | filterA(arg1, arg2) }}</p> -->
    <!-- // arg1 参数，永远都是管道符前面待处理的值 -->
    <!-- // arg2 参数：开始才是调用过滤器时传递过来的 arg1 和 arg2 参数 -->
    <!-- Vue.filter('filterA', function (msg, arg1, arg2) {}); -->

    <!-- 2.5 过滤器的兼容性 -->
    <!-- 过滤器仅在 vue 2.x 和 1.x 中受支持，在 vue 3.x 的版本中剔除了过滤器相关的功能。 -->
    <!-- 在企业级项目开发中： -->
    <!-- 1).如果使用的是 2.x 版本的 vue，则依然可以使用过滤器相关的功能。 -->
    <!-- 2).如果项目已经升级到了 3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能。 -->
    <!-- 具体的迁移指南，请参考 vue 3.x 的官方文档给出的说明： -->
    <!-- 官方网址：https://v3.vuejs.org/guide/migration/filters.html#migration-strategy -->
    <!-- <td>{{ item.time | capitalize }}</td>
    Vue.filter('capitalize', function (parameter) {
        return this.dayjs(parameter).format(`YYYY-MM-DD HH:mm:ss`);
    }); -->
    <!-- 2.6 过滤器要注意的点 -->
    <!-- 要定义到 Filters 过滤器节点下，本质是一个函数。 -->
    <!-- 在过滤器函数中，一定要有 Return 返回值。 -->
    <!-- 在过滤器的形参中，可以获取到管道符前面待处理的那个值。 -->
    <!-- 如果全局过滤器和私有过滤器名字一致，此时按照（就近原则），调用的是私有过滤器。 -->

    <!-- 品牌列表案例 -->
    <!-- <link rel="stylesheet" href="./lib/bootstrap.css">
    <style>
        body {
            padding: 15px;
            user-select: none;
        }
    </style>
    <script src="./lib/jquery/jquery-3.7.0.js"></script>
    <script src="./lib/dayjs.min.js"></script>
    <div id="app">
        // 卡片区域
        <div class="card">
            <div class="card-header">
                添加品牌
            </div>
            <div class="card-body">
                // 添加品牌的表单区域（form 表单元素对象自带 submit 提交事件哈）
                <form v-on:submit.prevent="additionBrand()">
                    <div class="form-row align-items-center">
                        <div class="col-auto">
                            <div class="input-group mb-2">
                                <div class="input-group-prepend">
                                    <div class="input-group-text">品牌名称</div>
                                </div>
                                <input type="text" class="form-control" placeholder="请输入品牌名称" v-model:trim="brand">
                            </div>
                        </div>
                        <div class="col-auto">
                            <button type="submit" class="btn btn-primary mb-2">添加</button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
        // 表格区域
        <table class="table table-bordered table-hover table-striped">
            <thead>
            <tr>
                <th scope="col">#</th>
                <th scope="col">品牌名称</th>
                <th scope="col">状态</th>
                <th scope="col">创建时间</th>
                <th scope="col">操作</th>
            </tr>
            </thead>
            <tbody>
            <tr v-for="item in list" v-bind:key="item.id">
                <td>{{ item.id }}</td>
                <td>{{ item.name }}</td>
                <td>
                    <div class="custom-control custom-switch">
                        // 使用 v-bind 动态指定循环索引 label 元素对象
                        // 使用 v-model 双向数据绑定
                        <input type="checkbox" class="custom-control-input" v-bind:id="'customSwitch' + item.id" v-model="item.status">
                        // 使用 v-if 结合 v-else 实现按需求
                        <label class="custom-control-label" v-bind:for="'customSwitch' + item.id" v-if="item.status">已禁用</label>
                        <label class="custom-control-label" v-bind:for="'customSwitch' + item.id" v-else>已启用</label>
                    </div>
                </td>
                <td>{{ item.time | capitalize }}</td>
                <td>
                    // v-on 绑定事件
                    <a href="javascript:;" v-on:click="remove(item.id)">删除</a>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <script src="./lib/vue-2.6.12.js"></script>
    <script>
        Vue.filter('capitalize', function (parameter) {
            return this.dayjs(parameter).format(`YYYY-MM-DD HH:mm:ss`);
        });
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                brand: '',
                nextId: 4,
                list: [
                    {id: '1001', name: '奔驰', time: new Date(), status: true},
                    {id: '1002', name: '宝马', time: new Date(), status: false},
                    {id: '1004', name: '奥迪', time: new Date(), status: false}
                ]
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                additionBrand: function () {
                    console.log(this.brand);
                    const obj = {
                        id: this.nextId,
                        name: this.brand,
                        status: false,
                        time: new Date().getTime()
                    }
                    this.list.push(obj);
                    this.brand = '';
                    this.nextId++;
                },
                remove: function (id) {
                    console.log(id);
                    console.log(this.list);
                    console.log(viewModule.list);
                    this.list = this.list.filter(item => item.id !== id);
                }
            }
        });
    </script> -->

    <!-- 侦听器 -->
    <!-- 1. 什么是 watch 侦听器 -->
    <!-- watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。 -->
    <!-- 语法格式如下： -->
    <!-- <div id="app">
        // Watch 侦听器
        <input type="text" v-model="watchListener"><br>
    </div>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                watchListener: '',
            },
            // methods的作用，就是定义事件的处理函数
            methods: {            },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {            },
            // watch的作用：所有的侦听器，都应该被定义到Watch节点下
            watch: {
                // 定义函数形式的侦听器
                watchListener: function (newVal, oldVal) {
                    console.log(`Okay` + newVal + `` + oldVal);
                },
                // 定义对象格式的侦听器
            }
        });
    </script> -->

    <!-- 2. 侦听器的格式 -->
    <!-- 1.方法格式的侦听器 -->
    <!-- 缺点一：无法在刚进入页面的时候，自动触发。 -->
    <!-- 缺点二：如果侦听的是一个对象，如果对象中的属性发生了改变，不会触发侦听器。 -->
    <!-- 2.对象格式的侦听器 -->
    <!-- 优点一：可以通过 Immediate 选项，让侦听器自动触发。 -->
    <!-- 优点二：可以通过 Deep 选项，让侦听器深度侦听对象中的每个属性的变化。 -->

    <!-- 2. 使用 watch 检测用户名是否可用 -->
    <!-- 监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用： -->
    <!-- <script>
        watch: {
            // 监听 username 值的变化
            async username(newVal) {
            if (newVal === '') {
                return;
            }
            // 使用 axios 发起请求，判断用户名是否可用
            const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal);
            console.log(res);
            }
        }
    </script> -->

    <!-- 3. immediate 选项 -->
    <!-- 默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用 immediate 选项。 -->
    <!-- 示例代码如下： -->
    <!-- <script>
        watch: {
            username: {
                // handler 是固定写法，表示当 username 的值变化时，自动调用 handler 处理函数
                handler: async function (newVal) {
                    if (newVal === '') {
                        return;
                    }
                    const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal);
                    console.log(res);
                },
                // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器
                immediate: true,
            }
        }
    </script> -->

    <!-- 4. deep 选项 -->
    <!-- 如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 选项，代码示例如下： -->
    <!-- <script>
        // 定义对象格式的侦听器
        informationObject: {
            handle: function (newVal, oldVal) {
                console.log(newVal, oldVal);
            },
            // immediate 选项的默认值是 False
            // immediate 的作用是：控制侦听器是否自动触发一次
            immediate: false,
            // deep 选项开启深度侦听，只要对象中任何一个属性变化了，都会触发对象侦听器
            deep: true,
        }
    </script> -->
    <!-- 5. 监听对象单个属性的变化 -->
    <!-- 如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器： -->
    <!-- <div id="app">
        // Watch 侦听器
        <input type="text" v-model="watchListener"><br>
        <input type="text" v-model="informationObject.nickname"><br>
    </div>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                watchListener: '',
                informationObject: {
                    nickname: 'LiuDaWei',
                    age: 38,
                }
            },
            // methods的作用，就是定义事件的处理函数
            methods: {            },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {            },
            // watch的作用：所有的侦听器，都应该被定义到Watch节点下
            watch: {
                // 定义函数形式的侦听器
                watchListener: function (newVal, oldVal) {
                    console.log(`Okay` + newVal + `` + oldVal);
                },
                // 定义对象格式的侦听器
                informationObject: {
                    handle: function (newVal, oldVal) {
                        console.log(newVal, oldVal);
                    },
                    // immediate 选项的默认值是 False
                    // immediate 的作用是：控制侦听器是否自动触发一次
                    immediate: false,
                    // deep 选项开启深度侦听，只要对象中任何一个属性变化了，都会触发对象侦听器
                    deep: true,
                }
            }
        });
    </script> -->

    <!-- 计算属性 -->
    <!-- 1. 什么是计算属性 -->
    <!-- 计算属性指的是通过一系列运算之后，最终得到一个属性值。 -->
    <!-- 这个动态计算出来的属性值可以被模板结构或 methods 方法使用。示例代码如下： -->
    <!-- 2. 计算属性的特点 -->
    <!-- 1).虽然计算属性在声明的时候被定义为方法，但是计算属性的本质是一个属性。 -->
    <!-- 2).计算属性会缓存计算的结果，只有计算属性依赖的数据变化时，才会重新进行运算。 -->
    <!-- <div id="app">
        // computed计算属性
        <div>
            <span>R: </span>
            <input type="text" v-model:number="r">
        </div>
        <div>
            <span>G: </span>
            <input type="text" v-model:number="g">
        </div>
        <div>
            <span>B: </span>
            <input type="text" v-model:number="b">
        </div>
        // computed计算属性，批的是通过一系列运算之后，最终得到的一个属性值
        // 在属性身上，代表 v-bind 属性绑定
        // v-bind:style 代表动态绑定一个样式对象，它的值是一个 {{}} 插值表达式样式对象
        <div class="box" v-bind:style="{ backgroundColor: rgb }">
            {{ rgb }}
        </div>
        <button v-on:click="showColor()">计算属性显示颜色</button>
    </div>
    <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {
                r: 0,
                g: 0,
                b: 0,
            },
            // 计算属性，批的是通过一系列运算之后，最终得到的一个属性值
            computed: {
                rgb: function () {
                    return `rgb(${this.r}, ${this.g}, ${this.b})`;
                }
            },
            // methods的作用，就是定义事件的处理函数
            methods: {
                showColor: function () {
                    console.log(this.rgb);
                }
            },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {            },
            // watch的作用：所有的侦听器，都应该被定义到Watch节点下
            watch: {
                // 定义函数形式的侦听器
                // 定义对象格式的侦听器
            }
        });
    </script> -->

    <!-- Axios 网络请求库 -->
    <!-- Axios 是一个专注于网络请求的库。 -->
    <!-- Axios 的基本语法如下： -->
    <!-- <script>
        axios({
            method: "请求的类型",
            url: "请求的URL地址",
        }).then(function (result) {
            // .then方法用来指定请求成功后的回调函数（result参数是请求成功之后的结果）
            console.log(result);
        });
    </script> -->
    <!-- Axios 发起 GET 请求，不带参数： -->
    <!-- <script>
        // 调用 Axios 方法得到的返回值是 Promise 对象。
        console.log(axios);
        const promiseObject = axios({
            // 请求方式
            method: "GET",
            // 请求URL地址
            url: 'http://www.liulongbin.top:3006/api/getbooks'
        });
        // 返回 Promise 对象
        console.log(promiseObject);
        promiseObject.then(function (data) {
            console.log(data);
        });
    </script> -->
    <!-- Axios 发起 GET 请求，带参数： -->
    <!-- <script>
        // 调用 Axios 方法得到的返回值是 Promise 对象。
        console.log(axios);
        const promiseObject = axios({
            // 请求方式
            method: "GET",
            // 请求URL地址
            url: 'http://www.liulongbin.top:3006/api/getbooks',
            // URL中的查询参数（GET请求可选）
            params: {
                id: 10086,
            },
        });
        // 返回 Promise 对象
        console.log(promiseObject);
        promiseObject.then(function (data) {
            console.log(data);
        });
    </script> -->
    <!-- Axios 发起 POST 请求，必带参数： -->
    <!-- <script>
        // 调用 Axios 方法得到的返回值是 Promise 对象。
        console.log(axios);
        const promiseObject = axios({
            // 请求方式
            method: "POST",
            // 请求URL地址
            url: 'http://www.liulongbin.top:3006/api/getbooks',
            // 请求体参数（POST请求可选）
            data: {
                username: "admin",
                password: "12345678",
            }
        });
        // 返回 Promise 对象
        console.log(promiseObject);
        promiseObject.then(function (data) {
            console.log(data);
        });
    </script> -->
    <!-- async 关键字 + await 关键字组合使用： -->
    <!-- <script>
        // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await 关键字。
        document.querySelector("#app").addEventListener('click', async function () {
            // await 关键字只能用在被 async 关键字修饰的函数中。
            await axios({
                // 请求方式
                method: "POST",
                // 请求URL地址
                url: 'http://www.liulongbin.top:3006/api/getbooks',
                // 请求体参数（POST请求可选）
                data: {
                    username: "admin",
                    password: "12345678",
                }
            });
        });
    </script> -->
    <!-- 解构 result 大对象结构： -->
    <!-- <script>
        // 调用 Axios 方法得到的返回值是 Promise 对象。
        console.log(axios);
        const promiseObject = axios({
            // 请求方式
            method: "GET",
            // 请求URL地址
            url: 'http://www.liulongbin.top:3006/api/getbooks',
            // URL中的查询参数（GET请求可选）
            params: {
                id: 10086,
            },
            // 请求体参数（POST请求可选）
            data: {
                username: "admin",
                password: "12345678",
            }
        });
        // 返回 Promise 对象
        console.log(promiseObject);
        promiseObject.then(function (result) {
            console.log(result);
            // 解构返回对象，进行赋值。
            const { status } = result.status;
            console.log(status);
            const { message } = result.message;
            console.log(message);
            const { data } = result.data;
            console.log(data);
        });
        // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await 关键字。
        document.querySelector("#app").addEventListener('click', async function () {
            // await 关键字只能用在被 async 关键字修饰的函数中。
            // 解构 result 返回大对象中 data 数据。假如只需要 data 的值。
            const {data : result } = await axios({
                // 请求方式
                method: "POST",
                // 请求URL地址
                url: 'http://www.liulongbin.top:3006/api/getbooks',
                // 请求体参数（POST请求可选）
                data: {
                    username: "admin",
                    password: "12345678",
                }
            });
        });
    </script> -->

    <!-- vue-cli 脚手架工具 -->
    <!-- 1. 什么是单页面应用程序 -->
    <!-- 单页面应用程序（英文名：Single Page Application）简称 SPA，顾名思义，指的是一个 Web 网站中只有唯一的一个 HTML 页面， -->
    <!-- 所有的功能与交互都在这唯一的一个页面内完成。 -->
    <!-- 例如资料中的这个 Demo 项目： -->

    <!-- 2. 什么是 vue-cli -->
    <!-- vue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程。 -->
    <!-- 引用自 vue-cli 官网上的一句话： -->
    <!-- 程序员可以专注在撰写应用上，而不必花好几天去纠结 webpack 配置的问题。 -->
    <!-- 中文官网：https://cli.vuejs.org/zh/ -->
    <!-- 2.1 vue-cli2 和 vue cli3 区别 -->
    <!-- # 查看版本 -->
    <!-- C:\Users\Administrator>node -v -->
    <!-- v16.20.0 -->
    <!-- C:\Users\Administrator>npm -v -->
    <!-- 8.19.4 -->
    <!-- # 升级或安装 cnpm -->
    <!-- C:\Users\Administrator>npm install cnpm -g -->
    <!-- # 升级 npm -->
    <!-- C:\Users\Administrator>cnpm install npm -g -->
    <!-- C:\Users\Administrator>cnpm -v -->
    <!-- cnpm@9.2.0 (D:\Program Files\nodejs\node_global\node_modules\cnpm\lib\parse_argv.js) -->
    <!-- npm@9.7.2 (D:\Program Files\nodejs\node_global\node_modules\cnpm\node_modules\npm\index.js) -->
    <!-- node@16.20.0 (D:\Program Files\nodejs\node.exe) -->
    <!-- npminstall@7.9.0 (D:\Program Files\nodejs\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js) -->
    <!-- prefix=D:\Program Files\nodejs\node_global -->
    <!-- win32 x64 10.0.19045 -->
    <!-- registry=https://registry.npmmirror.com -->
    <!-- # 最新稳定版 -->
    <!-- $ cnpm install vue -->
    <!-- 区别：vue cli2 的安装过程： -->
    <!-- C:\Users\Administrator>npm install --global vue-cli -->
    <!-- C:\Users\Administrator>vue init webpack vue2-cli2-demo2 -->
    <!-- 区别：vue cli3 的安装过程： -->
    <!-- C:\Users\Administrator>npm install --global @vue/cli -->
    <!-- C:\Users\Administrator>vue create vue2-cli3-demo3 -->
    <!-- 各种菜单... -->

    <!-- 3. node 与 npm 与 vue 和 vue-cli 安装操作 -->
    <!-- 
    # 安装：
    # 查看node版本
    C:\Users\Administrator>node -v
    v16.20.1
    # 查看npm版本
    C:\Users\Administrator>npm -v
    9.7.2
    # 查看cnpm版本
    C:\Users\Administrator>cnpm -v
    cnpm@9.2.0 (C:\Users\Administrator\AppData\Roaming\npm\node_modules\cnpm\lib\parse_argv.js)
    npm@9.7.2 (C:\Users\Administrator\AppData\Roaming\npm\node_modules\cnpm\node_modules\npm\index.js)
    node@16.20.1 (C:\Program Files\nodejs\node.exe)
    npminstall@7.9.0 (C:\Users\Administrator\AppData\Roaming\npm\node_modules\cnpm\node_modules\npminstall\lib\index.js)
    prefix=C:\Program Files\nodejs
    registry=https://registry.npmmirror.com
    # 升级cnpm版本
    C:\Users\Administrator>npm install cnpm -g
    # 升级npm版本（不建议：指定版本）
    C:\Users\Administrator>cnpm install npm@9.7.2 -g
    # 查看npm详情
    C:\Users\Administrator>npm config list
    # 查看nvm版本
    C:\Users\Administrator>nvm -v
    # 查看node当前使用版本
    C:\Users\Administrator>nvm list
    # 查看node可以安装版本
    C:\Users\Administrator>nvm list available
    # 安装vue版本
    C:\Users\Administrator>cnpm install vue
    # 安装vue-cli脚手架2版本（基于webpack3打造）
    C:\Users\Administrator>cnpm install --global vue-cli
    C:\Users\Administrator>vue init webpack vue2-cli2-demo2
    # 安装vue-cli脚手架3版本（基于webpack4打造）
    C:\Users\Administrator>cnpm install --global @vue/cli
    C:\Users\Administrator>vue create vue2-cli3-demo4
    # 查看vue-cli脚手架版本
    C:\Users\Administrator>vue -V
    @vue/cli 5.0.8
    # 区别：
    1、vue-cli2是基于webpack3打造的。
    2、vue-cli3是基于webpack4打造的。
    2、vue-cli3的仓库github由原有独立的仓库github迁移到了vue项目下。
    2、vue-cli3的项目架构完全抛弃了vue-cli2的原有架构，vue-cli3的设计更加抽象和简洁。
    2、vue-cli3提供了vue ui命令，提供了可视化配置，更加人性化。
    2、vue-cli3也学习了rollup的零配置思路，所以项目初始化后，没有了以前熟悉的build目录，也就没有了webpack.base.config.js、webpack.dev.config.js、webpack.prod.config.js等配置文件。
    2、vue-cli3的设计原则是0配置，移除的配置文件根目录下的build和config等目录。
    2、vue-cli3移除了static文件夹，新增public文件夹，并且将index.html文件移动到了public文件夹中。
    # 安装：
    Vue CLI v5.0.8
    ? Please pick a preset: Manually select features
    ? Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection, and <enter> to proceed)
    >(1) Babel
    >( ) TypeScript
    >( ) Progressive Web App (PWA) Support
    >(4) Router
    >(5) Vuex
    >(6) CSS Pre-processors
    >(7) Linter / Formatter
    >( ) Unit Testing
    >( ) E2E Testing
    # 选择：
    ? Please pick a preset: Manually select features
    ? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter
    ? Choose a version of Vue.js that you want to start the project with 2.x
    ? Use class-style componet syntax? ( )
    ? Use Babel alongside TypeScript? ( )
    ? Use history mode for router? (Requires proper server setup for index fallback in production) (Yes)
    ? Pick a CSS pre-processors: (Less)
        Sass/SCSS (with dart-sass)
        Less
        Stylus
    ? Pick a linter / formatter config: (Basic)
        ESLint with error prevention only
        ESLint + Airbnb config
        ESLint + Standard config
        ESLint + Prettier
    ? Pick additional lint features: (Lint on save)
        Lint on save
        Lint and fix on commit
    ? Where do you prefer placing config for Babel, ESLint, etc.? (In dedicated config files)
        In dedicated config files
        In package.json
    ? Save this as a preset for future project? (Yes)
    ? Save preset as: (Enter)
    --
    $ cd app
    $ npm run serve
    # 目录结构：
    # dist/
    # node_modules/
    # public/
    # src/
    # ....assets/
    # ....components/
    # ....router/
    # ....store/
    # ....views/
    # ....App.vue
    # ....main.js
    # ....babel.config.js
    # ....jsconfig.json
    # ....package-lock.json
    # ....package.json
    # ....README.md
    # ....vue.config.js
    # 模板结构：
    -->

    <!-- 3. 安装和使用 -->
    <!-- vue-cli 是 npm 上的一个全局包，使用 npm install 命令，即可方便的把它安装到自己的电脑上： -->
    <!-- # npm install -g @vue/cli -->
    <!-- 基于 vue-cli 快速生成工程化的 Vue 项目： -->
    <!-- vue create 项目的名称： -->
    <!-- 第一步：找到需要创建项目的目录执行如下命令。 -->
    <!-- # npm install -g @vue/cli -->
    <!-- 第二步：进入命令窗口CMD，记住PowerShell脚本命令窗口不可用。 -->
    <!-- 在此目录的路径输入框中，输入：cmd，即可进入命令窗口。 -->
    <!-- 第三步：在此目录下创建项目。 -->
    <!-- # vue create vue2-demo1 -->
    <!-- 第四步：选择需要创建的项目版本。 -->
    <!-- Vue CLI v5.0.8 -->
    <!-- ? Please pick a preset: (Use arrow keys) -->
    <!-- > Default ([Vue 3] babel, eslint) -->
    <!--   Default ([Vue 2] babel, eslint) -->
    <!--   Manually select features -->
    <!-- 第五步：如果选择（Manually select features）手动选择功能。 -->
    <!-- Vue CLI v5.0.8 -->
    <!-- ? Please pick a preset: Manually select features -->
    <!-- ? Check the feature needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection, and <enter> to proceed) -->
    <!-- >(*) Babel -->
    <!--  ( ) TypeScript -->
    <!--  ( ) Progressive Web App (PWA) Support -->
    <!--  (*) Router -->
    <!--  (*) Vuex -->
    <!--  (*) CSS Pre-processors -->
    <!--  (*) Linter / Formatter -->
    <!--  ( ) Unit Testing -->
    <!--  ( ) E2E Testing -->
    <!-- 第六步：按空格键（Space）选择需要的选项，按回车键（Enter）进入下一页。 -->
    <!-- Vue CLI v5.0.8 -->
    <!-- ? Please pick a preset: Manually select features -->
    <!-- ? Check the features needed for your project: Babel, TS, PWA, Router, Vuex, CSS Pre-processors, Linter, Unit, E2E -->
    <!-- ? Choose a version of Vue.js that you want to start the project with (Use arrow keys) -->
    <!-- > 3.x -->
    <!--   2.x -->
    <!-- 第七步：选择版本按回车（Enter）进入下一页。 -->
    <!-- Vue CLI v5.0.8 -->
    <!-- ? Please pick a preset: Manually select features -->
    <!-- ? Check the features needed for your project: Babel, TS, PWA, Router, Vuex, CSS Pre-processors, Linter, Unit, E2E -->
    <!-- ? Choose a version of Vue.js that you want to start the project with 2.x -->
    <!-- ? Use class-style component syntax? (Y/n) -->
    <!-- 第八步：输入Y进入下一页。 -->
    <!-- Y -->
    <!-- Y -->
    <!-- Y -->
    <!-- Successfully created proejct vue2-demo2. -->
    <!-- Get started with the following commands: -->
    <!-- $ cd vue2-demo2 -->
    <!-- $ npm run serve -->
    <!-- 项目操作： -->
    <!-- Project Setup -->
    <!-- # npm install -->
    <!-- Compiles and hot-reloads for development -->
    <!-- # npm run serve -->
    <!-- Compiles and minifies for production -->
    <!-- # npm run build -->
    <!-- Lints and fixes files -->
    <!-- # npm run lint -->
    <!-- Customize configuration -->
    <!-- See Configuration Reference. -->
    <!-- 提示：安装、构建、启动。 -->

    <!-- 4. vue 项目的运行流程 -->
    <!-- 重点：在工程化的项目中【vue】要做的事情很单纯：通过【main.js】脚本把【App.vue】模块结构渲染到【index.html】页面的指定区域中。 -->
    <!-- 其中： -->
    <!-- 1).App.vue 用来编写待渲染的模板结构。 -->
    <!-- 2).index.html 中需要预留一个 el 区域。 -->
    <!-- 3).main.js 把 App.vue 渲染到了 index.html 所预留的区域中。 -->
    <!-- 【重点】入口文件：main.js -->
    <!-- <script>
        // 导入第三方vue模块包，得到Vue这个构造函数
        import Vue from 'vue';
        // 导入自定义app模块文件，将来要把App.vue中的模块结构，渲染到HTML页面中
        import App from './App.vue';
        import './registerServiceWorker';
        import router from './router';
        import store from './store';
        Vue.config.productionTip = false;
        // 创建Vue的实例对象
        new Vue({
            // 把Render函数指定的组件，渲染到HTML页面中
            router,
            store,
            render: h => h(App)
        }).$mount('#app');
    </script> -->
    <!-- 【重点】模块结构：App.vue -->
    <!-- 
    <template>
        <div id="app">
          <nav>
            <router-link to="/">Home</router-link> |
            <router-link to="/about">About</router-link>
          </nav>
          <router-view/>
        </div>
    </template> -->
    <!-- 【重点】页面文件：index.html -->
    <!-- 
    <!DOCTYPE html>
    <html lang="">
      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="icon" href="<%= BASE_URL %>favicon.ico">
        <title><%= htmlWebpackPlugin.options.title %></title>
      </head>
      <body>
        <noscript>
          <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
        </noscript>
        <div id="app"></div>
        // built files will be auto injected
      </body>
    </html> -->

    <!-- 5. vue 项目目录结构 -->
    <!-- Assets 文件夹：存放项目中用到的静态资源文件，例如：CSS样式表、图片资源等等。 -->
    <!-- Components 文件夹：自定义封装的可复用的组件，都要放到此目录下。 -->
    <!-- main.js 文件，是项目的入口文件，整个项目的运行，要先执行 main.js文件。 -->
    <!-- App.vue 文件，是项目的根组件。 -->

    <!-- vue 组件 -->
    <!-- 1. 什么是组件化开发 -->
    <!-- 组件化开发指的是：根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护。 -->

    <!-- 2. vue 中的组件化开发 -->
    <!-- vue 是一个支持组件化开发的前端框架。 -->
    <!-- vue 中规定：组件的后缀名是（.vue）。之前接触到的（App.vue）文件本质上就是一个vue的组件。 -->

    <!-- 3. vue 组件的三个组成部分 -->
    <!-- 每个.vue组件都由3部分构成，分别是： -->
    <!-- 1).template -> 组件的 HTML 模板结构。 -->
    <!-- 2).script   -> 组件的 JavaScript 行为。 -->
    <!-- 3).style    -> 组件的 CSS 样式。 -->
    <!-- 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。 -->

    <!-- 3.1 template 模块结构 -->
    <!-- vue 规定：每个组件对应的模板结构，需要定义到 template 节点中。 -->
    <!-- 注意： -->
    <!-- 1).template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素。 -->
    <!-- 2).template 中只能包含唯一的根节点。 -->

    <!-- 3.2 script 行为 -->
    <!-- vue 规定：开发者可以在 script 节点中封装组件的 JavaScript 业务逻辑。 -->
    <!-- 1).script 节点的基本结构如下： -->

    <!-- .vue 组件中的 data 必须是函数 -->
    <!-- vue 规定：.vue 组件中的 data 必须是一个函数，不能直接指向一个数据对象。 -->
    <!-- 因此在组件中定义 data 数据节点时，下面的方式是错误的： -->
    <!-- 会导致多个组件实例共用同一份数据的问题，请参考官方给出的示例： -->
    <!-- https://cn.vuejs.org/v2/guide/components.html# -->
    <!-- 注意：data 必须是一个函数。 -->
    <!-- <script>
        // 默认导出。这是固定写法哈。
        export default {
          //当前组件的数据源
          data() {
            // return返回出去定义数据
            return {
              username: 'LiuWeiWei'
            };
          },
          //当前组件中的事件函数
          methods: {
            changeName() {
              // 在组件中，这个 this 就表示当前组件的实例对象
              this.username = 'LiuDaWei'
            }
          },
          //当前组件中的侦听器
          watch: {    },
          //当前组件中的计算属性
          computed: {    },
          //当前组件中的过滤器
          filters: {    }
        }
    </script> -->

    <!-- 3.3 style 样式 -->
    <!-- vue 规定：组件内的 style 节点是可选的，开发者可以在 style 节点中编写样式美化当前组件的 UI 结构。 -->
    <!-- script 节点的基本结构如下： -->
    <!-- <script>
        const viewModule = new Vue({
            // el属性是固定的写法，表示当前ViewModel实例要控制页面上的哪个区域，接收的值是一个选择器
            el: "#app",
            // data对象就是要渲染到页面上的数据
            data: {            },
            // 计算属性，批的是通过一系列运算之后，最终得到的一个属性值
            computed: {            },
            // methods的作用，就是定义事件的处理函数
            methods: {            },
            // filters的作用，就是过滤器函数，处理管道符（|）前面的那个值
            filters: {            },
            // watch的作用：所有的侦听器，都应该被定义到Watch节点下
            watch: {            }
        });
    </script> -->

    <!-- 3.3.1 style 格式中支持 less 语法 -->
    <!-- 在 style 标签上添加 lang="less" 属性，即可使用 less 语法编写组件的样式： -->
    <!-- 报错：Module not found: Error: Can't resolve 'less-loader' in 'D:\workspace-vue\vue2-demo2' -->
    <!-- 解决： -->
    <!-- # npm install --save-dev less-loader less -->
    <!-- 这是 CSS 样式 -->
    <!-- <style lang="scss"> -->
    <!-- 这是 LESS 样式 -->
    <!-- <style lang="less">
        .app {
          background-color: pink;
          h3 {
            color: red;
          }
        }
    </style> -->

    <!-- 4. 组件之间的父子关系 -->
    <!-- 组件在被封装好之后，彼此之间是相互独立的，不存在父子关系 在使用组件的时候，根据彼此的嵌套关系，形成了父子关系、兄弟关系。 -->

    <!-- 4.1 使用组件的三个步骤 -->
    <!-- App.vue 组件 -->
    <!-- 第一步：使用【import】语法（关键字）导入需要的组件。 -->
    <!-- 第二步：使用【components】节点（关键字）注册组件。 -->
    <!-- 第三步：以标签形式使用刚才注册的组件。 -->
    <!-- 第一层组件：App.vue -->
    <!-- <template>
        <div id="app-container">
          <h1>App.vue 根组件</h1>
          <hr>
          <div class="box">
            // 渲染 Left.vue 左侧子组件和 Right.vue 右侧子组件
            // 以标签形式，使用注册好的组件
            <HelloWorld></HelloWorld>
          </div>
        </div>
    </template>
    <script>
        // 导入需要使用的模块结构文件（Left.vue）
        // import HelloWorld from '../src/components/HelloWorld.vue';
        // 参考 webpack 工具 @ 艾特符号起源
        import HelloWorld from '@/components/HelloWorld.vue';
        // 默认导出（这是固定写法）
        export default {
          //注册组件
          components: {
            HelloWorld,
          },
          //当前组件的数据源
          data() {},
          //当前组件中的事件函数
          methods: {}
        }
    </script>
    // <style lang="scss">
    <style lang="less">
    </style> -->
    <!-- 第二层组件：HelloWorld.vue -->
    <!-- <template>
        <div class="hello">
          <h1>{{ msg }}</h1>
        </div>
    </template>
    <script lang="ts">  
    </script>
    // Add "scoped" attribute to limit CSS to this component only
    <style scoped lang="scss">
    </style> -->
    <!-- 拓展：@ 艾特符号的起源（webpack 工具） -->
    <!-- 1).配置艾特（@）符号代替指定目录。 -->
    <!-- 2).配置文件（webpack.config.js）。 -->
    <!-- 
    <script>
        // 0. 导入第三方模块
        const pathModule = require('path');
        // 1. 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象。
        module.exports = {
            resolve: {
                alias: {
                    // 告诉webpack指定代码中@艾特符号表示./src/这一层目录
                    '@': pathModule.join(__dirname, './src/')
                }
            }
        }
    </script> -->
    <!-- 其他文件引入可优化？ -->
    <!-- <script>
        // 使用 ES6 导入语法，导入自定义模块。
        import '@/css/index.css';
        // 使用 ES6 导入语法，导入自定义模块。
        import '@/css/index.less';
        // 使用 ES6 导入语法，导入自定义模块。
        import logo from '@/images/logo.png';
    </script> -->

    <!-- 4.2 通过【components】注册的是私有子组件 -->
    <!-- 例如： -->
    <!-- 在组件 A 的 components 节点下，注册了组件 F。则组件 F 只能用在组件 A 中；不能被用在组件 C 中。 -->
    <!-- 请大家思考两个问题： -->
    <!-- 1).为什么 F 组件不能用在组件 C 组件中。 -->
    <!-- 2).怎样才能在组件 C 组件中使用 F 组件。 -->
    <!-- 第一组件：App.vue -->
    <!-- 
    <template>
        <div id="app-container">
          <h1>App.vue 根组件</h1>
          <hr>
          <div class="box">
            // 渲染 Left.vue 左侧子组件和 Right.vue 右侧子组件
            // 以标签形式，使用注册好的组件
            <HelloWorld></HelloWorld>
            // 以标签形式，使用注册好的组件
            <Count></Count>
          </div>
        </div>
      </template>
      <script>
        // 导入需要使用的模块结构文件（Left.vue）
        // import HelloWorld from '../src/components/HelloWorld.vue';
        // 参考 webpack 工具 @ 艾特符号起源
        import HelloWorld from '@/components/HelloWorld.vue';
        import Count from '@/components/CountX.vue';
        // 默认导出（这是固定写法）
        export default {
          //注册组件
          components: {
            HelloWorld,
            Count,
          },
          //当前组件的数据源
          data() {},
          //当前组件中的事件函数
          methods: {},
          //当前组件中的侦听器
          watch: {},
          //当前组件中的计算属性
          computed: {},
          //当前组件中的过滤器
          filters: {}
        }
    </script>
    // <style lang="scss"></style>
    <style lang="less">
    </style> -->
    <!-- 第二组件：Count.vue -->
    <!-- <template>
        <div>
          <h5>Count 组件</h5>
          <p>Count 的值是：{{ count }}</p>
          <button v-on:click="addition()">添加按钮</button>
        </div>
    </template>
    <script>
        export default {
          data() {
            return {
              count: 0,
            }
          },
          methods: {
            addition() {
              this.count++;
            }
          }
        }
    </script>
    <style lang="less">
    </style> -->

    <!-- 4.3 注册全局组件 -->
    <!-- 在 vue 项目的 main.js 入口文件中，通过 Vue.component() 方法，可以注册全局组件。示例代码如下： -->
    <!-- 第一入口：main.js -->
    <!-- 
    <script>
        // 导入第三方vue模块包，得到Vue这个构造函数
        import Vue from 'vue';
        // 导入自定义app模块文件，将来要把App.vue中的模块结构，渲染到HTML页面中
        import App from './App.vue';
        import './registerServiceWorker';
        import router from './router';
        import store from './store';
        Vue.config.productionTip = false;
        import Count from '@/components/CountX.vue';
        // 导入需要被全局注册的那个组件
        // eslint-disable-next-line vue/multi-word-component-names
        Vue.component('Count', Count);
        // 创建Vue的实例对象
        new Vue({
        // 把Render函数指定的组件，渲染到HTML页面中
        router,
        store,
        render: h => h(App)
        }).$mount('#app-container');
    </script> -->
    <!-- 第一组件：App.vue -->
    <!-- <template>
        <div id="app-container">
          <h1>App.vue 根组件</h1>
          <hr>
          <div class="box">
            // 渲染 Left.vue 左侧子组件和 Right.vue 右侧子组件
            // 以标签形式，使用注册好的组件
            <HelloWorld></HelloWorld>
            // 以标签形式，使用注册好的组件
            <Count></Count>
          </div>
        </div>
    </template>
    <script>
        // 导入需要使用的模块结构文件（Left.vue）
        // import HelloWorld from '../src/components/HelloWorld.vue';
        // 参考 webpack 工具 @ 艾特符号起源
        import HelloWorld from '@/components/HelloWorld.vue';
        // 默认导出（这是固定写法）
        export default {
          //注册组件
          components: {
            HelloWorld,
          },
          //当前组件的数据源
          data() {},
          //当前组件中的事件函数
          methods: {},
          //当前组件中的侦听器
          watch: {},
          //当前组件中的计算属性
          computed: {},
          //当前组件中的过滤器
          filters: {}
        }
    </script>
    // <style lang="scss"></style>
    <style lang="less">
    </style> -->
    <!-- 第二组件：Count.vue -->
    <!-- <template>
        <div>
          <h5>Count 组件</h5>
          <p>Count 的值是：{{ count }}</p>
          <button v-on:click="addition()">添加按钮</button>
        </div>
    </template>
    <script>
        export default {
          data() {
            return {
              count: 0,
            }
          },
          methods: {
            addition() {
              this.count++;
            }
          }
        }
    </script>
    <style lang="less">
    </style> -->

    <!-- 5. 组件的 props 自定义属性 -->
    <!-- props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性。 -->
    <!-- 它的语法格式如下： -->
    <!-- 第二组件：BasicModule.vue -->
    <!-- <script>
        export default {
          // props的作用：是【自定义属性】，允许使用者通过自定义属性，为当前组件指定初始值。
          // 自定义属性的名字，是封装者自定义的（只要名称合法即可）。
          // props属性中的数据，可以直接在模板结构中被使用。
          // 注意：props属性是只读的，不要直接修改props属性的值，否则终端会报错。
          // 自定义属性数组形式：props: ['init'],
          // 自定义属性对象形式：props: {init:{}},
          props: {
            init: {
              // 如果外界使用Count组件的时候，没有传递init属性，则默认值生效
              default: 0,
              // init的值类型必须是Number数字
              type: Number,
              // 必填项校验
              required: true
            }
          },
          data() {
            // 把【自定义属性】赋值给【data】属性更好些
            // 把 props 中的 init 值，转存到 count 上
            return {
              count: this.init
            }
          },
          methods: {
            show() {
              console.log(this);
            }
          }
        }
    </script> -->

    <!-- 5.1 props 自定义属性是只读的 -->
    <!-- vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。 -->
    <!-- 否则会直接报错：要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的。 -->
    <!-- <script>
        export default {
          props: {
            init: {
              default: 0,
              type: Number,
              required: true
            }
          },
          data() {
            // 把props【自定义属性】init赋值给【data】属性count更好些
            return {
              count: this.init
            }
          }
        }
    </script> -->

    <!-- 5.2 props 自定义属性的 default 默认值 -->
    <!-- 在声明自定义属性时，可以通过 default 来定义属性的默认值。示例代码如下： -->
    <!-- <script>
        export default {
          props: {
            init: {
              // 如果外界使用Count组件的时候，没有传递init属性，则默认值生效
              default: 0,
              // init的值类型必须是Number数字
              type: Number,
              // 必填项校验
              required: true
            }
          },
          data() {
            return {
              count: this.init
            }
          }
        }
    </script> -->

    <!-- 5.3 props 自定义属性的 type 值类型 -->
    <!-- 在声明自定义属性时，可以通过 type 来定义属性的值类型。示例代码如下： -->
    <!-- <script>
        export default {
          props: {
            init: {
              // 如果外界使用Count组件的时候，没有传递init属性，则默认值生效
              default: 0,
              // init的值类型必须是Number数字
              type: Number,
              // 必填项校验
              required: true
            }
          },
          data() {
            return {
              count: this.init
            }
          }
        }
    </script> -->

    <!-- 5.4 props 自定义属性的 required 必填项 -->
    <!-- 在声明自定义属性时，可以通过 required 选项，将属性设置为必填项，强制用户必须传递属性的值。 -->
    <!-- 示例代码如下： -->
    <!-- 第一入口：main.js -->
    <!-- <script>
        // 导入第三方vue模块包，得到Vue这个构造函数
        import Vue from 'vue';
        // 导入自定义app模块文件，将来要把App.vue中的模块结构，渲染到HTML页面中
        import App from './App.vue';
        import './registerServiceWorker';
        import router from './router';
        import store from './store';
        import BasicModule from '@/components/BasicModule.vue';
        // 全局配置
        Vue.config.productionTip = false;
        // 导入需要被全局注册的那个组件
        Vue.component('BasicModule', BasicModule);
        // 创建Vue的实例对象
        // router属性：把Render函数指定的组件，渲染到HTML页面中。
        // store属性：
        // render函数：函数中渲染的是哪个（.vue）组件，那么这个组件就叫做【根组件】。
        new Vue({
        router,
        store,
        render: h => h(App)
        }).$mount('#app-container');
    </script> -->
    <!-- 第一组件：App.vue -->
    <!-- <template>
        <div class="app-container">
          <h1>App 根组件</h1>
          <hr>
          <div class="box">
            // 渲染 Left 组件和 Right 组件
            // 3. 以标签形式，使用注册好的组件
            <LeftModule></LeftModule>
            // 3. 以标签形式，使用注册好的组件
            <RightModule></RightModule>
          </div>
        </div>
    </template>
    <script>
        // 1. 导入需要使用的模块结构文件（.vue组件）
        // import LeftModule from '../src/components/LeftModule.vue';
        // 参考 webpack 工具 @ 艾特符号起源
        import LeftModule from '@/components/LeftModule.vue';
        import RightModule from "@/components/RightModule.vue";
        // 默认导出（这是固定写法）
        export default {
          // 2. 注册组件
          components: {
            LeftModule,
            RightModule,
          },
          //当前组件的数据源
          data() {
            // return返回出去定义数据
            return {
              username: 'LiuWeiWei'
            };
          },
          //当前组件中的事件函数
          methods: {
            changeName() {
              // 在组件中，这个 this 就表示当前组件的实例对象
              this.username = 'LiuDaWei'
            }
          },
          //当前组件中的侦听器
          watch: {},
          //当前组件中的计算属性
          computed: {},
          //当前组件中的过滤器
          filters: {}
        }
    </script>
    <style lang="less">
        .app-container {
          padding: 1px 20px 20px;
          background-color: #efefef;
        }
        .box {
          display: flex;
        }
    </style> -->
    <!-- 第二组件：BasicModule.vue -->
    <!-- <template>
        <div class="other">
          <h5>Count组件</h5>
          <p>Count的值是：{{ count }}</p>
          <button v-on:click="count += 1">+1</button>
          <button v-on:click="show()">打印：this</button>
        </div>
    </template>
    <script>
      export default {
        // props的作用：是【自定义属性】，允许使用者通过自定义属性，为当前组件指定初始值。
        // 自定义属性的名字，是封装者自定义的（只要名称合法即可）。
        // props属性中的数据，可以直接在模板结构中被使用。
        // 注意：props属性是只读的，不要直接修改props属性的值，否则终端会报错。
        // 自定义属性数组形式：props: ['init'],
        // 自定义属性对象形式：props: {init:{}},
        props: {
          init: {
            // 如果外界使用Count组件的时候，没有传递init属性，则默认值生效
            default: 0,
            // init的值类型必须是Number数字
            type: Number,
            // 必填项校验
            required: true
          }
        },
        data() {
          // 把【自定义属性】赋值给【data】属性更好些
          // 把 props 中的 init 值，转存到 count 上
          return {
            count: this.init
          }
        },
        methods: {
          show() {
            console.log(this);
          }
        }
      }
    </script>
    <style lang="less"></style> -->
    <!-- 第三组件：LeftModule.vue & RightModule.vue -->
    <!-- <template>
        <div class="left-container">
          <h3>LeftModule组件：</h3>
          <hr>
          <BasicModule :init="9"></BasicModule>
        </div>
    </template>
    <script>
        export default {}
    </script>
    <style lang="less" scoped>
      .left-container {
        padding: 0 20px 20px;
        background-color: orange;
        min-height: 250px;
        flex: 1;
      }
      h3 {
        color: red;
      }
      // 当使用第三方组件库的时候，如果有修改第三方组件默认样式的需求，需要用到 /deep/
      /deep/ h5 {
        color: pink;
      }
    </style> -->

    <!-- 6. 组件之间的样式冲突问题 -->
    <!-- 默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。 -->
    <!-- 导致组件之间样式冲突的根本原因是： -->
    <!-- ① 单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的。 -->
    <!-- ② 每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素。 -->
    <!-- Add "scoped" attribute to limit CSS to this component only -->
    <!-- 添加 scoped 属性以将 CSS 仅限于此组件 -->
    <!-- .right-container[data-v-6b6479a8] {} -->
    <!-- <style scoped lang="scss">
        .right-container {
        padding: 0 20px 20px;
        background-color: lightskyblue;
        min-height: 250px;
        flex: 1;
        }
    
        h3 {
        color: blue;
        }
    </style> -->

    <!-- 6.1 思考：如何解决组件样式冲突的问题 -->
    <!-- 为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域，示例代码如下： -->
    <!-- 6.2 style 节点的 scoped 属性 -->
    <!-- 为了提高开发效率和开发体验，vue 为 style 节点提供了 scoped 属性，从而防止组件之间的样式冲突问题： -->
    <!-- <style scoped lang="scss">
        .right-container {
            padding: 0 20px 20px;
            background-color: lightskyblue;
            min-height: 250px;
            flex: 1;
        }
      
        h3 {
            color: blue;
        }
    </style> -->

    <!-- 6.3 /deep/ 样式穿透 -->
    <!-- 如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。 -->
    <!-- 如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。 -->
    <!-- Add "scoped" attribute to limit CSS to this component only -->
    <!-- 添加 scoped 属性以将 CSS 仅限于此组件 -->
    <!-- .left-container[data-v-3869e5fa] {} -->
    <!-- <style lang="less" scoped>
        .left-container {
            padding: 0 20px 20px;
            background-color: orange;
            min-height: 250px;
            flex: 1;
        }
        h3 {
            color: red;
        }
        // 当使用第三方组件库的时候，如果有修改第三方组件默认样式的需求，需要用到 /deep/
        // 显示方式一：h5[data-v-3c83f0b7]
        // 显示方式二：[data-v-3c83f0b7] h5
        /deep/ h5 {
            color: pink;
        }
    </style> -->

    <!-- 四、组件的生命周章节 -->
    <!-- 1. 生命周期 & 生命周期函数 -->
    <!-- 生命周期（Life Cycle）是指一个组件从：【创建】->【运行】->【销毁】的整个阶段，强调的是一个时间段。 -->
    <!-- 生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。 -->
    <!-- 注意：生命周期强调的是时间段，生命周期函数强调的是时间点。 -->

    <!-- 3. 组件生命周期函数的分类 -->
    <!-- 第一阶段：组件创建阶段。 -->
    <!-- 第二阶段：组件运行阶段。 -->
    <!-- 第三阶段：组件销毁阶段。 -->
    <!-- // 组件生命周期的第一个阶段 -->
    <!-- 1).new Vue() -->
    <!-- 2).beforeCreate() -->
    <!-- 3).created() -->
    <!-- 4).beforeMount() -->
    <!-- 5).mounted() -->
    <!-- // 组件生命周期的第二个阶段 -->
    <!-- 6).beforeUpdate() -->
    <!-- 7).updated() -->
    <!-- // 组件生命周期的第三个阶段 -->
    <!-- 8).beforeDestroy() -->
    <!-- 9).destroyed() -->

    <!-- 4. 生命周期图示 -->
    <!-- 可以参考 vue 官方文档给出的【生命周期图示】，进一步理解组件生命周期执行的过程： -->
    <!-- 生命周期图示图片地址： -->
    <!-- https://v2.cn.vuejs.org/v2/guide/instance.html -->
    <!-- <template>
        <div class="test-container">
          <h3 id="myh3">Test.vue 组件 --- {{ books.length }} 本图书</h3>
          <p id="pppp">message 的值是：{{ message }}</p>
          <button @click="message += '~'">修改 message 的值</button>
        </div>
    </template>
    <script>
        export default {
          props: [],
          data() {},
          watch: {},
          methods: {},
          // Vue.js 生命周期每个过程函数
          // 0. new Vue() 对象，创建组件实例对象。
          // 【第一阶段】组件创建阶段的生命周期函数（beforeCreate(), created(), beforeMount(), mounted()）
          // 1. beforeCreate 函数，创建阶段的第一个生命周期函数。
          // 组件尚未被创建，都处于不可用状态。
          // 初始化事件和生命周期函数。
          beforeCreate() {
            console.log(this.info);
            console.log(this.message);
            this.show();
          },
          // 2. created 函数，生命周期函数，非常常用。
          // 经常在它里面，调用 methods 中的方法，请求服务器的数据。
          // 并且，把请求到的数据，转存到 data 中，供 template 模板渲染的时候使用。
          // 基于【数据】和【模板】，在内存中编译生成 html 结构。
          created() {
            this.initBookList();
          },
          // 3. beforeMount 函数，将要把内存中编译的好 html 结构渲染到浏览器中。
          // 此时，浏览器中还没有当前组件的 DOM 结构。
          // 用内存中编译生成的 html 结构，替换掉 el 属性指定的 DOM 元素。
          beforeMount() {
            console.log('beforeMount');
            const dom = document.querySelector('#myh3');
            console.log(dom);
          },
          // 4. mounted 函数，如果要操作当前组件的 DOM，最早，只能在 mounted 阶段执行。
          // 已经把内存中的 html 结构，成功的渲染到了浏览器之中。
          // 此时，浏览器中已经包含了当前组件的 DOM 结构。
          mounted() {
            console.log(this.$el);
            const dom = document.querySelector('#myh3');
            console.log(dom);
          },
          // 【第二阶段】组件运行阶段的生命周期函数（beforeUpdate(), updated()）
          // 5. beforeUpdate 函数，将要根据变化过后，最新的数据，重新渲染组件的模板结构。
          // 根据最新的数据，重新渲染组件的 DOM 结构。
          beforeUpdate() {
            console.log('beforeUpdate');
            console.log(this.message);
            const dom = document.querySelector('#pppp');
            console.log(dom.innerHTML);
          },
          // 6. 当数据变化之后，为了能够操作到最新的 DOM 结构，必须把代码写到 updated 生命周期函数中。
          // 已经根据最新的数据，完成了组件 DOM 结构的重新渲染。
          updated() {
            console.log('updated');
            console.log(this.message);
            const dom = document.querySelector('#pppp');
            console.log(dom.innerHTML);
          },
          // 【第三阶段】组件销毁阶段的生命周期函数（beforeDestroy(), destroyed()）
          // 7. beforeDestroy 函数，将要销毁此组件，此时尚未销毁，组件还处于正常工作的状态。
          beforeDestroy() {
            console.log('beforeDestroy');
            this.message = 'aaa';
            console.log(this.message);
          },
          // 8. destroyed 函数，销毁当前组件的数据侦听器、子组件、事件监听。
          // 组件已经被销毁，此组件在浏览器中对应的 DOM 结构已经被完成移除。
          destroyed() {
            console.log('destroyed');
            this.message = 'aaa';
          }
        }
    </script>
    <style lang="less" scoped>
        .test-container {
            background-color: pink;
            height: 200px;
        }
    </style> -->

    <!-- 组件之间的数据共享 -->
    <!-- 1. 组件之间的关系 -->
    <!-- 在项目开发中，组件之间的最常见的关系分为如下两种： -->
    <!-- 1).父子关系。 -->
    <!-- 2).兄弟关系。 -->

    <!-- 2. 父子组件之间的数据共享 -->
    <!-- 父子组件之间的数据共享又分为： -->
    <!-- 1).父【向】子共享数据。使用【自定义属性】实现。 -->
    <!-- 2).子【向】父共享数据。使用【自定义事件】实现。 -->

    <!-- 2.1 父组件向子组件共享数据 -->
    <!-- 父组件向子组件共享数据需要使用【自定义属性】props:[]。 -->
    <!-- 示例代码如下： -->
    <!-- 第一组件：App.vue -->
    <!-- <template>
        // 父级组件message和userInfo绑定给到子级组件msg和user
        <Son v-bind:msg="message" v-bind:user="userInfo"></Son>
    </template>
    <script>
        export default {
            data() {
                return {
                    message: 'Hello World',
                    userInfo: {username: 'LiuWeiWei', password: '12345678'}
                }
            }
        }
    </script> -->
    <!-- 第二组件：Son.vue -->
    <!-- <template>
        <div>
            <h3>Son 组件</h3>
            <p>父组件传递过来的 msg 值是：{{ msg }}</p>
            <p>父组件传递过来的 user 值是：{{ user }}</p>
        </div>
    </template>
    <script>
        export default {
            props: [
                'msg',
                'user'
            ]
        }
    </script> -->

    <!-- 2.2 子组件向父组件共享数据 -->
    <!-- 子组件向父组件共享数据需要使用【自定义事件】$emit()。 -->
    <!-- 示例代码如下： -->
    <!-- 第一组件：App.vue -->
    <!-- <template>
        <Son v-on:countChange="addPlus()"></Son>
    </template>
    <script>
        export default {
            data() {
                return {
                    countFromSon: 0
                }
            },
            methods: {
                addPlus(value) {
                    this.countFromSon = value;
                }
            }
        }
    </script> -->
    <!-- 第二组件：Son.vue -->
    <!-- <template>
        <div>
            <h3>Son 组件</h3>
            <p>子组件的值是：{{ count }}</p>
            <button v-on:click="add()">点击自增</button>
        </div>
    </template>
    <script>
        export default {
            data() {
                return {
                    count: 0
                }
            },
            methods: {
                add() {
                    this.count += 1;
                    this.$emit('countChange', this.count);
                }
            }
        }
    </script> -->

    <!-- 3. 兄弟组件之间的数据共享 -->
    <!-- 在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus。 -->

    <!-- 3.1 EventBus 的使用步骤： -->
    <!-- 1).创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象。 -->
    <!-- <script>
        import Vue from 'vue';
        export default new Vue();
    </script> -->
    <!-- 2).在数据发送方，调用：bus.$emit('事件名称', 要发送的数据) 方法【触发一个自定义事件】。 -->
    <!-- 
    <script>
        import bus from '@/components/eventBus';
        export default {
            data() {
                return {
                    msg: 'Hello World'
                }
            },
            methods: {
                sendMsg() {
                    bus.$emit('share', this.msg);
                }
            }
        }
    </script>
    -->
    <!-- 3).在数据接收方，调用：bus.$on('事件名称', 事件处理函数) 方法【注册一个自定义事件】。 -->
    <!-- 
    <script>
        import bus from '@/components/eventBus';
        export default {
            data() {
                return {
                    msgFromLeftModule: ''
                }
            },
            created() {
                bus.$on('share', val => {
                    this.msgFromLeftModule = val;
                });
            }
        }
    </script>
    -->

    <!-- 总结：第 01 天 -->
    <!-- (01) 内容渲染指令： -->
    <!-- v-text 缺点：覆盖元素中的默认内容。 -->
    <!-- {{}} 插值表达式。只能用在元素的内容节点，无法使用在属性节点。 -->
    <!-- v-html 用处：把带有 html 标签的字符串，渲染为真正的 DOM 元素。 -->
    <!-- (02) 属性绑定指令： -->
    <!-- v-bind  -->
    <!-- 简写 : -->
    <!-- (03) 事件绑定指令： -->
    <!-- v-on -->
    <!-- 简写 @ -->
    <!-- @click="show" 和 @click="show(传参)" -->
    <!-- 内置的变量 @event 比如：@click="show(10, $event)" -->
    <!-- 事件修饰符 .pervent 和 .stop -->
    <!-- 按键修饰符 .esc 和 .enter -->
    <!-- (04) 双向数据绑定指令： -->
    <!-- v-model 只能使用在表单元素上 -->
    <!-- 修饰符 .number 与 .trim 和 .lazy -->
    <!-- (05) 循环渲染指令： -->
    <!-- v-for = "(item, index) in 数组" -->
    <!-- :key = "item.id" -->
    <!-- 拿索引当 key 没有意义 -->
    <!-- (06) 条件渲染指令： -->
    <!-- v-if 动态创建和移除元素 -->
    <!-- v-else-if -->
    <!-- v-else -->
    <!-- v-show 动态添加和移除 display:none 样式 -->
    <!-- (07) 过滤器： -->
    <!-- 全局过滤器 Vue.filter('名字', function (过滤器前面的值) {reutrn 返回结果}) -->
    <!-- 私有过滤器 定义到组件的 filters 节点之下 -->
    <!-- 调用 {{ message | dateFormat }} -->

    <!-- 总结：第 02 天 -->
    <!-- (08) watch -->
    <!-- 两种格式： -->
    <!-- 方法格式，简单。username(newVal, oldVal) {} -->
    <!-- 对象格式，username: {handler(newVal, oldVal) {}, deep: true, immediate: true} -->
    <!-- (09) computed -->
    <!-- 在定义的时候，要定义为 function 函数。 -->
    <!-- 在使用的时候，当作普通属性来使用即可。 -->
    <!-- 在 template 模板结构中可以使用。 -->
    <!-- 在 methods 方法中，也可以使用。this 计算属性的名字。 -->
    <!-- 需要 return 一个计算的结果。 -->
    <!-- 只要任何一个依赖的数据发生了变化，计算属性就会重新旧值。 -->
    <!-- (10) vue-cli -->
    <!-- 全局安装 npm install @vue/cli -g -->
    <!-- 创建项目 vue create 项目的名称 -->
    <!-- 组件的构成： -->
    <!-- template 只能有唯一的根节点 -->
    <!-- script -->
    <!-- 格式：export default {} -->
    <!-- .vue 中的 data 必须是（方法）函数 -->
    <!-- style -->
    <!-- 启用 less 语法：lang = "less" -->
    <!-- 防止组件之间的样式冲突：scoped -->
    <!-- 防止组件之间的样式冲突：/deep/ 深度选择器，在需要覆盖第三方组件样式的时候，会用到。 -->

    <!-- 总结：第 03 天 -->
    <!-- props -->
    <!-- 极大的提高可复用性。 -->
    <!-- 定义 props 有两种格式： -->
    <!-- 数组格式，简单。props: ['initial'] -->
    <!-- 对象格式，定义的时候稍微复杂点。props: {initial: {type: Number, default: 0, required: true}} -->
    <!-- props 是只读的，因此在项目开发中，不要直接修改它的值。 -->
    <!-- 把 props 的值，转存到 data 中，就可以进行读写操作了。 -->
    <!-- 生命周期 -->
    <!-- 概述：每个组件从创建->运行->销毁的一个过程，强调的是一个时间段。 -->
    <!-- 三个阶段： -->
    <!-- 创建阶段 -->
    <!-- BeforeCreate -->
    <!-- Created 发起Ajax请求最早的时机，请求数据。 -->
    <!-- BeforeMount -->
    <!-- Mounted 组件第一次被渲染到浏览器中，操作 DOM 最早的时机。 -->
    <!-- 运行阶段 -->
    <!-- BeforeUpdate -->
    <!-- Updated 能够操作到最新的 DOM 元素。 -->
    <!-- 销毁阶段 -->
    <!-- BeforeDestroy -->
    <!-- Destroyed -->
    <!-- 生命周期函数 -->
    <!-- 概述：在生命周期的不同阶段，会按次序，依次执行的函数，叫做生命周期函数。强调的是时间点。 -->
    <!-- 组件之间的数据共享 -->
    <!-- 父向子：自定义属性 -->
    <!-- 子组件中，通过 props 来自定义属性。 -->
    <!-- 父组件中，负责把数据，通过 v-bind: 绑定给子组件。 -->
    <!-- 子向父：自定义事件 -->
    <!-- 在子组件中调用 this.$emit() 函数来触发自定义事件。 -->
    <!-- 参数1：字符串，表示自定义事件的名称 -->
    <!-- 参数2：值，要发送给父组件的数据 -->
    <!-- 在父组件中，通过 v-on:来绑定自定义事件，并且提供一个事件处理函数。通过事件处理函数的形参，接收子组件传递过来的数据。 -->
    <!-- 兄弟组件共享数据 -->
    <!-- EventBus -->
    <!-- 数据发送方 -->
    <!-- 导入 Vue 实例对象 import bus from '@/eventBus.js'; -->
    <!-- bus.$emit('要触发的事件的名字', 要发送的数据) -->
    <!-- EventBus模块 -->
    <!-- 创建 Vue 实例对象 new Vue(); -->
    <!-- 向外导出 Vue 的实例对象 export default new Vue(); -->
    <!-- 数据接收方 -->
    <!-- 导入 Vue 实例对象 import bus from '@/eventBus.js'; -->
    <!-- bus.$on('要声明的自定义事件的名称', 事件的处理函数) -->
    <!-- 通过事件处理函数的形参，可以接收到发送过来的数据 -->
    <!-- 在数据接收方的 created() 生命周期函数中，调用 bus.$on() 函数 -->

    <!-- ref引用和$refs对象 -->
    <!-- 1. 什么是 ref 引用 -->
    <!-- ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用。 -->
    <!-- 每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。 -->
    <!-- 默认情况下，组件的 $refs 指向一个空对象。 -->
    <!-- <template>
        <div>
            <h5>Vue Ref 组件</h5>
            <button @click="getRef()">获取 $refs 引用</button>
        </div>
    </template>
    <script>
        export default {
            methods: {
                getRef: function () {
                    // this 是当前组件的实例对象，this.$refs 默认指向空对象
                    console.log(this);
                }
            }
        }
    </script> -->

    <!-- 2. 使用 ref 引用 DOM 元素 -->
    <!-- 如果想要使用 ref 引用页面上的 DOM 元素，则可以按照如下的方式进行操作： -->
    <!-- <template>
        <h5 ref="myH5">Vue Ref 组件：</h5>
        <button @click="getRef()">获取 $refs 引用</button>
    </template>
    <script>
        export default {
            methods: function () {
                // 通过 this.$refs 引用的名称，可以获取到 DOM 元素的引用
                console.log(this.$refs.myH5);
                // 通过引用组件获取引用来操作 DOM 元素，把文本颜色修改为红色
                this.$refs.myH5.style.color = 'red';
            }
        }
    </script> -->

    <!-- 3. 使用 ref 引用组件实例 -->
    <!-- 如果想要使用 ref 引用页面上的组件实例，则可以按照如下的方式进行操作： -->
    <!-- RefsModule.vue -->
    <!-- <template>
        <div class="refsX">
          <h5 ref="myH5">Count 组件：{{ count }}</h5>
          <button @click="count += 1">点击+1</button><br>
          <button @click="resetCount()">重置数量</button><br>
          <button v-on:click="getRefModule()">获取 $ref 引用</button>
          <br>
          <label>
            // 命名后面带上Ref，就表示是一个引用
            <input type="text" v-if="inputVisible" @blur="showButton()" ref="inputRef">
            <button v-else @click="showInput()">展示输入框吧</button>
          </label>
        </div>
    </template>
    <script>
        export default {
          methods: {
            getRefModule: function () {
              console.log(this.$refs);
              this.$refs.myH5.style.color = 'red';
            },
            resetCount: function () {
                this.count = 0;
            },
            showInput: function () {
              this.inputVisible = true;
              // 显示输入框时就获得焦点
              this.$refs.inputRef.focus();
            },
            showButton: function () {
              this.inputVisible = false;
            }
          }
        }
    </script> -->
    <!-- App.vue -->
    <!-- <template>
        <div class="app-container">
          <div class="one">
            <button @click="getThisRefs()">点击 this</button>
            // 3. 以标签形式，使用注册好的组件
            <RefsModule ref="refsM"></RefsModule>
          </div>
        </div>
    </template>
    <script>
        import RefsModule from "@/components/RefsModule.vue";
        export default {
          //当前组件中的事件函数
          methods: {
            getThisRefs: function () {
              console.log(this);
              this.$refs.refsM.resetCount();
            }
          }
        }
    </script> -->

    <!-- 4. 控制文本框和按钮的按需切换 -->
    <!-- 通过布尔值 inputVisible 来控制组件中的文本框与按钮的按需切换。示例代码如下： -->
    <!-- <template>
        <input type="text" v-if="inputVisible">
        <button v-else @click="showInput()">显示输入框</button>
    </template>
    <script>
        export default {
            data() {
                return {
                    inputVisible: false
                }
            },
            methods: {
                showInput: function () {
                    this.inputVisible = true;
                    // 显示输入框时就获得焦点
                    this.$refs.inputRef.focus();
                }
            }
        }
    </script> -->

    <!-- 5. 让文本框自动获得焦点 -->
    <!-- 当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的 .focus() 方法即可。 -->
    <!-- 示例代码如下： -->
    <!-- <template>
        <input type="text" v-if="inputVisible">
        <button v-else @click="showInput()">显示输入框</button>
    </template>
    <script>
        export default {
            data() {
                return {
                    inputVisible: false
                }
            },
            methods: {
                showInput: function () {
                    this.inputVisible = true;
                    // 显示输入框时就获得焦点
                    this.$refs.inputRef.focus();
                }
            }
        }
    </script> -->

    <!-- 6. this.$nextTick(callback) 方法 -->
    <!-- 组件的 $nextTick(callback) 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。 -->
    <!-- 通俗的理解是： -->
    <!-- 等组件的 DOM 更新完成之后，再执行 callback 回调函数。从而能保证 callback 回调函数可以操作到最新的 DOM 元素。 -->
    <!-- <template>
        <div class="refsX">
          <label>
            // 命名后面带上Ref，就表示是一个引用
            <input type="text" v-if="inputVisible" @blur="showButton()" ref="inputRef">
            <button v-else @click="showInput()">展示输入框吧</button>
          </label>
        </div>
    </template>
    <script>
        export default {
          data() {
            return {
              inputVisible: false
            }
          },
          methods: {
            showInput: function () {
              this.inputVisible = true;
              // 显示输入框时就获得焦点
              this.$nextTick(function () {
                this.$refs.inputRef.focus();
              });
            },
            showButton: function () {
              this.inputVisible = false;
            }
          }
        }
    </script> -->

    <!-- 购物车案例 -->
    <!-- 1. 案例效果 -->
    <!-- 2. 实现步骤 -->
    <!-- 1).初始化项目基本结构。 -->
    <!-- 2).封装 MyHeader 组件。 -->
    <!-- 3).基于 axios 请求商品列表数据（GET请求地址为：https://www.escook.cn/api/cart）。 -->
    <!-- 4).封装 MyFooter 组件。 -->
    <!-- 5).封装 MyGoods 组件。 -->
    <!-- 6).封装 MyCounter 组件。 -->

    <!-- 步骤： -->
    <!-- 1. 安装 axios 网络请求库模块，并且在 App.vue 模块中导入。 -->
    <!-- 2. 使用 methods 方法中，定义 initCartList() 函数请求列表数据。 -->
    <!-- 3. 使用 created 生命周期函数中，调用步骤 2 封装的 initCartList() 函数。 -->
    <!-- 1. 在子组件中，要监听复选框状态变化的事件。拿到最新的勾选状态。 -->
    <!-- 2. 当监听到勾选状态变化之后，应该立即把最新的状态，通过自定义事件的形式，发送给父组件。 -->
    <!-- this.$emit('state-change', {id, value}); -->
    <!-- this.$emit('state-change', {id: this.id, value: event.target.checked}); -->

    <!-- 总结： -->
    <!-- 1).能够知道 vue 中常用的生命周期函数 -->
    <!-- 创建阶段、运行阶段、销毁阶段。 -->
    <!-- created、mounted。 -->
    <!-- 2).能够知道如何实现组件之间的数据共享 -->
    <!-- 父 -> 子（自定义属性）。 -->
    <!-- 子 -> 父（自定义事件）。 -->
    <!-- 兄弟组件（EventBus）。 -->
    <!-- 3).能够知道如何使用 ref 引用 DOM 元素或组件 -->
    <!-- 给元素或组件添加 ref="xxx" 的引用名称。 -->
    <!-- 通过 this.$refs.xxx 获取元素或组件的实例。 -->
    <!-- $nextTick() 函数的执行时机。 -->

    <!-- 五、动态组件章节 -->
    <!-- 1. 什么是动态组件 -->
    <!-- 动态组件指的是动态切换组件的显示与隐藏。 -->

    <!-- 2. 如何实现动态组件渲染 -->
    <!-- vue 提供了一个内置的 <component> 组件，专门用来实现动态组件的渲染。示例代码如下： -->
    <!-- 
    <script>
        export default {
            data() {
                return {
                    // 1. 通过要渲染的组件名称
                    componentName: 'Left'
                }
            }
        }
    </script>
    // 2. 通过绑定属性 is 属性，动态指定要渲染的组件。
    <component v-bind:is="componentName"></component>
    // 3. 点击按钮，动态切换组件的名称。
    <button v-on:click="componentName = 'Left'">显示 Left 组件</button>
    <button v-on:click="componentName = 'Right'">显示 Right 组件</button>
    -->

    <!-- 3. 使用 keep-alive 保持状态 -->
    <!-- 默认情况下，切换动态组件时无法保持组件的状态。此时可以使用 vue 内置的 <keep-alive> 组件保持动态组件的状态。 -->
    <!-- 示例代码如下： -->
    <!-- 
    <keep-alive>
        <component v-bind:is="componentName"></component>
    </keep-alive>
    -->

    <!-- 4. keep-alive 对应的生命周期函数 -->
    <!-- 当组件被缓存时，会自动触发组件的 deactivated 生命周期函数。 -->
    <!-- 当组件被激活时，会自动触发组件的 activated 生命周期函数。 -->
    <!-- 
    <script>
        export default {
            created() {
                console.log(`Left 组件被创建鸟！`);
            },
            destroyed() {
                console.log(`Left 组件被销毁鸟！`);
            }
        }
    </script>
    <script>
        export default {
            created() {
                console.log(`Right 组件被创建鸟！`);
            },
            destroyed() {
                console.log(`Right 组件被销毁鸟！`);
            }
        }
    </script>
    -->

    <!-- 5. keep-alive 的 include 属性 -->
    <!-- include 属性用来指定：只有名称匹配的组件会被缓存。多个组件名之间使用英文的逗号分隔： -->
    <!-- 
    <keep-alive include="MyLeft, MyRight">
        <component v-bing:is="componentName"></component>
    </keep-alive>
    -->
    <!-- 实例演示： -->
    <!-- <template>
        <div class="app-container">
          <h1>App 根组件</h1>
          <hr>
          <button v-on:click="componentName = 'Left'">显示左侧组件</button>
          <button v-on:click="componentName = 'Right'">显示右侧组件</button>
          <div class="box">
            // 渲染 Left 组件和 Right 组件。
            // 1. component 标签是 vue 内置的动态组件标签，作用：组件的占位符。
            // 2. is 属性的值，表示要渲染的组件的名称。
            // 3. is 属性的值，应该是组件在 component 标签节点下的注册名称。
            <component v-bind:is="componentName"></component>
            // 4. keep-alive 对应的生命周期函数。
            // 4. keep-alive 标签可以把内部的组件进行缓存，而不是销毁组件。
            // 当组件被【缓存的时候】，会自动触发组件的【Deactivated()】生命周期函数。
            // 当组件被【激活的时候】，会自动触发组件的【Activitied()】生命周期函数。
            // 5. keep-alive include 属性用来指定，只有名称匹配的组件才会被缓存。
            // 多个组件名称之间使用英文逗号分隔。
            <keep-alive include="Left, Right">
              <component v-bind:is="componentName"></component>
            </keep-alive>
            <keep-alive exclude="Right">
              <component v-bind:is="componentName"></component>
            </keep-alive>
          </div>
        </div>
      </template>
      <script>
        import Left from '@/components/Left.vue';
        import Right from '@/components/Right.vue';
        export default {
          components: {
            Left,
            Right
          },
          data() {
            return {
              componentName: 'Left'
            }
          }
        }
    </script> -->

    <!-- 六、插槽 -->
    <!-- 1. 什么是插槽 -->
    <!-- 插槽（Slot）是 vue 为组件的封装者提供的能力。 -->
    <!-- 允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。 -->
    <!-- 可以把插槽认为是组件封装期间，为用户预留的内容的占位符。 -->

    <!-- 2. 体验插槽的基础用法 -->
    <!-- 在封装组件时，可以通过 <slot> 元素定义插槽，从而为用户预留内容占位符。 -->
    <!-- 示例代码如下： -->
    <!-- 
    <template>
        <p>这是 MyComponentOne 组件的第一个P标签。</p>
        // 通过 slot 标签，为用户预留内容占位符，也叫【插槽】。
        <slot>这是 MyComponentOne 组件最后一个P标签。</slot>
    </template>
    -->

    <!-- 2.1 没有预留插槽的内容会被丢弃 -->
    <!-- 如果在封装组件时没有预留任何 <slot> 插槽，则用户提供的任何自定义内容都会被丢弃。 -->
    <!-- 示例代码如下： -->
    <!-- 
    <template>
        <p>这是 MyComponentOne 组件的第一个P标签。</p>
        // 通过 slot 标签，为用户预留内容占位符，也叫【插槽】。
        <slot>这是 MyComponentOne 组件最后一个P标签。</slot>
    </template>
    <my-component-one>
        // 自定义的内容会被丢弃
        <p>用户自定义的内容</p>
    </my-component-one>
    -->

    <!-- 2.2 后备内容 -->
    <!-- 封装组件时，可以为预留的 <slot> 插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。 -->
    <!-- 示例代码如下： -->
    <!-- 
    <template>
        <p>这是 MyComponentOne 组件的第一个P标签。</p>
        // 通过 slot 标签，为用户预留内容占位符，也叫【插槽】。
        <slot>这是后备内容</slot>
        <p>这是 MyComponentOne 组件最后一个P标签。</p>
    </template>
    -->
    <!-- 案例演示： -->
    <!-- 
    <template>
        <div class="app-container">
            // Slot 插槽
            <Left>
              <template v-slot:default>
                <span>这是 Left 组件的内容区域</span>
              </template>
            </Left>
            // Slot 插槽简写 v-slot:default 恒等于 #default
            <Left>
              <template #default>
                <span>这是 Left 组件的内容区域</span>
              </template>
            </Left>
            <Right>
              <template #default>
                <span>这是 Right 组件的内容区域</span>
              </template>
            </Right>
          </div>
        </div>
    </template>
    <script>
        import Left from '@/components/Left.vue';
        import Right from '@/components/Right.vue';
        export default {
          components: {
            Left,
            Right
          },
          data() {
            return {
              componentName: 'Left'
            }
          }
        }
    </script>
    -->

    <!-- 3. 具名插槽 -->
    <!-- 如果在封装组件时需要预留多个插槽节点，则需要为每个 <slot> 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做【具名插槽】。 -->
    <!-- 示例代码如下： -->
    <!-- 注意：没有指定 name 名称的插槽，会有隐含的名称叫做【default】。 -->
    <!-- 【第一组件】App.vue -->
    <!-- <template>
        <div class="app-container">
            // 无名插槽：Slot 插槽
            // <Left>
            //   <template v-slot:default>
            //     <span>这是 Left 组件的内容区域</span>
            //   </template>
            // </Left>
            // 具名插槽：Slot 插槽简写 v-slot:default 恒等于 #default
            <Left>
              <template #default>
                <span>这是 Left 组件的内容区域</span>
              </template>
            </Left>
            <Right>
              <template #default>
                <span>这是 Right 组件的内容区域</span>
              </template>
              <template #content="obj">
                <span>这是 Right 组件的内容区域</span>
                <span>{{ obj.message }}</span>
              </template>
              // 【ES5】解构赋值
              <template #footer="{ message, userInfo }">
                <span>这是 Right 组件的内容区域</span><br>
                <span>{{ message }}</span><br>
                <span>{{ userInfo.name }}</span><br>
                <span>{{ userInfo.age }}</span><br>
              </template>
            </Right>
          </div>
        </div>
    </template>
    <script>
      import Left from '@/components/Left.vue';
      import Right from '@/components/Right.vue';
      export default {
        components: {
          Left,
          Right
        }
      }
    </script> -->
    <!-- 【第二组件】Right.vue -->
    <!-- <template>
        <div class="right-container">
          <h3>Right 组件</h3>
          <hr>
          <div>
            // 这种叫做具名插槽
            <slot name="default">
              <span>这是 Right 组件的默认内容区域</span>
            </slot>
          </div>
          <hr>
          <div>
            // 这种叫做具名插槽
            // 在封装组件中，为预留<slot>提供属性对应的值，这种用法，叫做【作用域插槽】。
            <slot name="content" message="这里可以传值">
              <span>这是 Right 组件的默认内容区域</span>
            </slot>
          </div>
          <hr>
          <div>
            // 这种叫做具名插槽
            // 通过属性动态绑定：v-bind:userInfo="userInfo"
            <slot name="footer" message="这里可以传值" v-bind:userInfo="userInfo">
              <span>这是 Right 组件的默认内容区域</span>
            </slot>
          </div>
        </div>
    </template>
    <script>
        export default {
          data() {
            return {
              count: 0,
              userInfo: {
                name: '石斑鱼',
                age: 800
              }
            }
          },
          created() {
            console.log(`Right 组件被创建了呀！`);
          },
          destroyed() {
            console.log(`Right 组件被销毁了呀！`);
          },
          activated() {
            console.log(`Right 组件激活了 Activated 生命周期函数！`);
          },
          deactivated() {
            console.log(`Right 组件激活了 Deactivated 生命周期函数！`);
          }
        }
    </script> -->

    <!-- 3.1 为具名插槽提供内容 -->
    <!-- 在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。 -->
    <!-- 示例代码如下： -->
    <!-- <div>
        // 这种叫做具名插槽
        <slot name="default">
          <span>这是 Right 组件的默认内容区域</span>
        </slot>
      </div>
      <hr>
      <div>
        // 这种叫做具名插槽
        // 在封装组件中，为预留<slot>提供属性对应的值，这种用法，叫做【作用域插槽】。
        <slot name="content" message="这里可以传值">
          <span>这是 Right 组件的默认内容区域</span>
        </slot>
      </div>
      <hr>
      <div>
        // 这种叫做具名插槽
        // 通过属性动态绑定：v-bind:userInfo="userInfo"
        <slot name="footer" message="这里可以传值" v-bind:userInfo="userInfo">
          <span>这是 Right 组件的默认内容区域</span>
        </slot>
    </div> -->

    <!-- 3.2 具名插槽的简写形式 -->
    <!-- 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。 -->
    <!-- 例如 v-slot:header 可以被重写为 #header： -->
    <!-- // 具名插槽：Slot 插槽简写 v-slot:default 恒等于 #default
    <Left>
      <template #default>
        <span>这是 Left 组件的内容区域</span>
      </template>
    </Left>
    <Right>
      <template #default>
        <span>这是 Right 组件的内容区域</span>
      </template>
      <template #content="obj">
        <span>这是 Right 组件的内容区域</span>
        <span>{{ obj.message }}</span>
      </template>
      // 【ES5】解构赋值
      <template #footer="{ message, userInfo }">
        <span>这是 Right 组件的内容区域</span><br>
        <span>{{ message }}</span><br>
        <span>{{ userInfo.name }}</span><br>
        <span>{{ userInfo.age }}</span><br>
      </template>
    </Right> -->

    <!-- 4. 作用域插槽 -->
    <!-- 在封装组件的过程中，可以为预留的 <slot> 插槽绑定 props 数据，这种带有 props 数据的 <slot> 叫做【作用域插槽】。 -->
    <!-- 示例代码如下： -->

    <!-- 4.1 使用作用域插槽 -->
    <!-- 可以使用 v-slot: 的形式，接收作用域插槽对外提供的数据。 -->
    <!-- 示例代码如下： -->

    <!-- 4.2 解构插槽 Prop -->
    <!-- 作用域插槽对外提供的数据对象，可以使用解构赋值简化数据的接收过程。 -->
    <!-- 示例代码如下： -->
    <!-- App.vue 引入插槽以及父子传值： -->
    <!-- <template>
        <div class="app-container">
            // v-slot 插槽
            <Counter v-slot:default
                     v-bind:num="goods.goods_count"
                     v-bind:id="goods.id"
                     v-on:num-change="getNewNum(item, $event)">
            </Counter>
          </Goods>
        </div>
    </template>
    <script>
        import Counter from "@/components/Counter/Counter.vue";
        export default {
          components: {
            Counter
          },
          methods: {
            getNewNum(item, event) {
              item.goods_count = event;
            }
          }
        }
    </script> -->
    <!-- Goods.vue 预留 slot 插槽： -->
    <!-- 
    <template>
        <div class="goods-container">
            // 商品的数量
            <slot name="default"></slot>
        </div>
    </template>
    -->
    <!-- Counter.vue 父子相互传值： -->
    <!-- 
    <template>
        <div>
          <button type="button" class="btn btn-light btn-sm" v-on:click="sub">-</button>
          <span class="number-box">{{ num }}</span>
          <button type="button" class="btn btn-light btn-sm" v-on:click="add">+</button>
        </div>
    </template>
    <script>
        import bus from '@/components/eventBus.js';
        export default {
          props: {
            id: {
              type: Number,
              required: true
            },
            num: {
              type: Number,
              default: 1
            }
          },
          methods: {
            add() {
              this.num++;
              this.$emit('num-change', this.num);
            },
            sub() {
              this.num--;
              this.$emit('num-change', this.num);
            }
          }
        }
    </script>
    -->

    <!-- 七、自定义指令 -->
    <!-- 1. 什么是自定义指令 -->
    <!-- vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令。 -->

    <!-- 2. 自定义指令的分类 -->
    <!-- vue 中的自定义指令分为两类，分别是： -->
    <!-- 1).私有自定义指令。 -->
    <!-- 
    export default {
        directives: {
          // 自定义名为 color 的指令，指向一个配置对象。
          color: {
            // 当指令第一次被绑定到元素上的时候，会立即触发 bind() 函数。
            // 形式参数 el 表示当前的指令所绑定到的那个 DOM 对象。
            // 形式参数 binding 表示当前的指令所传递过来的那个 DOM 对象的值。
            bind(el, binding) {
              el.style.fontSize = '14px';
              console.log(`触发了 v-color 的 bind() 函数。`);
              el.style.color = binding.value;
            },
            update(el, binding) {
              console.log(`触发了 v-color 的 update() 函数。`);
              el.style.color = binding.value;
            }
          }
    }, 
    -->
    <!-- 2).全局自定义指令。 -->
    <!-- 
    import Vue from 'vue';
    import App from './App.vue';
    import 'bootstrap/dist/css/bootstrap.min.css'
    Vue.config.productionTip = false;
    import Counter from "@/components/Counter/Counter.vue";
    Vue.component('Counter', Counter);
    Vue.directive('color', (el, binding) => el.style.color = binding.value);
    new Vue({render: h => h(App)}).$mount('#app');
    -->

    <!-- 3. 私有自定义指令 -->
    <!-- 在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令。示例代码如下： -->
    <!-- <template>
        <div class="header-container" v-color="color">
          <span>{{ title }}</span>
        </div>
    </template>
    <script>
      export default {
            directives: {
                // 自定义名为 color 的指令，指向一个配置对象。
                color: {
                    // 当指令第一次被绑定到元素上的时候，会立即触发 bind() 函数。
                    // 形式参数 el 表示当前的指令所绑定到的那个 DOM 对象。
                    // 形式参数 binding 表示当前的指令所传递过来的那个 DOM 对象的值。
                    bind(el, binding) {
                    el.style.fontSize = '14px';
                    console.log(`触发了 v-color 的 bind() 函数。`);
                    el.style.color = binding.value;
                    },
                    update(el, binding) {
                    console.log(`触发了 v-color 的 update() 函数。`);
                    el.style.color = binding.value;
                    }
                }
            }
        }
    </script> -->

    <!-- 4. 使用自定义指令 -->
    <!-- 在使用自定义指令时，需要加上【v-】前缀。示例代码如下： -->

    <!-- 5. 为自定义指令动态绑定参数值 -->
    <!-- 在 template 结构中使用自定义指令时，可以通过等号（=）的方式，为当前指令动态绑定参数值： -->

    <!-- 6. 通过 binding 获取指令的参数值 -->
    <!-- 在声明自定义指令时，可以通过形参中的第二个参数，来接收指令的参数值： -->

    <!-- 7. update 函数 -->
    <!-- bind 函数只调用 1 次：当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。  -->
    <!-- update 函数会在每次 DOM 更新时被调用。 -->
    <!-- 示例代码如下： -->
    <!-- 
    <template>
        <div class="header-container" v-color="color">
          <span>{{ title }}</span>
        </div>
    </template>
    <script>
      export default {
        directives: {
          // 自定义名为 color 的指令，指向一个配置对象。
          color: {
            // 当指令第一次被绑定到元素上的时候，会立即触发 bind() 函数。
            // 形式参数 el 表示当前的指令所绑定到的那个 DOM 对象。
            // 形式参数 binding 表示当前的指令所传递过来的那个 DOM 对象的值。
            bind(el, binding) {
              el.style.fontSize = '14px';
              console.log(`触发了 v-color 的 bind() 函数。`);
              el.style.color = binding.value;
            },
            update(el, binding) {
              console.log(`触发了 v-color 的 update() 函数。`);
              el.style.color = binding.value;
            }
          }
        }
    </script>
    -->

    <!-- 8. 函数简写 -->
    <!-- 如果 insert 和update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式： -->

    <!-- 9. 全局自定义指令 -->
    <!-- 全局共享的自定义指令需要通过【Vue.directive()】进行声明，示例代码如下： -->
    <!-- 1).能够掌握 keep-alive 元素的基本使用 -->
    <!-- <keep-alive> 标签、include 属性 -->
    <!-- 2).能够掌握插槽的基本用 -->
    <!-- <slot> 标签、具名插槽、作用域插槽、后备内容 -->
    <!-- 3).能够知道如何自定义指令 -->
    <!-- 私有自定义指令：directives:{} -->
    <!-- 全局自定义指令：Vue.directive() -->
    <!-- 
    <template>
        <div class="header-container" v-color="color">
          <span>{{ title }}</span>
        </div>
    </template>
    <script>
      export default {
        directives: {
          // 自定义名为 color 的指令，指向一个配置对象。
          color: {
            // 当指令第一次被绑定到元素上的时候，会立即触发 bind() 函数。
            // 形式参数 el 表示当前的指令所绑定到的那个 DOM 对象。
            // 形式参数 binding 表示当前的指令所传递过来的那个 DOM 对象的值。
            bind(el, binding) {
              el.style.fontSize = '14px';
              console.log(`触发了 v-color 的 bind() 函数。`);
              el.style.color = binding.value;
            },
            update(el, binding) {
              console.log(`触发了 v-color 的 update() 函数。`);
              el.style.color = binding.value;
            }
          }
        },
        props: {
          // 声明 title 自定义属性，允许使用者自定义标题的内容。
          title: {
            default: '',
            type: String
          }
        },
        data() {
          return {
            color: 'yellow'
          }
        }
    }
    </script>
    -->

    <!-- ESLint 插件 -->
    <!-- 官网地址：https://eslint.nodejs.cn/docs/latest/ -->
    <!-- 下载模块：npm init @eslint/config -->

    <!-- Axios 模块 -->
    <!-- 下载模块：npm install --save axios -->
    <!-- 下载模块：npm install axios -S -->
    <!-- 案例演示： -->
    <!-- 
    import Vue from 'vue';
    import App from './App.vue';
    import axios from "axios";
    Vue.config.productionTip = false;
    // 全局配置请求根路径
    // 装逼写法：Vue.prototype.$http = axios;
    Vue.prototype.axios = axios;
    axios.defaults.baseURL = 'https://localhost:3007';
    // 但是，这种把axios挂载到vue原型上的写法有一个缺点，就是利于api接口的复用。
    new Vue({
      render: h => h(App),
    }).$mount('#app');
    -->
    <!-- 
    <script>
        export default {
            methods: {
                async postInfo() {
                    const { data: res } = await this.axios.post(
                        '/api/cart',
                        {
                            name: 'Jessica',
                            age: 38
                        }
                    );
                    console.log(res);
                },
                async btnGetBooks() {
                    const { data: res } = await this.axios.get(
                        '/api/cart'
                    );
                    console.log(res);
                }
            },
        }
    </script>
    -->

    <!-- 八、路由章节 -->
    <!-- 锚链接概念： -->
    <!-- 
    // CSS Files
    <link rel="stylesheet" href="./bootstrap-3.4.1-dist/css/bootstrap.css">
    <style>
        .side-bar {
            position: fixed;
            top: 400px;
            left: 0px;
        }
        #b1, #b2, #b3, #b4 {
            width: 100%;
            height: 1400px;
        }
        #b1 {
            background-color: burlywood;
        }
        #b2 {
            background-color: cadetblue;
        }
        #b3 {
            background-color: chocolate;
        }
        #b4 {
            background-color: darkgreen;
        }
    </style>
    // JS Files
    <script src="./js/jquery-3.5.1.js"></script>
    // 这就是传说中的锚链接呀。页面不会跳转，但是会有历史记录。
    // ./example-04.html#b1
    // ./example-04.html#b2
    // ./example-04.html#b3
    // ./example-04.html#b4
    <div class="side-bar">
        <a href="#b1">点击它锚链接到#b1就是id="b1"的div块上</a>
        <a href="#b2">点击它锚链接到#b2就是id="b2"的div块上</a>
        <a href="#b3">点击它锚链接到#b3就是id="b3"的div块上</a>
        <a href="#b4">点击它锚链接到#b4就是id="b4"的div块上</a>
    </div>
    <div id="b1"></div>
    <div id="b2"></div>
    <div id="b3"></div>
    <div id="b4"></div>
    -->
    <!-- href 属性是一个可读可写的字符串，可设置或返回当前显示的文档的完整URL。 -->
    <!-- hash 属性是一个可读可写的字符串，该字符串是URL的锚部分（从#号开始的部分）。 -->
    <!-- 【锚链接】===【路由链接】 -->

    <!-- 前端路由的概念 -->
    <!-- 1. 什么是路由 -->
    <!-- 路由（英文：router）就是对应关系。 -->
    <!-- 对应关系，是指这个 hash 地址与 vue 组件的对应关系。 -->
    <!-- 不同的 hash 地址（#/home，也就是传说中的锚链接），会展示不同的 vue 组件。 -->
    <!-- 传说中的锚链接：页面不会跳转，但是会导致页面的上下跳转，还会导致历史记录的变化。 -->

    <!-- 3. SPA 与前端路由 -->
    <!-- SPA 指的是一个 web 网站只有唯一的一个 HTML 页面，所有组件的展示与切换都在这唯一的一个页面内完成。 -->
    <!-- 此时，不同组件之间的切换需要通过前端路由来实现。 -->
    <!-- 结论：在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成！ -->

    <!-- 4. 什么是前端路由 -->
    <!-- 通俗易懂的概念：Hash 地址（#/home，也就是传说中的锚链接）与 vue 组件之间的对应关系。 -->
    <!-- 
    // 这就是传说中的锚链接呀。页面不会跳转，但是会有历史记录。
    // ./example-04.html#b1
    // ./example-04.html#b2
    // ./example-04.html#b3
    // ./example-04.html#b4
    <div class="side-bar">
        <a href="#b1">点击它锚链接到#b1就是id="b1"的div块上</a>
        <a href="#b2">点击它锚链接到#b2就是id="b2"的div块上</a>
        <a href="#b3">点击它锚链接到#b3就是id="b3"的div块上</a>
        <a href="#b4">点击它锚链接到#b4就是id="b4"的div块上</a>
    </div>
    <div id="b1"></div>
    <div id="b2"></div>
    <div id="b3"></div>
    <div id="b4"></div>
    -->

    <!-- 5. 前端路由的工作方式 -->
    <!-- 1).用户点击了页面上的路由链接。 -->
    <!-- 2).导致了 URL 地址栏中的 Hash 值发生了变化。 -->
    <!-- 3).前端路由监听了到 Hash 地址的变化。 -->
    <!-- 4).前端路由把当前 Hash 地址对应的组件渲染都浏览器中。 -->
    <!-- 页面上的路由链接：           前端路由的对应关系：                        页面上要展示的组件： -->
    <!-- <a href="#/home"></a>     {path: '#/home',  compoment: Home},      首页组件。 -->
    <!-- <a href="#/movie"></a>    {path: '#/movie', compoment: Movie},     电影组件。 -->
    <!-- <a href="#/about"></a>    {path: '#/about', compoment: about},     关于组件。 -->
    <!-- 结论：前端路由，指的是 Hash 地址与组件之间的对应关系。 -->
    <!-- 总结：前端路由，它底层的核心原理，就是监听了 hash 地址的变化。使用 window.onhashchange 窗口对象属性进行控制。 -->

    <!-- 6. 实现简易的前端路由 -->
    <!-- 步骤1：通过 <component> 标签，结合 comName 动态渲染组件。示例代码如下： -->
    <!-- 步骤2：在 App.vue 组件中，为 <a> 链接添加对应的 hash 值： -->
    <!-- 步骤3：在 created 生命周期函数中，监听浏览器地址栏中 hash 地址的变化，动态切换要展示的组件的名称： -->
    <!-- 
    <template>
        <div class="app-container">
            <h1>App 根组件</h1>
            <hr>
            <a href="#/home">首页</a>
            <a href="#/movie">电影</a>
            <a href="#/about">关于</a>
            <hr>
            // 动态组件 + 动态变量
            <component v-bind:is="componentName"></component>
        </div>
    </template>
    <script>
        // 导入组件
        import Home  from '@/components/Home.vue';
        import Movie from '@/components/Movie.vue';
        import About from '@/components/About.vue';
        export default {
            name: 'App',
            // 注册组件
            components: {
                Home,
                Movie,
                About
            },
            data() {
                return {
                    componentName: 'Home'
                }
            },
            created() {
                // 只要当前的app组件一旦被创建，就立即监听window对象的onhashchange事件。
                window.onhashchange = () => {
                    console.log(`200 -> ${location.hash}`);
                    switch (location.hash) {
                        case '#/home':
                            this.componentName = 'Home';
                            break;
                        case '#/movie':
                            this.componentName = 'Movie';
                            break;
                        case '#/about':
                            this.componentName = 'About';
                            break;
                        default:
                            break;
                    }
                }
            }
        }
    </script>
    -->

    <!-- vue-router 路由的基本使用 -->
    <!-- 1. vue-router 概念 -->
    <!-- vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。 -->
    <!-- vue-router 的官方文档地址：https://router.vuejs.org/zh/ -->

    <!-- 2. vue-router 安装和配置的步骤 -->
    <!-- 1).安装 vue-router 包。 -->
    <!-- 2).创建路由模块。 -->
    <!-- 3).导入并挂载路由模块。 -->
    <!-- 4).声明路由链接和占位符。 -->

    <!-- 2.1 在项目中安装 vue-router -->
    <!-- 在 vue2 的项目中，安装 vue-router 的命令如下： -->
    <!-- # npm install --save vue-router@3.2.0 -->
    <!-- # npm install vue-router@3.2.0 -S -->

    <!-- 2.2 创建路由模块 -->
    <!-- 在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码： -->
    <!-- 示例代码如下：/src/router/index.js -->
    <!-- 
        // 1. 导入第三方模块
        import Vue from 'vue';
        // 1. 导入第三方模块
        import VueRouter from "vue-router";
        import Home from "@/components/Home.vue";
        import Movie from "@/components/Movie.vue";
        import About from "@/components/About.vue";
        // 2. 使用
        Vue.use(VueRouter);
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie', component: Movie},
                {path: '/about', component: About}
            ]
        });
        // 4. 共享出去
        export default router;
    -->

    <!-- 2.3 导入并挂载路由模块 -->
    <!-- 在 src/main.js 入口文件中，导入并挂载路由模块。 -->
    <!-- 示例代码如下：/src/main.js -->
    <!-- 
        import Vue from 'vue';
        import App from './App2.vue';
        // 导入路由模块
        // import router from "@/router";
        import router from "@/router/index.js";
        // 导入 bootstrap 样式
        import 'bootstrap/dist/css/bootstrap.min.css';
        // 全局样式
        import '@/assets/global.css';
        Vue.config.productionTip = false;
        new Vue({
            render: h => h(App),
            router: router
        }).$mount('#app');
    -->

    <!-- 2.4 声明路由链接和占位符 -->
    <!-- 1).在 src/App.vue 组件中，使用 vue-router 提供的【<router-view>】声明路由【占位符】： -->
    <!-- 示例代码如下：/src/App.vue -->
    <!-- 
    <template>
        <div class="app-container">
          <h1>App2 组件</h1>
          // 子级路由的链接
          <a href="#/home">公司首页</a>
          <a href="#/movie">电影界面</a>
          <a href="#/about">关于我们</a>
          <hr>
          // 子级路由的占位符
          // 只要在项目中安装和配置了 vue-router，就可以使用 router-view 这个组件了。
          // 它的作用很单纯：占位符
          <router-view></router-view>
        </div>
    </template>
    <script>
        export default {
          name: 'App'
        }
    </script>
    -->
    <!-- 2).在 src/App.vue 组件中，使用 vue-router 提供的【<router-link>】和【<router-view>】声明路由【链接】和【占位符】： -->
    <!-- 示例代码如下：/src/App2.vue -->
    <!-- 
    <template>
        <div class="app-container">
            <h1>App2 组件</h1>
            // 子级路由的链接
            <router-link to="/home">公司首页</router-link>
            <router-link to="/movie">电影界面</router-link>
            <router-link to="/about">关于我们</router-link>
            <hr>
            // 子级路由的占位符
            // 只要在项目中安装和配置了 vue-router，就可以使用 router-view 这个组件了。
            // 它的作用很单纯：占位符
            <router-view></router-view>
        </div>
    </template>
    <script>
        export default {
            name: 'App'
        }
    </script>
    -->

    <!-- 3. 声明路由的匹配规则 -->
    <!-- 在 src/router/index.js 路由模块中，通过【routes】数组声明路由的匹配规则。 -->
    <!-- 示例代码如下： -->
    <!-- 
        // 1. 导入第三方模块
        import Vue from 'vue';
        // 1. 导入第三方模块
        import VueRouter from "vue-router";
        import Home from "@/components/Home.vue";
        import Movie from "@/components/Movie.vue";
        import About from "@/components/About.vue";
        // 2. 使用
        Vue.use(VueRouter);
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie', component: Movie},
                {path: '/about', component: About}
            ]
        });
        // 4. 共享出去
        export default router;
    -->

    <!-- vue-router 路由的常见用法 -->
    <!-- 1. 路由重定向 -->
    <!-- 路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。 -->
    <!-- 通过路由规则的【redirect】属性，指定一个新的路由地址，可以很方便地设置路由的重定向： -->
    <!-- 
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie', component: Movie},
                {path: '/about', component: About}
            ]
        });
    -->

    <!-- 2. 嵌套路由 -->
    <!-- 通过路由实现组件的嵌套展示，叫做嵌套路由。 -->
    <!-- 点击父级路由链接显示模板内容： -->
    <!-- 1).模板内容中又有子级路由链接。 -->
    <!-- 2).点击子级路由链接显示子级模板内容。 -->

    <!-- 3.1 声明子路由链接和子路由占位符 -->
    <!-- 在 About.vue 组件中，声明 tab1 和 tab2 的子路由链接以及子路由占位符。示例代码如下： -->
    <!-- 
    <template>
        <div class="about-container">
          <h3>About 组件</h3>
          // 子级路由的链接
          <router-link to="/about/tab1">tab1</router-link>
          <router-link to="/about/tab2">tab2</router-link>
          <hr>
          // 子级路由的占位符
          <router-view></router-view>
        </div>
    </template>
    -->

    <!-- 3.2 通过 children 属性声明子路由规则 -->
    <!-- 在 src/router/index.js 路由模块中，导入需要的组件，并使用 children 属性声明子路由规则： -->
    <!-- 写法一：通过【children】属性指定重定向子路由。 -->
    <!-- 
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie', component: Movie},
                {
                    path: '/about', component: About, redirect: '/about/tab1', children: [
                        {path: 'tab1', component: Tab1},
                        {path: 'tab2', component: Tab2}
                    ]
                }
            ]
        });
    -->
    <!-- 写法二：通过默认子路由（如果【children】数组中，某个路由规则的【path】值为空字符串，则这条路由规则，叫做默认子路由。） -->
    <!-- 
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie', component: Movie},
                {
                    path: '/about', component: About, children: [
                        {path: '', component: Tab1},
                        {path: 'tab2', component: Tab2}
                    ]
                }
            ]
        });
    -->

    <!-- 4. 动态路由匹配 -->
    <!-- 思考：有如下 3 个路由链接。 -->
    <!-- 
        <router-link to="/about/tab1">子路由一</router-link>
        <router-link to="/about/tab2">子路由二</router-link>
        <router-link to="/about/tab3">子路由三</router-link>
    -->
    <!-- 思考：，定义如下 3 个路由规则，是否可行。 -->
    <!-- 
        {path: '/about/tab1', component: Tab1},
        {path: '/about/tab2', component: Tab2},
        {path: '/about/tab3', component: Tab3}
    -->
    <!-- 缺点：路由规则的复用性差。 -->
    
    <!-- 4.1 动态路由的概念 -->
    <!-- 动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。 -->
    <!-- 在 vue-router 中使用英文的冒号（:）来定义路由的参数项。 -->
    <!-- 示例代码如下： -->
    <!-- 
        // 路由中的动态参数以英文的冒号（:）进行声明，冒号后面的是动态参数的名称。
        {path: '/media/:id', component: Media}
        // 将以下 3 个路由规则，合并成了一个，提高了路由规则的复用性。
        {path: '/media/1', component: Media}
        {path: '/media/2', component: Media}
        {path: '/media/3', component: Media}
    -->

    <!-- 4.2 $route.params 参数对象 -->
    <!-- 在动态路由渲染出来的组件中，可以使用 this.$route.params 对象访问到动态匹配的参数值。 -->
    <!-- 
    <template>
        <div class="movie-container">
            // this.$route  是路由的参数对象。
            // this.$router 是路由的导航对象。
            <h3>Movie 组件 - {{ this.$route.params.mid }} - {{ mid }}</h3>
            <button v-on:click="printThisInfo()">打印 this</button>
        </div>
        </template>
        <script>
        export default {
        name: 'Movie',
        props: [
            'mid'
        ],
        data() {
            return {

            }
        },
        methods: {
            printThisInfo() {
                console.log(this);
            }
        }
    }
    </script>
    -->

    <!-- 4.3 使用 props 接收路由参数 -->
    <!-- 为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参。 -->
    <!-- 示例代码如下： -->
    <!-- 
        // 3. 创建实例
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie/:mid', component: Movie, props: true},
                {
                    path: '/about', component: About, redirect: '/about/tab1', children: [
                        {path: 'tab1', component: Tab1},
                        {path: 'tab2', component: Tab2}
                    ]
                }
            ]
        });
    -->
    <!-- 
    <template>
        <div class="app-container">
            // this.$route  是路由的参数对象。
            // this.$router 是路由的导航对象。
            <h1>App2 组件 - {{ this.$route.params.mid }}</h1>
            // 子级路由的链接
            // <a href="#/home">公司首页</a>
            <router-link to="/home">公司首页</router-link>
            // <a href="#/movie">电影界面</a>
            // 在 hash 地址中，斜杠（/）后面的参数项，叫做路径参数。
            // 在路由参数对象中，需要使用 this.$route.params 来访问路径参数。
            // 在 hash 地址中，问号（?）后面的参数项，叫做查询参数。
            // 在路由参数对象中，需要使用 this.$route.query  来访问查询参数。
            // 在 this.$route 中，path 只是路径请求地址，fullPath 才是完整的路径地址，带参数。
            <router-link to="/movie/1">红楼梦</router-link>
            <router-link to="/movie/2">西游记</router-link>
            <router-link to="/movie/3">金瓶梅</router-link>
            // <a href="#/about">关于我们</a>
            <router-link to="/about">关于我们</router-link>
            <hr>
            // 子级路由的占位符
            // 只要在项目中安装和配置了 vue-router，就可以使用 router-view 这个组件了。
            // 它的作用很单纯：占位符
            <router-view></router-view>
        </div>
    </template>
    -->
    <!-- 
    <template>
        <div class="movie-container">
            // this.$route  是路由的参数对象。
            // this.$router 是路由的导航对象。
            <h3>Movie 组件 - {{ this.$route.params.mid }} - {{ mid }}</h3>
            <button v-on:click="printThisInfo()">打印 this</button>
        </div>
    </template>
    <script>
        export default {
        name: 'Movie',
        props: [
            'mid'
        ],
        data() {
            return {

            }
        },
        methods: {
            printThisInfo() {
            console.log(this);
            }
        }
    }
    </script>
    -->

    <!-- 5. 声明式导航 & 编程式导航 -->
    <!-- 在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如： -->
    <!-- 1).普通网页中点击 <a> 链接、vue 项目中点击 <router-link> 都属于声明式导航。 -->
    <!-- 在浏览器中，调用 API 方法实现导航的方式，叫做编程式导航。例如： -->
    <!-- 2).普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航。 -->

    <!-- 5.1 vue-router 中的编程式导航 API -->
    <!-- vue-router 提供了许多编程式导航的 API，其中最常用的导航 API 分别是： -->
    <!-- 1).this.$router.push('hash 地址'); -->
    <!-- 跳转到指定 hash 地址，并增加一条历史记录。 -->
    <!-- 2).this.$router.replace('hash 地址'); -->
    <!-- 跳转到指定的 hash 地址，并替换掉当前的历史记录。 -->
    <!-- 3).this.$router.go(数值 n); -->
    <!-- 实现导航历史前进、后退。 -->

    <!-- 5.2 $router.push -->
    <!-- 调用 this.$router.push() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。 -->
    <!-- 示例代码如下： -->

    <!-- 5.3 $router.replace -->
    <!-- 调用 this.$router.replace() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。 -->
    <!-- push 和 replace 的区别： -->
    <!-- 1).push()    方法，会增加一条历史记录。 -->
    <!-- 2).replace() 方法，不会增加历史记录，而是替换掉当前的历史记录。 -->
    <!-- 3).go()      方法，可以在浏览历史中前进和后退。 -->

    <!-- 5.4 $router.go -->
    <!-- 调用 this.$router.go() 方法，可以在浏览历史中前进和后退。 -->
    <!-- 示例代码如下： -->

    <!-- 5.5 $router.go 的简化用法 -->
    <!-- 在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法： -->
    <!-- 1).push()            方法，会增加一条历史记录。 -->
    <!-- 2).replace()         方法，不会增加历史记录，而是替换掉当前的历史记录。 -->
    <!-- 3).go()              方法，可以在浏览历史中前进和后退。 -->
    <!-- 1).$router.back()    方法，在历史记录中，后退到上一个页面。 -->
    <!-- 2).$router.forward() 方法，在历史记录中，前进到下一个页面。 -->
    <!-- 
        <template>
        <div class="home-container">
            <h3>Home 组件</h3>
            <hr>
            <button v-on:click="goToPush()">push()跳转到某个页面</button>
            <button v-on:click="goToReplace()">replace()跳转到某个页面</button>
            <button v-on:click="goToGo">go()跳转到某个页面</button>
            // 在行内使用编程式导航，跳转的时候，this 必须要省略，否则会报错。
            <button v-on:click="$router.back()">back()跳转到某个页面</button>
            <button v-on:click="$router.forward()">forward()跳转到某个页面</button>
        </div>
    </template>
    <script>
        export default {
            name: 'Home',
            methods: {
            goToPush() {
                this.$router.push('/movie/1');
            },
            goToReplace() {
                this.$router.replace('/movie/1');
            },
            goToGo() {
                this.$router.go(-1);
            }
            }
        }
    </script>
    -->

    <!-- 6. 导航守卫 -->
    <!-- 导航守卫可以控制路由的访问权限。 -->
    <!-- 示意图如下： -->
    <!-- 1).<router-link to="/main">Home 首页</router-link> 想要跳转到 Main 后台主页。 -->
    <!-- 未登录的情况下，访问后台主页。 -->
    <!-- 无法控制访问权限，用户可以直接访问后台主页。 -->
    <!-- 2).<router-link to="/main">Home 首页</router-link> 通过导航守卫再跳转到 Main 后台主页。 -->
    <!-- 未登录的情况下，访问后台主页。 -->
    <!-- 检测到未登录，强制跳转到登录页。 -->
    <!-- next()         方法，跳转到 Main 后台主页。 -->
    <!-- next('/login') 方法，跳转到 Index 首页登录。 -->
    <!-- 当前用户拥有后台主页的访问权限，直接放行：next() -->
    <!-- 当前用户没有后台主页的访问权限，强制其跳转到登录页面：next('/login') -->
    <!-- 当前用户没有后台主页的访问权限，不允许跳转到后台页面：next(false) -->

    <!-- 6.1 全局前置守卫 -->
    <!-- 每次发生路由的导航跳转时，都会触发全局前置守卫。因此，在全局前置守卫中，程序员可以对每个路由进行访问权限的控制： -->
    <!-- // 创建路由实例对象 -->
    <!-- const router = new VueRouter({ ... }); -->
    <!-- // 调用路由实例对象的 beforeEach() 函数。 -->
    <!-- // 每次发生路由导航跳转的时候，都会自动触发 fn 这个【回调函数】。 -->
    <!-- router.beforeEach(fn); -->

    <!-- 6.2 守卫方法的 3 个形参 -->
    <!-- 全局前置守卫的回调函数中接收 3 个形参，格式为： -->
    <!-- // 创建路由实例对象 -->
    <!-- const router = new VueRouter({ ... }); -->
    <!-- // 全局前置守卫 -->
    <!-- router.beforeEach((to, from, next) => {
        // to   参数是将要访问的路由的信息对象。
        console.log(to);
        // from 参数是将要离开的路由信息对象。
        console.log(from);
        // next 参数是一个函数，调用 next() 函数表示放行，允许这次路由导航。
        console.log(next);
        next()
    }); -->

    <!-- 6.3 next 函数的 3 种调用方式 -->
    <!-- 参考示意图，分析 next 函数的 3 种调用方式最终导致的结果： -->
    <!-- 1).当前用户拥有后台主页的访问权限，直接放行：next() -->
    <!-- 2).当前用户没有后台主页的访问权限，强制其跳转到登录页面：next('/login') -->
    <!-- 3).当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false) -->

    <!-- 6.4 控制后台主页的访问权限 -->
    <!-- 
        // 1. 导入第三方模块
        import VueRouter from "vue-router";
        // 2. 把 VueRouter 安装为 Vue 项目的插件，Vue.use() 函数的作用，就是来安装插件的
        Vue.use(VueRouter);
        // 3. 创建路由的实例对象
        const router = new VueRouter({
            routes: [
                {path: '/', redirect: '/home'},
                {path: '/home', component: Home},
                {path: '/movie/:mid', component: Movie, props: true},
                {
                    path: '/about', component: About, redirect: '/about/tab1', children: [
                        {path: 'tab1', component: Tab1},
                        {path: 'tab2', component: Tab2}
                    ]
                }
            ]
        });
        // 3. 为 router 实例对象，声明全局前置导航守卫
        router.beforeEach(function (to, from, next) {
            // to   参数是将要访问的路由的信息对象。
            console.log(to);
            // from 参数是将要离开的路由信息对象。
            console.log(from);
            // next 参数是一个函数，调用 next() 函数表示放行，允许这次路由导航。
            console.log(next);
            // 分析：
            // 1.要拿到用户将要访问的 hash 地址
            // 2.判断 hash 地址是否等于 /main
            // 2.1.如果等于 /main，证明需要登录之后，才能访问
            // 2.2.如果不等于 /main，则不需要登录，直接放行
            // 3.如果访问的地址是 /main，则需要读取 localStorage 中的 token 值
            // 3.1.如果有 token，则放行
            // 3.2.如果没有 token，则强制跳转到 /login 登录页面
            if (to.path === '/main') {
                const token = localStorage.getItem('token');
                if (token) {
                    next();
                } else {
                    next('/login');
                }
            } else {
                next();
            }
        });
    -->

    <!-- 后台管理案例 -->
    <!-- 1. 案例效果 -->

    <!-- 2. 案例用到的知识点 -->
    <!-- 1).命名路由。 -->
    <!-- 2).路由重定向。 -->
    <!-- 3).导航守卫。 -->
    <!-- 4).嵌套路由。 -->
    <!-- 5).动态路由匹配。 -->
    <!-- 6).编程式导航。 -->

    <!-- 1).能够知道如何在 vue 中配置路由 -->
    <!-- createRouter -->
    <!-- app.use(router) -->
    <!-- 2).能够知道如何使用嵌套路由 -->
    <!-- 通过 children 属性进行路由嵌套 -->
    <!-- 3).能够知道如何实现动态路由匹配 -->
    <!-- 使用冒号声明参数项、 -->
    <!-- this.$route.params、 -->
    <!-- props: true -->
    <!-- 4).能够知道如何使用编程式导航 -->
    <!-- this.$router.push、 -->
    <!-- this.$router.go -->
    <!-- 5).能够知道如何使用导航守卫 -->
    <!-- 路由实例.beforeEach((to, from, next) => { /* 必须调 next 函数 */ }) -->

    <!-- 总结： -->
    <!-- 1).学会了如何基于 vue-cli 创建和开发工程化的 Vue 项目。 -->
    <!-- 2).能够熟练运用组件化的开发思想，进行企业级的项目开发。 -->
    <!-- 3).能够熟练使用指令、侦听器、插槽、生命周期、组件通讯等技术，来完成自己的业务开发。 -->
    <!-- 4).能够掌握在 Vue 项目中如何封装和使用 Axios 来请求后端的 API 接口。 -->
    <!-- 5).能够熟练使用 vue-router 实现单页面应用程序的开发。 -->
    <!-- 6).能够在 Vue 项目中使用 Vant 和 Element-UI 组件库。 -->
    <!-- 7).能够熟练运用 vue-devtools 来调试自己的 Vue 项目。 -->
    <!-- 8).更多细节... -->

    <!-- 黑马程序员vue章节： -->
    <!-- 一、webpack 前端工程化章节 -->
    <!-- 二、vue 基础章节 -->
    <!-- 2.1 vue 指令 -->
    <!-- 2.2 vue 调试工具 -->
    <!-- 2.3 过滤器 -->
    <!-- 2.4 侦听器 -->
    <!-- 2.5 计算属性 -->
    <!-- 2.6 vue-cli 脚手架 -->
    <!-- 2.7 vue 组件 -->
    <!-- 2.8 ref 和$refs 对象 -->
    <!-- 三、生命周期章节 -->
    <!-- 四、动态组件章节 -->
    <!-- 五、插槽章节 -->
    <!-- 六、自定义指令章节 -->
    <!-- 七、路由章节 -->

    <!-- 尚硅谷vue章节： -->
    <!-- 搭建vue开发环境 -->
    <!-- 模板语法 -->
    <!-- 数据绑定 -->
    <!-- el与data两种写法 -->
    <!-- 理解MVVM -->
    <!-- Object.DefineProperty -->
    <!-- 数据代理 -->
    <!-- 事件 -->
    <!-- 计算属性 -->
    <!-- 侦听属性 -->
    <!-- 绑定样式 -->
    <!-- 条件渲染 -->
    <!-- 列表渲染 -->
    <!-- 过滤器 -->
    <!-- 常用指令 -->

    <!-- 自定义指令 -->
    <!-- 
    需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。
    需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。
    自定义指令总结：
    一、定义语法：
    (1).局部指令：
        new Vue({
            directives:{指令名:配置对象}
            或者
            directives{指令名:回调函数}
            directives:{
                // 自定义指令：函数式
			    big(element, binding){
			    	console.log('big', this);
			    	element.innerText = binding.value * 10;
			    },
                // 自定义指令：对象式
			    fbind:{
			    	// 指令与元素成功绑定时（一上来）
			    	bind(element, binding) {
			    		element.value = binding.value;
			    	},
			    	// 指令所在元素被插入页面时
			    	inserted(element, binding) {
			    		element.focus();
			    	},
			    	// 指令所在的模板被重新解析时
			    	update(element, binding) {
			    		element.value = binding.value;
			    	}
			    }
			}
        });
    (2).全局指令：
        Vue.directive(指令名, 配置对象);
        或者
        Vue.directive(指令名, 回调函数);
    二、配置对象中常用的3个回调：
        (1).bind     指令与元素成功绑定时调用。
        (2).inserted 指令所在元素被插入页面时调用。
        (3).update   指令所在模板结构被重新解析时调用。
    三、备注：
        (1).指令定义时不加v-，但使用时要加v-；
        (2).指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。
    -->

    <!-- 生命周期 -->
    <!-- 
    // 此阶段：挂载阶段
    (01).Init Events & Lifecycle                初始化：生命周期、事件、但数据代理还未开始。
    (02).beforeCreate()                         此时：无法通过vm访问到data中的数据、methods中的方法。
    (03).Init Injections & Reactivity           初始化：数据检测、数据代理。
    (04).created()                              此时：可以通过vm访问到data中的数据、methods中配置的方法。
    (05).Has "el" option?                       .
    (05).YES & NO                               .
    (05).Has "template" option?                 .
    (05).when vm.$mount(el) is called           .
    (05).YES & NO                               .
    (05).Compile template into render function  .
    (05).Compile el's outerHTML as template     此时：此阶段vue开始解析模板，生成虚拟DOM（内存中），页面不能显示解析好的内容。
    (06).beforeMount()                          此时：页面呈现的未经vue编译的DOM结构。所有对DOM的操作，最终都不奏效。
    (07).Create vm.$el and replace "el" with it 将内存中的虚拟DOM转为真实DOM插入页面。
    (08).mounted()                              此时：页面中呈现的是经过vue编译的DOM。对DOM的操作均有效（尽可能避免）。至此初始化过程结束，一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件、等等初始化操作。
    // 此阶段：更新阶段
    (09).Mounted                                .
    (09).when data changes                      .
    (09).beforeUpdate()                         此时：数据是新的，但页面是旧的，即：页面尚未和数据保持同步。
    (09).Virtual DOM re-render and patch        根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，即：完成Model->View更新。
    (09).updated()                              此时：数据是新的，页面也是新的，即：页面和数据保持同步。
    (10).when vm.$destroy() is called           .
    // 此阶段：销毁阶段
    (11).beforeDestroy()                        此时：vm中所有的：data、methods、指令等等，都处于可用状态，马上就要执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等等收尾操作。
    (12).Teardown watchers,                     .
    (12).child components and event listeners   .
    (13).Destroyed                              .
    (14).destroyed()                            .
    -->

    <!-- 组件 -->
    <!-- 
    Vue中使用组件的三大步骤：
        (1).定义组件（创建组件）。
        (2).注册组件。
        (3).使用组件（写组件标签）。
    如何定义一个组件？
        使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；
        区别如下：
        (1).el   不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。
        (2).data 必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。
        备注：使用template可以配置组件结构。
    如何注册组件？
        (1).局部注册：创建new Vue()实例对象时候传入components选项。
        (2).全局注册：创建Vue.component('组件名', 组件)全局组件。
    编写组件标签：
        <SchoolView></SchoolView>
    -->

    <!-- 
    几个注意点：
    (1).关于组件名:
        一个单词组成：
            第一种写法(首字母小写)：school
            第二种写法(首字母大写)：School
        多个单词组成：
            第一种写法(kebab-case命名)：my-school
            第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)
        备注：
            (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。
            (2).可以使用name配置项指定组件在开发者工具中呈现的名字。
    (2).关于组件标签:
        第一种写法：<school></school>
        第二种写法：<school/>
        备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。
    (3).一个简写方式：
        const school = Vue.extend(options) 可简写为：const school = options
    -->

    <!-- 
    关于VueComponent：
    (1).school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。
    (2).我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。
    (3).特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent。
    (4).关于this指向：
        (1).组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。
        (2).new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。
    (5).【VueComponent的实例对象】，以后【简称vc】（也可称之为：组件实例对象）。
        const vc = Vue.extend({
            data() {
                return {
                    name: 'Hello World'
                }
            }
        });
    (5).【Vue的实例对象】，以后【简称vm】。
        const vm = new Vue({
            data() {
                return {
                    name: 'Hello World'
                }
            }
        });
    总结：【VueComponent】vc和【Vue】vm还是有区别的哈！！！
    -->

    <!-- 
    分析Vue的实例对象vm与VueComponent的实例对象vc的关系：
    (1).一个重要的内置关系：
        VueComponent.prototype.__proto__ === Vue.prototype
    (2).为什么要有这个关系：
        让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法。
    -->
    
    <!-- vue-cli脚手架 -->
    <!-- vue-cli -> Vue - Command Line Interface -->

    <!-- ref属性与props属性 -->
    <!-- 
    ref="myH3"
    ref="myBtn"
    ref="myIpt"
    props:['name', 'age', 'sex']
    props:{
        name: String,
        age: Number
    }
    props:{
        name:{
            type: String,
            required: true,
        },
        age:{
            type: Number,
            default: 18
        },
        sex:{
            type: String,
            required: true
        }
    }
    -->

    <!-- mixin混入 -->
    <!-- 
    import {hunhe1,hunhe2} from '@/mixin.js';
    // 全局混合
    Vue.mixin(hunhe1);
    Vue.mixin(hunhe2);
    // 配置文件混入mixin.js
    export const hunhe1 = {
        methods: {
            showName() {
                alert(this.name);
            }
        },
        mounted() {
            console.log('你好啊！');
        },
    }
    export const hunhe2 = {
        data() {
            return {
                x:100,
                y:200
            }
        },
    }
    -->

    <!-- 插件 -->
    <!-- 
    import plugins from '@/plugins.js';
    // 配置文件使用插件plugins.js
    Vue.use(plugins);
    // plugins.js
    export default {
        install(Vue) {
            Vue.filter('mySlice', function(value) {
                return value.slice(0, 4);
            });
            Vue.directive('fbind', {
                bind(element,binding) {
                    element.value = binding.value
                },
                inserted(element,binding){
                    element.focus()
                },
                update(element,binding){
                    element.value = binding.value
                }
            });
            Vue.mixin({
                data() {
                    return {
                        x:100,
                        y:200
                    }
                },
            });
        }
    }
    -->

    <!-- 组件案例： -->
    <!-- 
    添加：
    (01).先从App.vue组件传递给MyHeader.vue组件通过绑定属性v-bind。
    <MyList v-bind:list="array"></MyList>
    export default {
        data() {
            return {
                array: [
                    {id: '10086', name: '中国移动', state: true},
                    {id: '10010', name: '中国联通', state: false},
                    {id: '10000', name: '中国电信', state: true},
                ]
            }
        },
        methods: {
            // (04).添加obj到array中。【props适用于】子组件===>父组件通信（要求父组件先给子组件一个函数）
            array(obj) {
                this.array.unshift(obj);
            }
        }
    }
    (02).然后MyHeader.vue组件接收App.vue传递过来的属性。
    <input type="text" placeholder="请输入搜索关键字" @keyup.enter="addObj($event)"></input>
    export default {
        【props适用于】父组件===>子组件通信
        props: {
            'list'
        },
        methods: {
            // (03).添加obj到list中。【props适用于】子组件===>父组件通信（要求父组件先给子组件一个函数）
            addObj(event) {
                const obj = {id: '12306', title: '中国铁路', state: false};
                this.list(obj);
            }
        }
    }
    勾选：
    (01).先从App.vue父级组件传递给MyList.vue子级组件通过绑定属性v-bind。
    <MyList v-bind:list="array" v-bind:check="checked"/>
    export default {
        data() {
            return {
                array: [
                    {id: '10086', name: '中国移动', state: true},
                    {id: '10010', name: '中国联通', state: false},
                    {id: '10000', name: '中国电信', state: true},
                ]
            }
        },
        methods: {
            // (04).添加obj到array中。
            array(obj) {
                this.array.unshift(obj);
            },
            // (04).添加到checked中。【props适用于】子组件===>父组件通信（要求父组件先给子组件一个函数）
            checked(id) {
				this.array.forEach((t) => {
					if(t.id === id) t.state = !t.state;
				})
			},
        }
    }
    (02).然后MyList.vue子级组件接收App.vue父级组件传递过来的属性。
    <MyItem v-for="item in list" :key="item.id" v-bind:check="check"/>
    export default {
        【props适用于】父组件===>子组件通信
        props: {
            'list',
            'check'
        }
    }
    (02).然后MyItem.vue孙级组件接收MyList.vue子级组件传递过来的属性。
    <input type="checkbox" v-bind:checked="list.state" @change="set(list.id)"/>
    export default {
        【props适用于】父组件===>子组件通信
        props: {
            'list',
            'check'
        },
        check: {
            // (03).添加到check中。【props适用于】子组件===>父组件通信（要求父组件先给子组件一个函数）
			  set(id) {
			    this.check(id);
			  },
		  },
    }
    -->

    <!-- 本地存储：SessionStorage与LocalStorage -->
    <!-- 
    sessionStorage.setItem('token', JSON.stringify(token));
    const result = sessionStorage.getItem('token');
    console.log(JSON.parse(result));
    sessionStorage.removeItem('token');
    sessionStorage.clear();
    -- 
    localStorage.setItem('token', JSON.stringify(token));
    const result = localStorage.getItem('token');
    console.log(JSON.parse(result));
    localStorage.removeItem('token');
    localStorage.clear();
    -->

    <!-- 组件自定义事件 -->
    <!-- 
    // 子级组件
    this.$emit('share', value);
    // 父级组件
    <ChildView v-on:share="getShare">
    export default {
        methods: {
            // 回调函数
            getShare(val) {
                console.log(val);
            }
        }
    }
    注意：解绑自定义事件。
    this.$off();
    -->

    <!-- 全局事件总线 -->
    <!-- 
    // 全局事件总线，任意组件间通信
    (1).一种组件间通信的方式，适用于任意组件间通信。
    (2).安装全局事件总结；
    new Vue({
        beforeCreate() {
            // 安装全局事件总线，$bus就是当前应用的vm
            Vue.prototype.$bus = this
        }
    });
    (3).使用事件总线；
        (1).接收数据，A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。
        (2).提供数据：this.$bus.$emit('share', data)。
    (4).最好在beforeDestroy()钩子中，使用$off去解绑当前组件中所用到的事件。
    -->

    <!-- $nextTick -->
    <!-- 
    (1).语法：this.$nextTick(callback)
    (2).作用：在下一次DOM更新结束后，执行其指定的回调函数。
    (3).场景：当改变数据后，要基于更新后的新DOM进行某些操作时，要在$nextTick()所指定的回调函数中执行。
    handleEdit(todo) {
        if(todo.hasOwnProperty('isEdit')) {
            todo.isEdit = true;
        }else {
            this.$set(todo, 'isEdit', true);
        }
        this.$nextTick(function() {
            this.$refs.inputTitle.focus();
        });
    }
    -->

    <!-- 动画 -->
    <!-- 
    Vue封装的过渡与动画。
    (1).作用：在插入、更新或者移除DOM元素时，在合适的时候给元素添加样式类名。
    (2).图示：
    (3).写法一：
        (1).准备好样式；
        (2).使用<transition></transition>双标签包裹过渡的元素，并且配置name属性；
        (3).备注：若有多个元素需要过渡，则需要使用<transition-group></transition-group>双标签包裹，并且每个元素都需要指定key值。
        .hello-enter-active {
          animation: atguigu 0.5s linear;
        }
        .hello-leave-active {
          animation: atguigu 0.5s linear reverse;
        }
        @keyframes atguigu {
          from {
            transform: translateX(-100%);
          }
          to {
            transform: translateX(0px);
          }
        }
    -->

    <!-- 过渡 -->
    <!-- 
    Vue封装的过渡与动画。
    (1).作用：在插入、更新或者移除DOM元素时，在合适的时候给元素添加样式类名。
    (2).图示：
    (3).写法一：
        (1).准备好样式；
        (2).使用<transition></transition>双标签包裹过渡的元素，并且配置name属性；
        (3).备注：若有多个元素需要过渡，则需要使用<transition-group></transition-group>双标签包裹，并且每个元素都需要指定key值。
    <transition name="hello" appear>
        <h1 v-show="isShow">你好啊！！！</h1>
    </transition>
    <transition-group name="hello" appear>
        <h1 v-show="!isShow" key="1">你好啊！！！</h1>
        <h1 v-show="isShow"  key="2">好不好！！！</h1>
    </transition-group>
    <transition-group name="todo" appear>
        <MyItem v-for="todoObj in todos" :key="todoObj.id" :todo="todoObj" />
    </transition-group>
    -->

    <!-- 配置代理 -->
    <!-- 
    (1).xhr           new XMLHttpRequest();
    (2).jQuery        $.ajax();
    (3).axios         .get();
    (4).fetch         .
    (5).vue-resource  插件库。
    # npm install axios
    const url = 'http://localhost:8080/api/list'
    axios.get(url).then(
        response => {
            console.log(response.data);
        },
        error => {
            console.log(error.message);
        }
    );
    报错：
    Access to XMLHttpRequest at '' from origin '' has been blocked by CORS policy: 'Acess-Control-Allow-Origin'
    解决方式一：
    (1).vue.config.js
    (2).开启配置代理服务器
    module.exports = {
        devServer: {
            proxy: 'http://localhost:8080'
        }
    }
    解决方式二：
    (1).vue.config.js
    (2).开启配置代理服务器
    module.exports {
        devServer: {
            proxy: {
                '/api': {
                    target: '<url>',
                    ws: true,
                    changeOrigin: true
                },
                '/foo': {
                    target: '<other_url>'
                }
            }
        }
    }
    -->

    <!-- vue-resource 插件库 -->
    <!-- 
    (0).安装第三方模块
    # npm install vue-resource
    (1).引入插件
    import vueResource from 'vue-resource';
    (2).使用插件
    Vue.use(vueResource);
    export default {
      name:'SearchView',
      data() {
        return {
          keyWord: ''
        }
      },
      methods: {
        search() {
          this.$http.get(`https://api.github.com/search/users?q=${this.keyWord}`).then(
            response => {
              console.log(response.data);
              this.$bus.$emit('share', response.data);
            },
            error => {
              this.$bus.$emit('share', 500);
            }
          )
        }
      },
	  }
    -->

    <!-- 插槽Slot -->
    <!-- 
    <Category title="游戏">
      <template scope="list">
        <ul>
          <li v-for="(g, index) in list.games" :key="index">{{g}}</li>
        </ul>
      </template>
    </Category>
    <Category title="游戏">
      <template scope="{games}">
        <ol>
          <li style="color:red" v-for="(g, index) in games" :key="index">{{g}}</li>
        </ol>
      </template>
    </Category>
    <Category title="游戏">
      <template slot-scope="{games}">
        <h4 v-for="(g,index) in games" :key="index">{{g}}</h4>
      </template>
    </Category>
    <div class="category">
      <h3>{{title}}分类</h3>
      <slot :games="games" msg="hello">我是默认的一些内容</slot>
    </div>
    -->

    <!-- Vuex -->
    

    <!-- 路由 -->

    <!-- element-ui -->




    <script src="./libs/vue-2.6.12.js"></script>
</body>

</html>