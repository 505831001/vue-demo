<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeJS基础：简介</title>
    <!-- CSS files -->
    <link rel="icon" href="https://v3.bootcss.com/favicon.ico">
    <link rel="stylesheet" href="./bootstrap-3.4.1-dist/css/bootstrap.min.css">
    <!-- JavaScript Files -->
    <script type="text/javascript" src="./js/jquery-3.6.4.js"></script>
    <script type="text/javascript" src="./js/jquery.validate.js"></script>
</head>

<body>
    <!-- JS 部分 -->

    <!-- JS 作用 -->
    <!-- 网页特效(监听用户的一些行为让网页作出对应的反馈) -->
    <!-- 表单验证(针对表单数据的合法性进行判断) -->
    <!-- 数据交互(获取后台的数据渲染到前端) -->
    <!-- 服务端编程(node.js) -->
    <!-- JS 组成 -->
    <!-- ECMAScript: 规定了js基础语法核心知识。比如：变量、分支语句、循环语句、对象等等。 -->
    <!-- Web APIs DOM: 操作文档。比如对页面元素进行移动、大小、添加删除等操作。 -->
    <!-- Web APIs BOM: 操作浏览器。比如页面弹窗，检测窗口宽度、存储数据到浏览器等等。 -->
    <!-- JS 用法 -->
    <!-- 使用 内联的 JavaScript 函数。 -->
    <!-- 使用 <head>或者<body>中的 JavaScript 函数。 -->
    <!-- 使用 外部的 JavaScript 函数。 -->
    <!-- JS 注释 -->
    <!-- 使用 //    开头的单行注释。快捷键：Ctrl + /。 -->
    <!-- 使用 /* */ 包裹的多行注释。快捷键：Shift + Ctrl + A。 -->
    <!-- JS 结束符 -->
    <!-- 使用 分号（;）为结束符。换行为默认结束符。 -->
    <!-- JS 字面量 -->
    <!-- 使用 3.14 为数字字面量。 -->
    <!-- 使用 双引号"白马王子" 单引号'黑马攻城狮' 为字符串字面量。 -->
    <!-- 使用 大括号对象 {} 中括号数组 [] 尖括号标签<> 等等字面量。 -->
    <!-- JS 输入/输出 -->
    <!-- 使用 window.prompt()   方法显示可提示用户输入的对话框。 -->
    <!-- 使用 element.innerHTML 属性写入到 HTML 元素。 -->
    <!-- 使用 window.alert()    方法弹出警告框。 -->
    <!-- 使用 document.write()  方法将内容写到 HTML 文档中。 -->
    <!-- 使用 console.log()     方法写入到浏览器的控制台。 -->
    <!-- JS 变量 -->
    <!-- 使用 var   关键字声明的变量。在函数外声明作用域是全局变量，在函数内声明作用域是局部变量。变量必须以字母开头，变量也能以（$）和（_）符号开头，变量名称对大小写敏感。 -->
    <!-- 使用 let   关键字定义的限定范围内作用域的变量。只在 let 命令所在的代码块内有效。 -->
    <!-- 使用 const 关键字来定义一个常量。一旦声明，常量的值就不能改变。 -->
    <!-- JS 数据类型 -->
    <!-- 使用 number    基础数据类型赋值的是数字类型。JS 中的正数、负数、小数等等统一称为数字类型。 -->
    <!-- 使用 string    基础数据类型赋值的是字符串类型。通过单引号（''）、双引号（""）或反引号（``）包裹的数据都叫字符串类型。 -->
    <!-- 使用 boolean   基础数据类型赋值的是布尔类型。布尔（逻辑）类型只能有两个值真（true）或假（false）。 -->
    <!-- 使用 undefined 基础数据类型返回值的是未定义类型。只声明变量，不赋值的情况下，变量的默认值为 undefined 这个值表示变量不含有值。 -->
    <!-- 使用 null      基础数据类型返回值的是空值类型。可以通过将变量的值设置为 null 来清空变量。 -->
    <!-- 使用 object    引用数据类型返回的值是对象。对象由花括号（{}）分隔，对象属性以名称和值对的形式（Key:Value）来定义，属性之间由逗号（,）分隔。 -->
    <!-- 使用 array     引用数据类型返回的值是数组。数组由中括号（[]）分隔，每个值之间由逗号（,）分隔。返回也是对象：object。 -->
    <!-- 使用 function  引用数据类型返回的值是函数。函数就是包裹在花括号中的代码块，前面使用了关键词 function。 -->
    <!-- JS 运算符 -->
    <!-- 使用 + - * / %            符号来表示数学运算符（算术运算符），主要包括加、减、乘、除、取余（求模）。 -->
    <!-- 使用 = += -= *= /= %=     符号来表示赋值运算符，对变量进行赋值的运算符。 -->
    <!-- 使用 > < >= <= == === !== 符号来表示比较运算符，比较两个数据大小、是否相等。 -->
    <!-- 使用 i++ ++i i-- --i      符号来表示一元运算符，能够使用一元运算符做自增（自减）运算。 -->
    <!-- 使用 && ||                符号来表示逻辑运算符，逻辑运算符用来解决多重条件判断。 -->
    <!-- JS 分支/循环 -->
    <!-- 使用 if (condition) { }                                   语句只有当指定条件为 true 时，使用该语句来执行代码。 -->
    <!-- 使用 if (condition) { } else { }                          语句当条件为 true 时执行代码，当条件为 false 时执行其他代码。 -->
    <!-- 使用 if (condition) { } else if (condition) else {}       语句使用该语句来选择多个代码块之一来执行。 -->
    <!-- 使用 switch (key) {case value: break; default: break;}    语句用于基于不同的条件来执行不同的动作。 -->
    <!-- 使用 while (condition) { }                                语句只要指定条件为 true，循环就可以一直执行代码块。 -->
    <!-- 使用 do { } while (condition);                            语句循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。 -->
    <!-- 使用 for (let i = 0; i < array.length; i++) { array[i]; } 语句循环代码块一定的次数。 -->
    <!-- 使用 array.forEach(element => { });                       语句循环代码块一定的次数。 -->
    <!-- 使用 for (const key in object) { object[key]; }           语句循环遍历对象的属性。 -->
    <!-- 使用 for (const iterator of object) { }                   语句循环遍历对象的属性。 -->
    <!-- JS 数组 -->
    <!-- 使用 array = new Array();                                 语句创建数组，基于 new 关键字。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- 使用 array = [];                                          语句创建数组，基于中括号 []。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- JS 操作符 -->
    <!-- 使用 typeof                                               操作符来检测变量的数据类型。 -->
    <!-- 使用 typeof                                               操作符来检测 null 是一个只有一个值的特殊类型。表示一个空对象引用。会返回 object。 -->
    <!-- 使用 typeof                                               操作检测一个没有设置值的变量。会返回 undefined。 -->
    <!-- JS 类型转换 -->
    <!-- 隐式转换：某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 -->
    <!-- 显式转换：为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 -->
    <!-- 使用 Number(x)                                            方法将字符串转换成数字类型。 -->
    <!-- 使用 parseInt(x)                                          方法将字符串转换成数字类型。 -->
    <!-- 使用 parseFloat(x)                                        方法将字符串转换成数字类型。 -->
    <!-- 使用 String(x)                                            方法将其他类型转换成字符串类型。 -->
    <!-- 使用 x.toString()                                         方法将其他类型转换成字符串类型。 -->
    <!-- JS 正则表达式 -->
    <!-- 语法 /正则表达式主体/修饰符(可选)                           正则表达式（Regular Expression）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 -->
    <!-- 使用 s.search(/RegExp/i)                                  正则表达式搜索 RegExp 字符串，且不区分大小写。 -->
    <!-- 使用 s.replace(/RegExp/i, "RegularExpression")            正则表达式且不区分大小写将字符串中的 RegExp 替换为 RegularExpression。 -->
    <!-- 使用 i                                                    修饰符执行对大小写不敏感的匹配。 -->
    <!-- 使用 g                                                    修饰符执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 -->
    <!-- 使用 m                                                    修饰符执行多行匹配。 -->
    <!-- 使用 [abc]                                                表达式查找方括号之间的任何字符。 -->
    <!-- 使用 [0-9]                                                表达式查找任何从 0 至 9 的数字。 -->
    <!-- 使用 (x|y)                                                表达式查找任何以 | 分隔的选项。 -->
    <!-- 使用 \d                                                   元字符查找数字。 -->
    <!-- 使用 \s                                                   元字符查找空白字符。 -->
    <!-- 使用 \b                                                   元字符匹配单词边界。 -->
    <!-- 使用 \uxxxx                                               元字符查找以十六进制数 xxxx 规定的 Unicode 字符。 -->
    <!-- 使用 n+                                                   量词匹配任何包含至少一个 n 的字符串。 -->
    <!-- 使用 n*                                                   量词匹配任何包含零个或多个 n 的字符串。 -->
    <!-- 使用 n?                                                   量词匹配任何包含零个或一个 n 的字符串。 -->
    <!-- 使用 RegExp                                               对象是一个预定义了属性和方法的正则表达式对象。 -->
    <!-- 使用 test()                                               方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 -->
    <!-- 使用 exec()                                               方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 -->
    <!-- JS 异常 -->
    <!-- 使用 try                                                  语句允许我们定义在执行时进行错误测试的代码块。 -->
    <!-- 使用 catch                                                语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 -->
    <!-- 使用 finally                                              语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 -->
    <!-- 使用 throw                                                语句创建自定义错误。或者叫做创建或者抛出异常（Exception）。 -->
    <!-- JS 关键字 -->
    <!-- 使用 break                                                关键字 -->
    <!-- 使用 continue                                             关键字 -->
    <!-- 使用 return                                               关键字 -->
    <!-- 使用 typeof                                               关键字 -->
    <!-- 使用 this                                                 关键字 -->
    <!-- 使用 var                                                  关键字 -->
    <!-- 使用 let                                                  关键字 -->
    <!-- 使用 const                                                关键字 -->
    <!-- 使用 void                                                 关键字 -->
    <!-- JS 异步编程 -->
    <!-- 同步 sync                                                 相对的概念。 -->
    <!-- 异步 async                                                相对的概念。 -->
    <!-- 使用 Promise                                              对象是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 -->
    <!-- 使用 new Promise(function(resolve, reject){setTimeout(function(){}, 1000);})     异步函数是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。 -->
    <!-- JS 函数 -->
    <!-- 使用 function functionname(parameters) { return parameters; }                    声明函数。函数声明后不会立即执行，会在我们需要的时候调用到。 -->
    <!-- 使用 x = function (a, b) { return a * b; };                                      匿名函数（函数表达式）。函数存储在变量中，不需要函数名称，通常通过变量名来调用。 -->
    <!-- 使用 new Function("a", "b", "return a * b");                                     构造函数。函数同样可以通过内置的 JavaScript 函数构造器 Function() 定义。 -->
    <!-- 使用 (function () { var x = "callback"; })();                                    自调用函数（立即执行函数）。函数表达式可以"自调用"，自调用表达式会自动调用。如果表达式后面紧跟 () 则会自动调用。不能自调用声明的函数。 -->
    <!-- 使用 (function () { var x = "callback"; }());                                    自调用函数（立即执行函数）。函数实际上是一个匿名自我调用的函数（没有函数名）。 -->
    <!-- 使用 (parameters) => { return x * y; }                                           箭头函数。ES6 新增了箭头函数。箭头函数表达式的语法比普通函数表达式更简洁。 -->
    <!-- 使用 function callback() { return a * b; } window.setInterval(callback(), 1000); 回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- 使用 window.addEventListener('click', function () { return a * b; });            回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- JS 闭包 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       x 变量可以作为一个函数使用。它 function () {return i += 1;} 可以访问函数上一层作用域的计数器。这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 -->
    <!-- JS 类 -->
    <!-- 使用 class Parent { property: "value", method: function () { } }                 使用 class 关键字来创建一个类，类是用于创建对象的模板。类体在一对大括号 {} 中，在大括号 {} 中定义类成员的位置，如方法或构造函数。每个类中包含了一个特殊的方法 constructor()，它是类的构造函数。这种方法用于创建和初始化一个由 class 创建的对象。 -->
    <!-- 使用 new Parent()                                                                使用 new 关键字来创建对象。创建对象时会自动调用构造函数方法 constructor()。 -->
    <!-- 使用 class Children extends Parent { }                                           使用 extends 关键字继承类。这个已有的类称为基类（父类），新建的类称为派生类（子类）。 -->
    <!-- 使用 static method() { }                                                         使用 static 关键字修改的方法是静态方法，又叫类方法，属于类的，但不属于对象。通过（类名.方法名）调用静态方法。静态方法不能在对象上调用，只能在类中调用。 -->
    <!-- JS 对象 -->
    <!-- 使用 Console 对象提供了浏览器控制台调试的接口。在不同浏览器上它的工作方式可能不一样，但通常都会提供一套共性的功能。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- DOM 部分 -->

    <!-- DOM 获取元素 -->
    <!-- 通过 document.getElementById()         方法通过 ID 找到 HTML 元素。 -->
    <!-- 通过 document.getElementsByTagName()   方法通过 标签名 找到 HTML 元素。 -->
    <!-- 通过 document.getElementsByClassName() 方法通过 类名 找到 HTML 元素。 -->
    <!-- 通过 document.querySelector()          方法返回文档中与指定的选择器匹配的第一个元素 Element 节点。 -->
    <!-- 通过 document.querySelectorAll()       方法返回包含文档中与指定的选择器匹配的所有元素 NodeList 节点的列表。 -->
    <!-- DOM 修改元素内容 -->
    <!-- 通过 document.write()                  方法可向文档写入文本内容，可以是 HTML 代码。 -->
    <!-- 通过 element.innerText                 属性设置或者返回元素的内容。 -->
    <!-- 通过 element.innerHTML                 属性设置或获取 HTML 语法表示的元素的后代。 -->
    <!-- DOM 修改元素属性 -->
    <!-- 通过 element.href                      属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.title                     属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.src                       属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.className                 属性设置或者返回元素新赋值属性。 -->
    <!-- 通过 element.disabled                  属性规定应该启用或者禁用的 input 元素。 -->
    <!-- 通过 element.checked                   属性规定在页面加载时应该被预先选定的 input 元素。只针对 type="checkbox" 或者 type="radio"。 -->
    <!-- 通过 element.selected                  属性规定选项（在首次显示在列表中时）表现为选中状态。 -->
    <!-- DOM 修改元素样式 -->
    <!-- 通过 element.style.styleProperties     属性设置或者返回元素的样式属性。 -->
    <!-- DOM 定时器 -->
    <!-- 通过 window.setInterval(function, timeout)        方法按照指定的周期（毫秒）来无限循环调用，调用函数或计算表达式。 -->
    <!-- 通过 window.clearInterval(timer)                  方法取消由定时器设置的定时任务。 -->
    <!-- 通过 window.setTimeout(function, timeout)         方法在指定的毫秒数后仅此调用一次，调用函数或计算表达式。 -->
    <!-- 通过 window.clearTimeout(timer)                   方法取消由定时器设置的定时任务。 -->
    <!-- DOM 事件 -->
    <!-- 使用 window.onclick = function() { }                                      传统on注册事件（L0）。同一个对象，后面注册的事件会覆盖前面注册（同一个事件）。 -->
    <!-- 使用 window.addEventListener('event',  function () {})                    事件监听注册事件（L2）。后面注册的事件不会覆盖前面注册的事件（同一个事件）。 -->
    <!-- 使用 window.addEventListener('load',   function () {})                    事件监听注册事件（L2）。加载事件。加载外部资源（如图片、CSS和JavaScript等）加载完毕时触发的事件。 -->
    <!-- 使用 window.addEventListener('scroll', function () {})                    事件监听注册事件（L2）。滚动事件。页面进行滚动的时候触发的事件。监听某个元素的内部滚动直接给某个元素加即可。 -->
    <!-- DOM 事件流 -->
    <!-- 使用 window.addEventListener('event', function() {}, function callback()) 此方法若传入 false 代表冒泡阶段触发，默认就是 false。第三个参数传入 true 代表是捕获阶段触发（很少使用）。 -->
    <!-- 使用 window.stopPropagation()                                             此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有。当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段。 -->
    <!-- DOM 事件委托 -->
    <!-- 使用 window.target(Event.target)                                          此方法可以获得真正触发事件的元素。事件委托其实是利用事件冒泡的特点，给父元素添加事件，子元素（target）可以触发。 -->
    <!-- DOM 函数 -->
    <!-- 使用 function functionname(parameters) { return parameters; }             声明函数。 -->
    <!-- 使用 function (a, b) {return a * b};                                      匿名函数。 -->
    <!-- 使用 new Function("a", "b", "return a * b");                              构造函数。 -->
    <!-- 使用 (function () { var x = "callback"; })();                             自调用函数（立即执行函数）。 -->
    <!-- 使用 (function () { var x = "callback"; }());                             自调用函数（立即执行函数）。 -->
    <!-- 使用 (parameters) => { return x * y; }                                    箭头函数。 -->
    <!-- 使用 function callback() { return '回调函数'; } window.setInterval(callback(), 1000) 回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- 使用 window.addEventListener('click', function () { return '回调函数'; })            回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- DOM 节点操作 -->
    <!-- 使用 element.parentNode                    属性父节点查找。返回最近一级的父节点找不到返回为 null。 -->
    <!-- 使用 element.childNodes                    属性获得所有子节点，包括文本节点（空格、换行）注释节点等。 -->
    <!-- 使用 element.children                      属性仅获得所有元素节点。返回的还是一个伪数组。 -->
    <!-- 使用 element.nextElementSibling            属性查找下一个兄弟节点。 -->
    <!-- 使用 element.previousElementSibling        属性查找上一个兄弟节点。 -->
    <!-- 使用 document.createElement('elementName') 属性新建一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点。 -->
    <!-- 使用 element.appendChild('elementName')    属性要想在界面看到，还得插入到某个父元素中。插入到父元素的最后一个子元素。 -->
    <!-- 使用 element.cloneNode(boolean)            属性会克隆出一个跟原标签一样的元素，括号内传入布尔值。若为true，则代表克隆时会包含后代节点一起克隆，若为false，则代表克隆时不包含后代节点，默认false。 -->
    <!-- 使用 element.removeChild('elementName')    属性如不存在父子关系则删除不成功。 -->
    <!-- DOM 节点滚动 -->
    <!-- 使用 Element.scrollWidth                   返回类型为：Number，表示元素的滚动视图宽度。 -->
    <!-- 使用 Element.scrollHeight                  返回类型为：Number，表示元素的滚动视图高度。 -->
    <!-- 使用 Element.scrollLeft                    检测元素的内容左右和上下滚动的距离（被卷去的左侧scrollLeft），返回值不带单位。 -->
    <!-- 使用 Element.scrollTop                     检测元素的内容左右和上下滚动的距离（被卷去的头部scrollTop），返回值不带单位。 -->
    <!-- DOM 节点位置 -->
    <!-- 使用 element.offsetWidth                   返回元素的宽度，包括边框（border）和内边距（padding），但不包含外边距（margin）。 -->
    <!-- 使用 element.offsetHeight                  返回任何一个元素的高度包括边框（border）和内边距（padding），但不包含外边距（margin）。 -->
    <!-- 使用 element.offsetLeft                    检测元素相对于父级元素的左右偏移量位置，返回值不带单位。 -->
    <!-- 使用 element.offsetTop                     检测元素相对于父级元素的上下偏移量位置，返回值不带单位。 -->
    <!-- DOM 节点大小 -->
    <!-- 使用 Element.clientWidth                   检测元素的内容宽度（可见的区域大小（不包含滚动条和不包含超出的部分）），返回值不带单位。 -->
    <!-- 使用 Element.clientHeight                  检测元素的内容高度（可见的区域大小（不包含滚动条和不包含超出的部分）），返回值不带单位。 -->
    <!-- 使用 Element.clientLeft                    只读，返回 Number 表示该元素距离它左边界的宽度。 -->
    <!-- 使用 Element.clientTop                     只读，返回 Number 表示该元素距离它上边界的高度。 -->
    <!-- DOM 事件对象 -->
    <!-- 使用 o.addEventListener('event', function () {}) 事件监听对象。 -->
    <!-- 使用 MouseEvent.clientX                    鼠标指针在点击元素（DOM）中的 X 坐标。 -->
    <!-- 使用 MouseEvent.clientY                    鼠标指针在点击元素（DOM）中的 Y 坐标。 -->
    <!-- 使用 MouseEvent.offsetX                    鼠标指针相对于目标节点内边位置的 X 坐标。 -->
    <!-- 使用 MouseEvent.offsetY                    鼠标指针相对于目标节点内边位置的 Y 坐标。 -->
    <!-- 使用 MouseEvent.pageX                      鼠标指针相对于整个文档的 X 坐标。 -->
    <!-- 使用 MouseEvent.pageY                      鼠标指针相对于整个文档的 Y 坐标。 -->
    <!-- 使用 MouseEvent.screenX                    鼠标指针相对于全局（屏幕）的 X 坐标。 -->
    <!-- 使用 MouseEvent.screenY                    鼠标指针相对于全局（屏幕）的 Y 坐标。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- JQ 部分 -->

    <!-- 核心：$(function(){});                    页面加载事件。类似于window.load()页面加载事件。先ready()方法。 -->
    <!-- 函数：$(document).ready(function(){});    页面加载事件。类似于window.load()页面加载事件。先ready()方法。 -->
    <!-- 扩展：$(window).on('load', function(){}); 页面加载事件。类似于window.load()页面加载事件。后load()方法。 -->
    <!-- 原生：window.load(function(){});          页面加载事件。类似于window.load()页面加载事件。后load()方法。 -->
    <!-- 赋值：$("选择器").html('内容'); -->
    <!-- 赋值：$("选择器").text('内容'); -->
    <!-- 取值：$("选择器").html(); -->
    <!-- 取值：$("选择器").text(); -->
    <!-- 赋值：$("选择器").val('内容'); -->
    <!-- 取值：$("选择器").val(); -->
    <!-- 赋值：$("选择器").attr('属性名', '值'); -->
    <!-- 取值：$("选择器").attr('属性名'); -->
    <!-- 赋值：$("选择器").prop("checked", true);  设值（真True或者假False）。input标签checked属性是一个布尔属性。 -->
    <!-- 赋值：$("选择器").prop("disabled", true); 设值（真True或者假False）。button标签disabled属性是一个布尔属性。 -->
    <!-- 赋值：$("选择器").prop("selected", true); 设值（真True或者假False）。option元素selected属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("checked");        取值（真True或者假False）。input标签checked属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("disabled");       取值（真True或者假False）。button标签disabled属性是一个布尔属性。 -->
    <!-- 取值：$("选择器").prop("selected");       取值（真True或者假False）。option元素selected属性是一个布尔属性。 -->
    <!-- 删除：$("选择器").removeAttr('属性名'); -->
    <!-- 查找：$("选择器").eq(n);              获取第N个元素。 -->
    <!-- 查找：$("选择器").parent();           查询父级元素。 -->
    <!-- 查找：$("选择器").children();         查找子级元素。 -->
    <!-- 查找：$("选择器").siblings();         查找兄弟元素。 -->
    <!-- 查找：$("选择器").find();             查找后代元素。 -->
    <!-- 新增：$("选择器").append("element");  向每个匹配的元素内部追加内容。 -->
    <!-- 新增：$("选择器").prepend("element"); 向每个匹配的元素内部前置内容。 -->
    <!-- 删除：$("选择器").remove("element");  从DOM中删除所有匹配的元素。 -->
    <!-- 删除：$("选择器").empty();            所有删除匹配的元素集合中所有的子节点。 -->
    <!-- 样式：$("选择器").innerWidth();       获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。 -->
    <!-- 样式：$("选择器").innerHeight();      获取第一个匹配元素内部区域高度（包括补白、不包括边框）。 -->
    <!-- 样式：$("选择器").outerWidth();       获取第一个匹配元素外部宽度（默认包括补白和边框）。 -->
    <!-- 样式：$("选择器").outerHeight();      获取第一个匹配元素外部高度（默认包括补白和边框）。 -->
    <!-- 样式：$("选择器").css();              添加单个样式属性。 -->
    <!-- 样式：$("选择器").css({});            添加多个样式属性数组。 -->
    <!-- 样式：$("选择器").addClass();         添加已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").hasClass();         查找已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").removeClass();      删除已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").toggleClass();      有则删除，无则添加已经定义在Style中的样式。 -->
    <!-- 样式：$("选择器").offset();           获取匹配元素在当前视口的相对偏移。 -->
    <!-- 样式：$("选择器").position();         获取匹配元素相对父元素的偏移。 -->
    <!-- 样式：$("选择器").scrollTop();        获取匹配元素相对滚动条顶部的偏移。 -->
    <!-- 样式：$("选择器").scrollLeft();       获取匹配元素相对滚动条左侧的偏移。 -->
    <!-- 样式：$("选择器").show(1000);         显示隐藏的匹配元素。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").hide(1000);         隐藏显示的元素。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").toggle(1000);       用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的click事件。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeIn(1000);       通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeOut(1000);      通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").fadeToggle(1000);   通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。修改样式opacity透明度属性。最后display:none; -->
    <!-- 样式：$("选择器").slideDown(1000);    通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数。 -->
    <!-- 样式：$("选择器").slideUp(1000);      通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数。 -->
    <!-- 样式：$("选择器").slideToggle(1000);  通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数。 -->
    <!-- 动画：$("选择器").基础动画方法(回调函数); -->
    <!-- 动画：$("选择器").基础动画方法(持续时间, 回调函数); -->
    <!-- 动画：$("选择器").animate(params,speed,easing,function); 用于创建自定义动画的函数。 -->
    <!-- 动画：$("选择器").stop();                                停止所有在指定元素上正在运行的动画。 -->
    <!-- 动画：$("选择器").delay(duration,queueName);             设置一个延时来推迟执行队列中之后的项目。 -->
    <!-- 事件：$("选择器").click();                     点击事件。 -->
    <!-- 事件：$("选择器").mouseenter();                鼠标移入事件。 -->
    <!-- 事件：$("选择器").mouseleave();                鼠标移出事件。 -->
    <!-- 事件：$("选择器").focus();                     获取鼠标焦点事件。 -->
    <!-- 事件：$("选择器").blur();                      失去鼠标焦点事件。 -->
    <!-- 事件：$("选择器").on('click', function(){});   事件委托。减少事件注册。解决动态增加后代元素的事件绑定问题。原理是事件冒泡。 -->
    <!-- 事件：$("选择器").off('click', function(){});  移除事件。减少事件注册。解决动态增加后代元素的事件绑定问题。原理是事件冒泡。 -->
    <!-- 事件：$("选择器").off();                       移除所有事件。 -->
    <!-- 事件：$("选择器").one('click', function(){});  注册一次性事件。 -->
    <!-- 事件：$("选择器").bind("click", function(){}); 为每个匹配元素的特定事件绑定事件处理函数。 -->
    <!-- 事件：$("input").trigger("click"); -->
    <!-- 事件：$("input").triggerHandler("click"); -->
    <!-- 事件：$("p").unbind("click"); -->
    <!-- 事件：$("p").unbind(); -->
    <!-- 事件：$(window).scroll(function(){}); -->
    <!-- 事件：event.preventDefault();  阻止默认事件行为的触发。 -->
    <!-- 事件：event.stopPropagation(); 防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数。 -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- AJAX 部分 -->

    <!-- 一、客户端与服务器 -->
    <!-- 1.1 上网的目的 -->
    <!-- 上网的本质目的：通过互联网的形式来获取和消费资源。 -->
    <!-- 1.2 服务器 -->
    <!-- 上网过程中，负责存放和对外提供资源的电脑，叫做服务器。 -->
    <!-- 1.3 客户端 -->
    <!-- 上网过程中，负责获取和消费资源的电脑，叫做客户端。 -->

    <!-- 二、URL地址 -->
    <!-- 2.1 URL概述 -->
    <!-- URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。 -->
    <!-- 常见的URL举例： -->
    <!-- http://www.baidu.com/ -->
    <!-- http://www.taobao.com/ -->
    <!-- http://www.cnblogs.com/liulongbinblogs/p/11649393.html/ -->
    <!-- 2.2 URL组成 -->
    <!-- URL地址一般由三部组成： -->
    <!-- (1).客户端与服务器之间的通信协议。 -->
    <!-- (2).存有该资源的服务器名称。 -->
    <!-- (3).资源在服务器上具体的存放位置。 -->
    <!-- 语法：http://www.cnblogs.com/liuweiweiblogs/ajax/url.html -->
    <!-- 语法：通信协议://服务器名称/资源路径一级目录/资源路径二级目录/具体的存放位置.html -->

    <!-- 三、分析网页的打开过程 -->
    <!-- 3.1 图解客户端与服务器的通信过程 -->
    <!-- (1).客户端请求服务器 -->
    <!-- (2).服务器处理这次请求 -->
    <!-- (3).服务器响应客户端 -->
    <!-- 客户端流程： -->
    <!-- (1).打开浏览器。 -->
    <!-- (2).输入要访问的网站地址。 -->
    <!-- (3).回车，向服务器发起资源请求。 -->
    <!-- 服务器流程： -->
    <!-- (1).服务器接收到客户端发来的资源请求。 -->
    <!-- (2).服务器在内部处理这次请求，找到相关的资源。 -->
    <!-- (3).服务器把找到的资源，响应（发送）给客户端。 -->
    <!-- 注意：客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤。 -->
    <!-- 注意：网页中的每一个资源，都是通过 请求 – 处理 – 响应 的方式从服务器获取回来的。 -->
    <!-- 3.2 基于浏览器的开发者工具分析通信过程 -->
    <!-- (1).打开 Chrome 浏览器。 -->
    <!-- (2).Ctrl+Shift+I 打开 Chrome 的开发者工具。 -->
    <!-- (3).切换到 Network 面板。 -->
    <!-- (4).选中 Doc 页签。 -->
    <!-- (5).刷新页面，分析客户端与服务器的通信过程。 -->

    <!-- 四、服务器对外提供了哪些资源 -->
    <!-- 4.1 例举网页中常见的资源 -->
    <!-- (1).字体。 -->
    <!-- (2).图片。 -->
    <!-- (3).音频。 -->
    <!-- (4).视频。 -->
    <!-- 4.2 数据也是资源 -->
    <!-- 网页中的数据，也是服务器对外提供的一种资源。例如股票数据、各行业排行榜等。 -->
    <!-- 4.3 数据是网页的灵魂 -->
    <!-- (1).HTML       是网页的骨架。 -->
    <!-- (1).CSS        是网页的颜值。 -->
    <!-- (1).Javascript 是网页的行为。 -->
    <!-- (1).Data       数据则是网页的灵魂。 -->
    <!-- 总结：骨架、颜值、行为皆为数据服务数据，在网页中无处不在。 -->
    <!-- 4.4 网页中如何请求数据 -->
    <!-- 数据，也是服务器对外提供的一种资源。只要是资源，必然要通过 请求、处理、响应的方式进行获取。 -->
    <!-- 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。 -->
    <!-- XMLHttpRequest（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。 -->
    <!-- 最简单的用法：var xhrObj = new XMLHttpRequest(); -->
    <!-- 4.5 资源的请求方式 -->
    <!-- 客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为 get 和 post 请求。 -->
    <!-- (1).GET  请求通常用于获取服务端资源（向服务器要资源）。例如：根据 URL 地址，从服务器获取 HTML 文件、css 文件、js文件、图片文件、数据资源等。 -->
    <!-- (2).POST 请求通常用于向服务器提交数据（往服务器发送资源）。例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。 -->

    <!-- 五、了解Ajax -->
    <!-- 5.1 Ajax概述 -->
    <!-- Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。 -->
    <!-- 通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。 -->
    <!-- 5.2 Ajax场景 -->
    <!-- 之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但是，Ajax能让我们轻松实现网页与服务器之间的数据交互。 -->
    <!-- 用户名检测：注册用户时，通过 ajax 的形式，动态检测用户名是否被占用。 -->
    <!-- 搜索提示：当输入搜索关键字时，通过 ajax 的形式，动态加载搜索提示列表。 -->
    <!-- 数据分页显示：当点击页码值的时候，通过 ajax 的形式，根据页码值动态刷新表格的数据。 -->
    <!-- 数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过 ajax 的形式，来实现数据的交互。 -->

    <!-- 四、防抖与节流 -->
    <!-- 4.1 什么是防抖 -->
    <!-- 防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 -->
    <!-- 4.2 防抖的应用场景 -->
    <!-- 用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源； -->
    <!-- 实现输入框的防抖： -->
    <!-- 4.1 什么是节流 -->
    <!-- 节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 -->
    <!-- 4.2 节流的应用场景 -->
    <!-- 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次； -->
    <!-- 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源； -->
    <!-- 节流案例：鼠标跟随效果？ -->
    <!-- 节流阀的概述？ -->
    <!-- 高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。 -->
    <!-- 假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。 -->
    <!-- 上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。 -->
    <!-- 下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。 -->
    <!-- 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。 -->
    <!-- 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。 -->
    <!-- 每次执行操作前，必须先判断节流阀是否为空。 -->
    <!-- 总结： -->
    <!-- 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效，前面 N 多次的触发都会被忽略。 -->
    <!-- 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件。 -->

    <!-- 一、HTTP 协议 -->
    <!-- 1.1 什么是通信 -->
    <!-- 通信，就是信息的传递和交换。 -->
    <!-- 通信三要素： -->
    <!-- 通信的主体 -->
    <!-- 通信的内容 -->
    <!-- 通信的方式 -->
    <!-- 案例：张三要把自己考上传智专修学院的好消息写信告诉自己的好朋友李四。 -->
    <!-- 其中： -->
    <!-- 通信的主体是张三和李四； -->
    <!-- 通信的内容是考上传智专修学院； -->
    <!-- 通信的方式是写信； -->
    <!-- 其中： -->
    <!-- 通信的主体是服务器和客户端浏览器； -->
    <!-- 通信的内容是传智专修学院的简介； -->
    <!-- 通信的方式是响应； -->
    <!-- 1.2 什么是通信协议 -->
    <!-- 通信协议（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。 -->
    <!-- 通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。 -->
    <!-- 互联网中的通信协议： -->
    <!-- 客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。 -->
    <!-- 网页内容又叫做超文本，因此网页内容的传输协议又叫做超文本传输协议（HyperText Transfer Protocol） ，简称 HTTP 协议。 -->
    <!-- 1.3 HTTP -->
    <!-- HTTP 协议即超文本传送协议 (HyperText Transfer Protocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。 -->
    <!-- 例如： -->
    <!-- (1).客户端要以HTTP协议要求的格式把数据提交到服务器。 -->
    <!-- (2).服务器要以HTTP协议要求的格式把内容响应给客户端。 -->
    <!-- HTTP 协议的交互模型: -->
    <!-- HTTP 协议采用了 请求/响应 的交互模型。 -->

    <!-- 二、HTTP 请求 -->
    <!-- 2.1 什么是HTTP请求消息 -->
    <!-- 由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 HTTP 请求，客户端发送到服务器的消息，叫做 HTTP 请求消息。 -->
    <!-- 注意：HTTP 请求消息又叫做 HTTP 请求报文。 -->
    <!-- HTTP 请求消息的组成分部： -->
    <!-- HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。 -->
    <!-- 1.请求行 -->
    <!-- 请求行由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。 -->
    <!-- 2.请求头部 -->
    <!-- 请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。 -->
    <!-- 请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。 -->
    <!-- 3.空行 -->
    <!-- 最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。 -->
    <!-- 请求消息中的空行，用来分隔请求头部与请求体。 -->
    <!-- 4.请求体 -->
    <!-- 请求体中存放的，是要通过 POST 方式提交到服务器的数据。 -->

    <!-- 三、HTTP 响应 -->
    <!-- 2.2 什么是HTTP响应消息 -->
    <!-- 响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。 -->
    <!-- HTTP 响应消息的组成部分： -->
    <!-- HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示： -->
    <!-- 1.状态行 -->
    <!-- 状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开。 -->
    <!-- 2.响应头部 -->
    <!-- 响应头部用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。 -->
    <!-- 3.空行 -->
    <!-- 在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。 -->
    <!-- 响应消息中的空行，用来分隔响应头部与响应体。 -->
    <!-- 4.响应体 -->
    <!-- 响应体中存放的，是服务器响应给客户端的资源内容。 -->

    <!-- 四、HTTP 请求方法 -->
    <!-- 4.1 什么是HTTP请求方法 -->
    <!-- HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。 -->
    <!-- GET     (查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。 -->
    <!-- POST    (新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。 -->
    <!-- PUT     (修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。 -->
    <!-- DELETE  (删除)请求服务器删除指定的资源。 -->
    <!-- HEAD    HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 -->
    <!-- OPTIONS 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 -->
    <!-- CONNECT 建立一个到由目标资源标识的服务器的隧道。 -->
    <!-- TRACE   沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 -->
    <!-- PATCH   是对 PUT 方法的补充，用来对已知资源进行局部更新 。 -->

    <!-- 五、HTTP 响应状态码 -->
    <!-- 5.1 什么是HTTP响应状态码 -->
    <!-- HTTP 响应状态码（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。 -->
    <!-- 响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。 -->
    <!-- HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。 -->
    <!-- HTTP 状态码共分为 5 种类型： -->
    <!-- 1xx 信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到 1** 类型的状态码） -->
    <!-- 2xx 成功，操作被成功接收并处理 -->
    <!-- 3xx 重定向，需要进一步的操作以完成请求 -->
    <!-- 4xx 客户端错误，请求包含语法错误或无法完成请求 -->
    <!-- 5xx 服务器错误，服务器在处理请求的过程中发生了错误 -->
    <!-- 完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status -->




    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




    <!-- NodeJS 部分 -->




    <!-- 一、Node.js -->
    <!-- 1.1 回顾与思考 -->
    <!-- (1).已经掌握了哪些技术？ -->
    <!-- (2).浏览器中的 JavaScript 的组成部分？ -->
    <!-- (3).为什么 JavaScript 可以在浏览器中被执行？ -->
    <!-- 不同的浏览器使用不同的 JavaScript 解析引擎： -->
    <!-- Chrome  浏览器 => V8 -->
    <!-- Firefox 浏览器 => OdinMonkey（奥丁猴） -->
    <!-- Safri   浏览器 => JSCore -->
    <!-- IE      浏览器 => Chakra（查克拉） -->
    <!-- etc     ... -->
    <!-- 其中，Chrome 浏览器的 V8 解析引擎性能最好。 -->
    <!-- (4).为什么 JavaScript 可以操作 DOM 和 BOM？ -->
    <!-- 每个浏览器都内置了 DOM、BOM 这样的 API 函数，因此，浏览器中的 JavaScript 才可以调用它们。 -->
    <!-- (5).浏览器中的 JavaScript 运行环境？ -->
    <!-- 运行环境是指代码正常运行所需的必要环境。 -->
    <!-- 总结： -->
    <!-- V8 引擎负责解析和执行 JavaScript 代码。 -->
    <!-- 内置 API 是由运行环境提供的特殊接口，只能在所属的运行环境中被调用。 -->
    <!-- (6).JavaScript 能否做后端开发？ -->
    <!-- 回答：可以。常见后端开发语言（Java，Python，PHP，Node.js）。 -->

    <!-- 1.2 Node.js 简介 -->
    <!-- (1).什么是Node.js？ -->
    <!-- Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. -->
    <!-- Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 -->
    <!-- Node.js 的官网地址： https://nodejs.org/zh-cn/ -->
    <!-- (2).Node.js 中的 JavaScript 运行环境？【重点】类似于Java的虚拟机内存模型。 -->
    <!-- Node.js 运行环境： -->
    <!-- V8 引擎。 -->
    <!-- 内置API（fs、path、http、js 内置对象、querystring、etc...）。 -->
    <!-- 待执行的 JavaScript 代码。 -->
    <!-- 注意： -->
    <!-- 浏览器是 JavaScript 的前端运行环境。 -->
    <!-- Node.js 是 JavaScript 的后端运行环境。 -->
    <!-- Node.js 中无法调用 DOM 和 BOM 等浏览器内置 API。 -->
    <!-- (3).Node.js 可以做什么？ -->
    <!-- Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位： -->
    <!-- 基于 【Express 】 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用。 -->
    <!-- 基于 【Electron】 框架（https://electronjs.org/），可以构建跨平台的桌面应用。 -->
    <!-- 基于 【restify 】 框架（http://restify.com/），可以快速构建 API 接口项目。 -->
    <!-- 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc...。 -->
    <!-- 总之：Node.js 是大前端时代的“大宝剑”，有了 Node.js 这个超级 buff 的加持，前端程序员的行业竞争力会越来越强。 -->
    <!-- (4).Node.js 好学吗？ -->
    <!-- 会 JavaScript，就能学会 Node.js。 -->
    <!-- (5).Node.js 怎么学？ -->
    <!-- 浏览器中的 JavaScript 学习路径： -->
    <!-- JavaScript 基础语法（ECMAScript） + 浏览器 内置 API（DOM + BOM） + 第三方库（jQuery、Ajax、art-template等等）。 -->
    <!-- Node.js 的学习路径： -->
    <!-- JavaScript 基础语法（ECMAScript） + Node.js 内置 API 模块（fs、path、http等等）+ 第三方 API 模块（express、mysql等等）。 -->

    <!-- 1.3 Node.js 环境的安装 -->
    <!-- 如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。 -->
    <!-- 安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（https://nodejs.org/en/），点击绿色的按钮，下载所需的版本后，双击直接安装即可。 -->
    <!-- (1).区分 LTS 版本和 Current 版本的不同？ -->
    <!-- LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js。 -->
    <!-- Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。 -->
    <!-- (2).查看已经安装的 Node.js 的版本号？ -->
    <!-- 打开终端，在终端输入命令 node –v 后，按下回车键，即可查看已安装的 Node.js 的版本号。 -->
    <!-- Windows 系统快速打开终端的方式：使用快捷键（Windows徽标键 + R）打开运行面板，输入 cmd 后直接回车，即可打开终端。 -->
    <!-- (3).什么是终端？ -->
    <!-- 终端（英文：Terminal）是专门为开发人员设计的，用于实现人机交互的一种方式。 -->
    <!-- 作为一名合格的程序员，我们有必要识记一些常用的终端命令，来辅助我们更好的操作与使用计算机。 -->
    <!-- (4).在 Node.js 环境中执行 JavaScript 代码？ -->
    <!-- 打开终端。 -->
    <!-- 输入 node 要执行的js文件的路径。 -->
    <!-- 终端中的快捷键： -->
    <!-- 在 Windows 系统中使用 powershell 命令或 cmd 命令终端中，我们可以通过如下快捷键，来提高终端的操作效率： -->
    <!-- 使用 ↑ 键，可以快速定位到上一次执行的命令。 -->
    <!-- 使用 tab 键，能够快速补全路径。 -->
    <!-- 使用 esc 键，能够快速清空当前已输入的命令。 -->
    <!-- 输入 cls 命令，可以清空终端。 -->

    <!-- 二、Node.js fs 模块（文件系统：FileSystem） -->
    <!-- 2.1 什么是 fs 文件系统模块 -->
    <!-- fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 -->
    <!-- 例如： -->
    <!-- fs.readFile(path, options, callback);        方法，用来读取指定文件中的内容。 -->
    <!-- fs.writeFile(file, data, options, callback); 方法，用来向指定的文件中写入内容。 -->
    <!-- 如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它： -->
    <!-- 代码： -->
    <!-- const fs = require('fs'); -->
    <!-- 实例： -->
    <!-- <script>
        const fs = require('fs');
        const path = require('path');
        const regExpStyle = /<style>[\s\S]*<\/style>/;
        const regExpScript = /<script>[\s\S]*<\/script>/;
        const filePath = path.join(__dirname, './templates/index.html');
        // 1.读取文件
        fs.readFile(filePath, 'utf-8', function (err, dataStr) {
            if (err) {
                console.log(err.message);
                return false;
            }
            console.log(200);
            resolveStyle(dataStr);
            resolveScript(dataStr);
            resolveHtml(dataStr);
        });
        // 2.处理样式文件
        function resolveStyle(dataStr) {
            const dataVal = regExpStyle.exec(dataStr);
            // console.log(dataVal);
            const styleVal = dataVal[0].replace('<style>', '').replace('</style>', '');
            // console.log(styleVal);
            fs.writeFile(path.join(__dirname, './templates/clock/index.css'), styleVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
        // 4.处理脚本文件
        function resolveScript(dataStr) {
            const dataVal = regExpScript.exec(dataStr);
            // console.log(dataVal);
            const scriptVal = dataVal[0].replace('<script>', '').replace('</script>', '');
            fs.writeFile(path.join(__dirname, './templates/clock/index.js'), scriptVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
        // 3.处理结构文件
        function resolveHtml(dataStr) {
            const htmlVal = dataStr.replace(regExpStyle, '<link rel="stylesheet" href="./index.css">').replace(regExpScript, '<script src="./index.js"></script>');
            fs.writeFile(path.join(__dirname, './templates/clock/index.html'), htmlVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
    </script> -->

    <!-- 2.2 读取指定文件中的内容 -->
    <!-- (1).fs.readFile() 的语法格式？ -->
    <!-- 使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下： -->
    <!-- fs.readFile(path, options, callback); -->
    <!-- 参数解读： -->
    <!-- 参数1：必选参数，字符串，表示文件的路径。 -->
    <!-- 参数2：可选参数，表示以什么编码格式来读取文件。 -->
    <!-- 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。 -->
    <!-- (2).fs.readFile() 的示例代码？ -->
    <!-- 以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值： -->
    <!-- <script>
        const fs = require('fs');
        fs.readFile('./files/one.txt', 'utf-8', function (err, data) {
            console.log(err);
            console.log(data);
        });
    </script> -->
    <!-- (3).判断文件是否读取成功？ -->
    <!-- 可以判断 err 对象是否为 null，从而知晓文件读取的结果： -->
    <!-- <script>
        const fs = require('fs');
        fs.readFile('./files/one.txt', 'utf-8', function (err, data) {
            if (err) {
                console.log(404);
                return false;
            }
            console.log(data);
        });
    </script> -->

    <!-- 2.3 向指定的文件中写入内容 -->
    <!-- (1).fs.writeFile() 的语法格式？ -->
    <!-- 使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下： -->
    <!-- fs.writeFile(file, data, options, callback); -->
    <!-- 参数解读： -->
    <!-- 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。 -->
    <!-- 参数2：必选参数，表示要写入的内容。 -->
    <!-- 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。 -->
    <!-- 参数4：必选参数，文件写入完成后的回调函数。 -->
    <!-- (2).fs.writeFile() 的示例代码？ -->
    <!-- 向指定的文件路径中，写入文件内容： -->
    <!-- <script>
        const fs = require('fs');
        fs.writeFile('./files/two.txt', 'Hello World', function (err) {
            console.log(err);
        });
    </script> -->
    <!-- (3).判断文件是否写入成功？ -->
    <!-- 可以判断 err 对象是否为 null，从而知晓文件写入的结果： -->
    <!-- <script>
        const fs = require('fs');
        fs.writeFile('./files/two.txt', 'Hello World', function (err) {
            if (err) {
                console.log(500);
                return false;
            }
            console.log(200);
        });
    </script> -->
    <!-- 练习：考试成绩整理 -->
    <!-- 使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。 -->
    <!-- 整理前，成绩.txt文件中的数据格式如下： -->
    <!-- 整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下： -->
    <!-- 核心实现步骤： -->
    <!-- 导入需要的 fs 文件系统模块。 -->
    <!-- 使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件。 -->
    <!-- 判断文件是否读取失败。 -->
    <!-- 文件读取成功后，处理成绩数据。 -->
    <!-- 将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中。 -->

    <!-- 2.6 fs 模块 - 路径动态拼接的问题 -->
    <!-- 在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 -->
    <!-- 原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。 -->
    <!-- 解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。 -->
    <!-- 解决路径问题： -->
    <!-- <script>
        // NodeJS 文件系统模块（File System）
        const fs = require('fs');
        // NodeJS 路径模块（Path）
        const path = require('path');
        // NodeJS 超文本传输协议模块（Hyper Text Transfer Protocol）
        const http = require('http');
        const regExpStyle = /<style>[\s\S]*<\/style>/;
        const regExpScript = /<script>[\s\S]*<\/script>/;
        const filePath = path.join(__dirname, './templates/index.html');
        // 1.读取文件
        fs.readFile(filePath, 'utf-8', function (err, dataStr) {
            if (err) {
                console.log(err.message);
                return false;
            }
            console.log(200);
            resolveStyle(dataStr);
            resolveScript(dataStr);
            resolveHtml(dataStr);
        });
        // 2.处理样式文件
        function resolveStyle(dataStr) {
            const dataVal = regExpStyle.exec(dataStr);
            // console.log(dataVal);
            const styleVal = dataVal[0].replace('<style>', '').replace('</style>', '');
            // console.log(styleVal);
            fs.writeFile(path.join(__dirname, './templates/clock/index.css'), styleVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
        // 4.处理脚本文件
        function resolveScript(dataStr) {
            const dataVal = regExpScript.exec(dataStr);
            // console.log(dataVal);
            const scriptVal = dataVal[0].replace('<script>', '').replace('</script>', '');
            fs.writeFile(path.join(__dirname, './templates/clock/index.js'), scriptVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
        // 3.处理结构文件
        function resolveHtml(dataStr) {
            const htmlVal = dataStr.replace(regExpStyle, '<link rel="stylesheet" href="./index.css">').replace(regExpScript, '<script src="./index.js"></script>');
            fs.writeFile(path.join(__dirname, './templates/clock/index.html'), htmlVal, function (err) {
                if (err) {
                    console.log(err.message);
                    return false;
                }
                console.log(200);
            });
        }
    </script> -->

    <!-- 三、Node.js path 模块（路径：Path） -->
    <!-- 3.1 什么是 path 路径模块 -->
    <!-- path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。 -->
    <!-- 例如： -->
    <!-- path.join()     方法，用来将多个路径片段拼接成一个完整的路径字符串。 -->
    <!-- path.basename() 方法，用来从路径字符串中，将文件名解析出来。 -->
    <!-- 如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它： -->
    <!-- const path = require('path'); -->

    <!-- 3.2 路径拼接 -->
    <!-- (1).path.join() 的语法格式？ -->
    <!-- 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下： -->
    <!-- 参数解读： -->
    <!-- ...paths <string> 路径片段的序列。 -->
    <!-- 返回值: <string>。 -->
    <!-- (2).path.join() 的代码示例？ -->
    <!-- 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串： -->
    <!-- <script>
        const onePath = path.join('/a', '/b/c', '../', './d', 'e');
        console.log(filePath);
        const twoPath = path.join(__dirname, './files/one.txt');
    </script> -->
    <!-- 注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。 -->

    <!-- 3.3 获取路径中的文件名 -->
    <!-- (1).path.basename() 的语法格式？ -->
    <!-- 使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下： -->
    <!-- 参数解读： -->
    <!-- path <string> 必选参数，表示一个路径的字符串。 -->
    <!-- ext  <string> 可选参数，表示文件扩展名。 -->
    <!-- 返回: <string> 表示路径中的最后一部分。 -->
    <!-- 2. path.basename() 的代码示例？ -->
    <!-- 使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分： -->
    <!-- <script>
        const filePath = '/a/b/c/index.html';
        let fullName = path.basename(filePath);
        console.log(fullName);
        let nameWithoutExt = path.basename(filePath, '.html');
        console.log(nameWithoutExt);
    </script> -->

    <!-- 3.4 获取路径中的文件扩展名 -->
    <!-- (1).path.extname() 的语法格式？ -->
    <!-- 使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下： -->
    <!-- 参数解读： -->
    <!-- path <string>必选参数，表示一个路径的字符串。 -->
    <!-- 返回: <string> 返回得到的扩展名字符串。 -->
    <!-- 2. path.extname() 的代码示例？ -->
    <!-- 使用 path.extname() 方法，可以获取路径中的扩展名部分： -->
    <!-- <script>
        const filePath = '/a/b/c/index.html';
        const fileExt = path.extname(filePath);
        console.log(fileExt);
    </script> -->

    <!-- 3.5 综合案例：时钟 -->
    <!-- 案例的实现步骤： -->
    <!-- 创建两个正则表达式，分别用来匹配 <style> 和 <script> 标签。 -->
    <!-- 使用 fs 模块，读取需要被处理的 HTML 文件。 -->
    <!-- 自定义 resolveCSS  方法，来写入 index.css  样式文件。 -->
    <!-- 自定义 resolveJS   方法，来写入 index.js   脚本文件。 -->
    <!-- 自定义 resolveHTML 方法，来写入 index.html 结构文件。 -->
    <!-- 经典实例：时钟 -->
    <!-- <style>
        .box {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 80px;
            border: thick solid black;
            background-color: rgba(255, 255, 255, 0.6);
            border-radius: 6px;
            box-shadow: 1px 1px 10px #fff;
            text-shadow: 0px 1px 30px white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 70px;
            user-select: none;
            padding: 0 20px;
        }
    </style>
    <div class="box">
        <div id="HH">00</div>
        <div>:</div>
        <div id="mm">00</div>
        <div>:</div>
        <div id="ss">00</div>
    </div>
    <script src="./libs/jquery-3.5.1.min.js"></script>
    <script>
        window.onload = function () {
            // 定时器每隔 1 秒执行 1 次
            window.setInterval(() => {
                var dt = new Date();
                var HH = dt.getHours();
                var mm = dt.getMinutes();
                var ss = dt.getSeconds();
                // 为页面上的元素赋值
                document.querySelector('#HH').innerHTML = padZero(HH);
                document.querySelector('#mm').innerHTML = padZero(mm);
                document.querySelector('#ss').innerHTML = padZero(ss);
            }, 1000);
        };
        // 补零函数
        function padZero(n) {
            return n > 9 ? n : '0' + n;
        }
    </script> -->
    <!-- 案例的两个注意点： -->
    <!-- fs.writeFile() 方法只能用来创建文件，不能用来创建路径。 -->
    <!-- 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容。 -->

    <!-- 四、Node.js http 模块（超文本传输协议：Hyper Text Transfer Protocol） -->
    <!-- 4.1 什么是 http 模块 -->
    <!-- 回顾：什么是客户端、什么是服务器？ -->
    <!-- 在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。 -->
    <!-- http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。 -->
    <!-- 如果要希望使用 http 模块创建 Web 服务器，则需要先导入它： -->
    <!-- const http = require('http'); -->

    <!-- 4.2 进一步理解 http 模块的作用 -->
    <!-- 服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。 -->
    <!-- 在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务。 -->

    <!-- 4.3 服务器相关的概念 -->
    <!-- (1).IP 地址 -->
    <!-- IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。 -->
    <!-- IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）。 -->
    <!-- 注意： -->
    <!-- 互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。 -->
    <!-- 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP 地址，就能把自己的电脑当做一台服务器进行访问了。 -->
    <!-- (2).域名与域名服务器 -->
    <!-- 尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。 -->
    <!-- IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。 -->
    <!-- 注意： -->
    <!-- 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。 -->
    <!-- 在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。 -->
    <!-- (3).端口 -->
    <!-- 计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。 -->
    <!-- 同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。 -->
    <!-- 注意： -->
    <!-- 每个端口号不能同时被多个 web 服务占用。 -->
    <!-- 在实际应用中，URL 中的 80 端口可以被省略。 -->

    <!-- 4.4 创建最基本的 web 服务器 -->
    <!-- (1).创建 web 服务器的基本步骤？ -->
    <!-- 导入 http 模块。 -->
    <!-- 创建 web 服务器实例。 -->
    <!-- 服务器绑定 request 请求事件，监听客户端的请求。 -->
    <!-- 启动服务器。 -->
    <!-- 步骤一：导入 http 模块 -->
    <!-- 如果希望在自己的电脑上创建一个 web 服务器，从而对外提供 web 服务，则需要导入 http 模块： -->
    <!-- const http = require('http'); -->
    <!-- 步骤二：创建 web 服务器实例 -->
    <!-- 调用 http.createServer() 方法，即可快速创建一个 web 服务器实例： -->
    <!-- const server = http.createServer(); -->
    <!-- 步骤三：为服务器实例绑定 request 事件 -->
    <!-- 为服务器实例绑定 request 事件，即可监听客户端发送过来的网络请求： -->
    <!-- server.on('request', function(request, response) {}); -->
    <!-- 步骤四：启动服务器 -->
    <!-- 调用服务器实例的 .listen() 方法，即可启动当前的 web 服务器实例： -->
    <!-- server.listen(8080, function() {}); -->
    <!-- 步骤五：request 请求对象 -->
    <!-- 只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。 -->
    <!-- 如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式： -->
    <!-- server.on('request', function(request, response) { 
        const url = request.url;
        const method = request.method;
        console.log(`your request url is ${url}, and request method is ${method}`);
    }); -->
    <!-- 步骤六：response 响应对象 -->
    <!-- server.on('request', function(request, response) { 
        const url = request.url;
        const method = request.method;
        const str = `your request url is ${url}, and request method is ${method}`;
        response.end(str);
    }); -->
    <!-- (2).解决中文乱码问题？ -->
    <!-- 当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式： -->
    <!-- server.on('request', function(request, response) { 
        const url = request.url;
        const method = request.method;
        const str = `your request url is ${url}, and request method is ${method}`;
        response.setHeader('Content-Type', 'text/html; charset=utf-8');
        response.end(str);
    }); -->
    <!-- <script>
        // NodeJS 超文本传输协议模块（Hyper Text Transfer Protocol）
        const http = require('http');
        // 创建服务器实例
        const server = http.createServer();
        // 监听请求事件
        server.on('request', function (request, response) {
            console.log(`Someone visit our web server!`);
            const url = request.url;
            const method = request.method;
            const str = "request url address is " + url + ", and method is " + method;
            console.log(str);
            const headers = request.headers;
            console.log("request headers is " + headers);
            const utf8 = `请求URL地址是${request.url}，还有请求方法是${request.method}`;
            response.setHeader('Content-Type', 'text/html; charset=utf-8');
            response.end(utf8);
        });
        // 启动服务器
        server.listen(8080, function () {
            console.log(`Http server running at http://localhost:8080`);
        });
    </script> -->

    <!-- 4.5 根据不同的 url 响应不同的 html 内容 -->
    <!-- (1).核心实现步骤？ -->
    <!-- 获取请求的 url 地址： -->
    <!-- 设置默认的响应内容为 404 Not found。 -->
    <!-- 判断用户请求的是否为 / 或 /index.html 首页。 -->
    <!-- 判断用户请求的是否为 /about.html 关于页面。 -->
    <!-- 设置 Content-Type 响应头，防止中文乱码。 -->
    <!-- 使用 res.end() 把内容响应给客户端。 -->
    <!-- (2).动态响应内容？ -->
    <!-- <script>
        // 引入服务器模块
        const http = require('http');
        // 创建服务器实例
        const server = http.createServer();
        // 监听请求事件
        server.on('request', function (request, response) {
            const url = request.url;
            let content = `<h1>404 - Not found</h1>`;
            if (url === '/' || url === '/index.html') {
                content = `<h1>Index Page</h1>`;
            } else if (url === '/about.html') {
                content = `<h1>About Page</h1>`;
            }
            response.setHeader('Content-Type', 'text/html; charset=utf-8');
            response.end(content);
        });
        // 启动服务器实例
        server.listen(8080, function () {
            console.log(`Http server running at http://localhost:8080`);
        });
    </script> -->
    <!-- <script>
        // 导入模块（文件系统、路径、服务器）
        const fs = require('fs');
        const path = require('path');
        const http = require('http');
        // 创建web服务器实例
        const server = http.createServer();
        // 监听web服务器请求
        server.on('request', function (request, response) {
            const url = request.url;
            let filePath = null;
            if (url === '/') {
                filePath = path.join(__dirname, './templates/clock/index.html');
                console.log('FilePathIsA:' + filePath);
            } else {
                filePath = path.join(__dirname, './templates/clock', url);
                console.log('FilePathIsB:' + filePath);
            }
            fs.readFile(filePath, 'utf-8', function (err, data) {
                if (err) {
                    return response.end(`404 - Not found`);
                }
                response.end(data);
            });
        });
        // 启动web服务器实例
        server.listen(8080, function () {
            console.log(`Http server running at http://localhost:8080`);
        });
    </script> -->

    <!-- 4.6 案例：实现 clock 时钟的 web 服务器 -->
    <!-- (1).核心思路 -->
    <!-- 把文件的实际存放路径，作为每个资源的请求 url 地址。 -->
    <!-- (2).实现步骤 -->
    <!-- 导入需要的模块。 -->
    <!-- 创建基本的 web 服务器。 -->
    <!-- 将资源的请求 url 地址映射为文件的存放路径。 -->
    <!-- 读取文件内容并响应给客户端。 -->
    <!-- 优化资源的请求路径。 -->
    <!-- 步骤一：导入需要的模块 -->
    <!-- <script>
        const fs = require('fs');
        const path = require('path');
        const http = require('http');
    </script> -->
    <!-- 步骤二：创建最基本的 web 服务器 -->
    <!-- <script>
        const fs = require('fs');
        const path = require('path');
        const http = require('http');
        const server = http.createServer();
        server.on('request', function (request, response) {});
        server.listen(8080, function () {});
    </script> -->
    <!-- 步骤三：将资源的请求 url 地址映射主文件的存放路径 -->
    <!-- <script>
        const fs = require('fs');
        const path = require('path');
        const http = require('http');
        const server = http.createServer();
        server.on('request', function (request, response) {
            const url = request.url;
            const filePath = path.join(__dirname, url);
        });
        server.listen(8080, function () {});
    </script> -->
    <!-- 步骤四：读取文件的内容并且响应给客户端 -->
    <!-- <script>
        const fs = require('fs');
        const path = require('path');
        const http = require('http');
        const server = http.createServer();
        server.on('request', function (request, response) {
            const url = request.url;
            const filePath = path.join(__dirname, url);
            fs.readFile(filePath, 'utf-8', function (err, dataStr) {
                if (err) {
                    console.log(500);
                    return false;
                }
                response.end(dataStr);
            });
        });
        server.listen(8080, function () {
            console.log(`server start successs in http://localhost:8080/`);
        });
    </script> -->

    <!-- 五、Node.js 模块化 -->
    <!-- 5.1 什么是模块化 -->
    <!-- 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。 -->
    <!-- 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆分成独立并且相互依赖的多个小模块。 -->
    <!-- 把代码进行模块化拆分的好处： -->
    <!-- 提高了代码的复用性。 -->
    <!-- 提高了代码的可维护性。 -->
    <!-- 可以实现按需加载。 -->

    <!-- 5.2 模块化规范 -->
    <!-- 模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。 -->
    <!-- 例如： -->
    <!-- 使用什么样的语法格式来引用模块。 -->
    <!-- 在模块中使用什么样的语法格式向外暴露成员。 -->
    <!-- 模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。 -->

    <!-- 5.3 Node.js 中模块的分类 -->
    <!-- Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是： -->
    <!-- (1).内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）。 -->
    <!-- (2).自定义模块（用户创建的每个 .js 文件，都是自定义模块）。 -->
    <!-- (3).第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）。 -->

    <!-- 5.4 Node.js 模块的加载 -->
    <!-- 使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如： -->
    <!-- 内置模块 -->
    <!-- const fs = require('fs'); -->
    <!-- const path = require('path'); -->
    <!-- const http = require('http'); -->
    <!-- 自定义模块 -->
    <!-- const fiveFile = require('./five.js'); -->
    <!-- 第三方模块 -->
    <!-- const moment = require('moment'); -->
    <!-- <script>
        // 1.加载内置的文件系统模块
        const fs = require('fs');
        // 2.加载用户的自定义模块
        const fiveFile = require('./five.js');
        // 3.加载第三方模块（前提：通过 npm install moment 下载此包）
        const moment = require('moment');
    </script> -->

    <!-- 5.5 Node.js 中的模块作用域 -->
    <!-- (1).什么是作用域？ -->
    <!-- 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。 -->
    <!-- (2).模块作用域的好处？ -->
    <!-- 防止了全局变量污染的问题。 -->

    <!-- 5.6 向外共享模块作用域中的成员 -->
    <!-- (1).Module 对象 -->
    <!-- 在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下： -->
    <!-- 
    Module {                                             
        '9': [Function: internalRequire],                  
        id: '.',                                           
        path: 'D:\\workspace-vscode\\nodejs',              
        exports: {},                                       
        filename: 'D:\\workspace-vscode\\nodejs\\seven.js',
        loaded: false,                                     
        children: [],                                      
        paths: [                                           
            'D:\\workspace-vscode\\nodejs\\node_modules',    
            'D:\\workspace-vscode\\node_modules',            
            'D:\\node_modules'                               
        ]                                                  
    }
    -->
    <!-- (2).Module.Exports 对象 -->
    <!-- 在自定义模块中，可以使用 Module.Exports 对象，将模块内的成员共享出去，供外界使用。 -->
    <!-- 外界使用 require() 方法导入自定义模块时，得到的就是 Module.Exports 对象所指向的对象。 -->
    <!-- five.js -->
    <!-- 
    <script>
        module.exports.username = 'Brendan Eich';
        module.exports.password = '12345678';
        module.exports.user = {
            name: "Jessica",
            age: 24
        };
    </script> -->
    <!-- Exports 对象 -->
    <!-- 由于 Module.Exports 对象写起来比较复杂，为了简化向外共享成员的代码，NodeJS 提供了 Exports 对象。 -->
    <!-- 默认情况下，Exports 对象和 Module.Exports 对象指向同一个对象。 -->
    <!-- 最终共享的结果，还是以 Module.Exports 指向的对象为准。 -->
    <!-- five.js -->
    <!-- 
    <script>
        exports.age = 28;
        exports.sing = function () {
            console.log('唱歌');
        };
        exports.dance = function () {
            console.log('跳舞');
        };
        exports.user = {
            name: "Brendan Eich",
            age: 28
        };
    </script> -->
    <!-- (3).共享成员时的注意点 -->
    <!-- 使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。 -->
    <!-- (4).Exports 与 Module.Exports 使用区别 -->
    <!-- 时刻谨记，使用 require() 导入模块时，得到的永远都是 Module.Exports 指向的对象。 -->
    <!-- five.js -->
    <!-- 
    <script>
        module.exports.username = 'Brendan Eich';
        module.exports.password = '12345678';
        module.exports.user = {
            name: "Jessica",
            age: 24
        };
        exports.age = 28;
        exports.sing = function () {
            console.log('唱歌');
        };
        exports.dance = function () {
            console.log('跳舞');
        };
        exports.user = {
            name: "Brendan Eich",
            age: 28
        };
    </script> -->
    <!-- eight.js -->
    <!-- 
    <script>
        const fiveFile = require('./five.js');
        console.log(fiveFile);
    </script> -->
    <!-- 
    Module {                                             
        '9': [Function: internalRequire],                  
        id: '.',                                           
        path: 'D:\\workspace-vscode\\nodejs',              
        exports: {},                                       
        filename: 'D:\\workspace-vscode\\nodejs\\seven.js',
        loaded: false,                                     
        children: [],                                      
        paths: [                                           
            'D:\\workspace-vscode\\nodejs\\node_modules',    
            'D:\\workspace-vscode\\node_modules',            
            'D:\\node_modules'                               
        ]                                                  
    }
    {                                         
        username: 'Brendan Eich',               
        password: '12345678',                   
        user: { name: 'Brendan Eich', age: 28 },
        age: 28,                                
        sing: [Function (anonymous)],           
        dance: [Function (anonymous)]           
    }
    -->
    <!-- 注意：为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports。 -->

    <!-- 5.7 Node.js 模块化规范 -->
    <!-- Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各个模块之间是如何相互依赖的。 -->
    <!-- CommonJS 规定： -->
    <!-- 每个模块内部，Module 变量代表当前模块。 -->
    <!-- Module 变量是一个对象，它的 Exports 属性（就是 Module.Exports）是对外的接口。 -->
    <!-- 加载某个模块，其实就是加载该模块的 Module.Exports 属性。 -->
    <!-- require() 方法用于加载模块。 -->

    <!-- 六、npm 与 Package（包） -->
    <!-- 6.1 什么是包 -->
    <!-- Node.js 中的第三方模块又叫做包（Node Package Manager - npm（简称包管理工具））。 -->
    <!-- 就像电脑和计算机指的是相同的东西一样，第三方模块和包指的是同一个概念，只不过叫法不同而已。 -->
    <!-- 6.2 包的来源 -->
    <!-- 不同于 Node.js 中的内置模块与自定义模块，包是由第三方团队或者个人或者公司开发出来的，免费供所有人使用。 -->
    <!-- 注意：Node.js 中的包都是免费并且开源的，不需要付费即可免费下载使用。 -->
    <!-- 6.3 为什么需要包 -->
    <!-- 由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时候，效率很低。 -->
    <!-- 包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。 -->
    <!-- 包和内置模块之间的关系，类似于 JQuery 和浏览器内置 API 之间的关系。 -->
    <!-- 6.4 从哪里下载包 -->
    <!-- 国外有一家 IT 公司，叫做 npm 公司，这家公司旗下有一个非常著名的网站：https://www.npmjs.com/。 -->
    <!-- 它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心。 -->
    <!-- 到目前为止，全球约 1100 多万的开发人员，通过这个 -->
    <!-- npm 公司，提供了一个地址为：https://registry.npmjs.org/ 的服务器，来对外共享所有的包。 -->
    <!-- 我们可以从这个服务器上下载自己所需要的包。 -->
    <!-- 6.5 如何下载包 -->
    <!-- npm, Inc. 公司提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry.npmjs.org/ 服务器把需要的包下载到本地使用。 -->
    <!-- 这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。 -->
    <!-- 大家可以在终端中执行 npm -v 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号： -->

    <!-- 6.2 npm 初体验 -->
    <!-- (1).格式化时间原生做法？ -->
    <!-- five.js -->
    <!-- <script>
        // 定义或者赋值给共享对象
        module.exports = {
            dateFormat
        };
        // 封装公共函数（格式化时间）
        function dateFormat(dateStr) {
            const dt = new Date(dateStr);
            const ye = dt.getFullYear();
            const mo = zeroFill(dt.getMonth());
            const da = zeroFill(dt.getDate());
            const hh = zeroFill(dt.getHours());
            const mm = zeroFill(dt.getMinutes());
            const ss = zeroFill(dt.getSeconds());
            return `${ye}-${mo}-${da} ${hh}:${mm}:${ss}`;
        }
        // 封装公共函数（补零）
        function zeroFill(number) {
            return number > 9 ? number : '0' + number;
        }
    </script> -->
    <!-- eight.js -->
    <!-- <script>
        const fiveFile = require('./five.js');
        console.log(fiveFile.dateFormat(new Date()));
    </script> -->
    <!-- (2).格式化时间的高级用法？ -->
    <!-- 使用 npm 包管理工具，在项目中安装格式化时间的包（Moment）。 -->
    <!-- 使用 require() 方法导入格式化时间的包。 -->
    <!-- 参考 moment 的官方 API 文档对时间进行格式化。 -->
    <!-- 第三方模块高级用法： -->
    <!-- five.js -->
    <!-- <script>
        // 导入模块（文件系统、路径、服务器）
        const moment = require('moment');
        const dt = moment().format('YYYY-MM-DD hh:mm:ss');
        // 定义或者赋值给共享对象
        module.exports.dt = dt;
    </script> -->
    <!-- eight.js -->
    <!-- <script>
        console.log(fiveFile.dt);
    </script> -->

    <!-- 6.3 在项目中安装包的命令 -->
    <!-- 如果想在项目安装指定名称的名，需要运行如下的命令：npm install。 -->
    <!-- # npm install 包的完整名称 -->
    <!-- # npm install moment -->

    <!-- 6.4 初次安装包的相关文件夹及文件 -->
    <!-- 文件夹：node_modules    依赖包目录。 -->
    <!-- 文件：package.json      版本配置文件。 -->
    <!-- 文件：package-lock.json 依赖包配置文件。 -->
    <!-- 其中： -->
    <!-- node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 -->
    <!-- package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。 -->
    <!-- 注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。 -->
    <!-- 安装指定版本的包的命令 -->
    <!-- 默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。 -->
    <!-- 如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本，例如： -->
    <!-- # npm install moment@2.22.2 -->
    <!-- PS D:\workspace-vscode\nodejs> npm install moment -->
    <!-- {
        "name": "nodejs",
        "lockfileVersion": 2,
        "requires": true,
        "packages": {
            "node_modules/moment": {
                "version": "2.29.4",
                "resolved": "https://registry.npmmirror.com/moment/-/moment-2.29.4.tgz",
                "integrity": "sha512-5LC9SOxjSc2HF6vO2CyuTDNivEdoz2IvyJJGj6X8DJ0eFyfszE0QiEd+iXmBvUP3WHxSjFH/vIsA0EN00cgr8w==",
                "engines": {
                    "node": "*"
                }
            }
        }
    } -->
    <!-- added 1 package in 7s -->
    <!-- 提示：在项目同级目录下会创建一个 node_modules 文件夹，就是导入的包（JS Package 类似于后端的JAR包）。 -->
    <!-- 提示：其下级目录为刚下载的 moment 模块，目录就是 moment。 -->
    <!-- 提示：配置文件（模块完整包：.package-lock.json）。 -->
    <!-- 提示：配置文件（模块版本：.package.json）。 -->
    <!-- package-lock.json -->
    <!-- {
        "name": "html5-css3-javascript",
        "lockfileVersion": 2,
        "requires": true,
        "packages": {
          "": {
            "dependencies": {
              "moment": "^2.29.4"
            }
          },
          "node_modules/moment": {
            "version": "2.29.4",
            "resolved": "https://registry.npmmirror.com/moment/-/moment-2.29.4.tgz",
            "integrity": "sha512-5LC9SOxjSc2HF6vO2CyuTDNivEdoz2IvyJJGj6X8DJ0eFyfszE0QiEd+iXmBvUP3WHxSjFH/vIsA0EN00cgr8w==",
            "engines": {
              "node": "*"
            }
          }
        },
        "dependencies": {
          "moment": {
            "version": "2.29.4",
            "resolved": "https://registry.npmmirror.com/moment/-/moment-2.29.4.tgz",
            "integrity": "sha512-5LC9SOxjSc2HF6vO2CyuTDNivEdoz2IvyJJGj6X8DJ0eFyfszE0QiEd+iXmBvUP3WHxSjFH/vIsA0EN00cgr8w=="
          }
        }
    } -->
    <!-- package.json -->
    <!-- {
        "dependencies": {
          "moment": "^2.29.4"
        }
    } -->

    <!-- 6.5 包的语义人版本规范 -->
    <!-- 包的版本号是以"点分十进制"形式进行定义的，总共有三位数字，例如：2.24.0。 -->
    <!-- 其中每一位数字 -->
    <!-- 包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0 -->
    <!-- 其中每一位数字所代表的的含义如下： -->
    <!-- 第1位数字：大版本。 -->
    <!-- 第2位数字：功能版本。 -->
    <!-- 第3位数字：bug 修复版本。 -->
    <!-- 版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。 -->

    <!-- 6.6 包管理配置文件 -->
    <!-- npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。 -->
    <!-- 例如： -->
    <!-- 项目的名称、版本号、描述等等。 -->
    <!-- 项目中都用到了哪些包。 -->
    <!-- 哪些包只在开发期间会用到。 -->
    <!-- 哪些包在开发和部署时都需要用到。 -->
    <!-- (1).多人协作问题？ -->
    <!-- 整个项目的体积是 30.4M -->
    <!-- 第三方包的体积是 28.8M -->
    <!-- 项目源代码的体积 1.6M -->
    <!-- 遇到的问题：第三方包的体积过大，不方便团队成员之间共享项目源代码。 -->
    <!-- 解决方案：共享时剔除 node_modules。 -->
    <!-- (2).如何记录项目中安装了哪些包？ -->
    <!-- 在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。 -->
    <!-- 从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。 -->
    <!-- 注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。 -->
    <!-- # npm config get registry -->
    <!-- # npm config set registry=https://registry.npm.taobao.org/ -->
    <!-- # npm config get registry -->
    <!-- # npm install moment -->
    <!-- # npm install jquery art-template -->
    <!-- # npm install --save-dev webpack -->
    <!-- # npm install webpack -D -->
    <!-- # npm install webpack -g -->
    <!-- # npm uninstall moment -->
    <!-- # npm uninstall jquery art-template -->
    <!-- # npm uninstall webpack -g -->
    <!-- # yarn add webpack --dev -->
    <!-- (3).快速创建 package.json -->
    <!-- npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件： -->
    <!-- // 作用：在执行命令所处的目录中，快速新建 package.json 文件 -->
    <!-- # npm init -y -->
    <!-- 注意： -->
    <!-- 上述命令只能在英文的目录下成功运行。所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 -->
    <!-- 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。 -->

    <!-- 6.7 devDependencies 节点 -->
    <!-- package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。 -->
    <!-- 如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。 -->
    <!-- 与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。 -->
    <!-- 语法一： -->
    <!-- # npm install --save-dev webpack -->
    <!-- 语法二： -->
    <!-- # npm install webpack -D -->
    <!-- package.json -->
    <!-- {
        "dependencies": {
          "art-template": "^4.13.2",
          "jquery": "^3.7.0",
          "moment": "^2.29.4"
        },
        "devDependencies": {
          "webpack": "^5.82.1"
        }
    } -->
    <!-- 注意：节点一（dependencies）。 -->
    <!-- 注意：节点二（devDependencies）。 -->
    <!-- 当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。 -->
    <!-- 否则会报类似于下面的错误： -->
    <!-- 一次性安装所有的包，可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包。 -->
    <!-- 卸载包： -->
    <!-- // 使用 npm uninstall 完整的包名 -->
    <!-- # npm uninstall moment -->
    <!-- 可以运行 npm uninstall 命令，来卸载指定的包。 -->
    <!-- 注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。 -->

    <!-- 6.8 解决下包速度慢的问题 -->
    <!-- (1).为什么下包速度慢？ -->
    <!-- 在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。 -->
    <!-- 扩展阅读 - 海底光缆： -->
    <!-- https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830 -->
    <!-- https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363 -->
    <!-- https://baike.baidu.com/item/APG/23647721?fr=aladdin -->
    <!-- (2).淘宝 npm 镜像服务器? -->
    <!-- 淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。 -->
    <!-- 扩展： -->
    <!-- 镜像（Mirroring）是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。 -->
    <!-- (3).切换 npm 的下包镜像源？ -->
    <!-- 下包的镜像源，指的就是下包的服务器地址。 -->
    <!-- // 查看当前的下包镜像源 -->
    <!-- # npm config get registry -->
    <!-- // 修改下包镜像源 -->
    <!-- # npm config set registry=https://registry.npm.taobao.org/ -->
    <!-- // 再次查看新的下包镜像源 -->
    <!-- # npm config get registry -->
    <!-- (4).nrm 工具（后面还有 nvm 工具） -->
    <!-- (1).nrm 是管理 npm 源的，为了下载包更快的工具。 -->
    <!-- // 通过 npm 包管理器，将 nrm 安装为全局可用的工具 -->
    <!-- # npm install nrm -g -->
    <!-- // 查看所有可用的镜像源 -->
    <!-- # npm ls -->
    <!-- // 将下包的镜像源切换为 taobao 镜像 -->
    <!-- # nrm use taobao -->
    <!-- 总结：这个工具可有可无，无非就是让你简写输入切换镜像源地址而已。细心一点输入完整的镜像源就行了。 -->
    <!-- (2).nvm 是管理多个 node 版本的工具。 -->
    <!-- #  -->
    <!-- #  -->
    <!-- #  -->
    <!-- 总结：这个才是重点，负责管理所有版本 -->

    <!-- 6.9 包的分类 -->
    <!-- 使用 npm 包管理工具下载的包，共分为两大类，分别是： -->
    <!-- (1).项目包。 -->
    <!-- (2).全局包。 -->
    <!-- (1).项目包 -->
    <!-- 那些被安装到项目的 node_modules 目录中的包，都是项目包。 -->
    <!-- 项目包又分为两类，分别是： -->
    <!-- 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）。 -->
    <!-- 核心依赖包（被记录到    dependencies 节点中的包，在开发期间和项目上线之后都会用到）。 -->
    <!-- # npm install packageName -D   // 开发依赖包（会被 记录到 devDependencies 节点下） -->
    <!-- # npm install packageName      // 核心依赖包（会被 记录到 dependencies 节点下） -->
    <!-- (2).全局包 -->
    <!-- 在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。 -->
    <!-- 全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。 -->
    <!-- 注意： -->
    <!-- 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 -->
    <!-- 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。 -->
    <!-- # npm install packageName -D   // 开发依赖包（会被 记录到 devDependencies 节点下） -->
    <!-- # npm install packageName      // 核心依赖包（会被 记录到 dependencies 节点下） -->
    <!-- # npm install packageName -g   // 全局安装指定的包 -->
    <!-- # npm uninstall packageName -g // 卸载全局安装指定的包 -->
    <!-- (3).i5ting_toc 包 -->
    <!-- i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下： -->

    <!-- 6.10 规范的包的结构 -->
    <!-- 在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。 -->
    <!-- 一个规范的包，它的组成结构，必须符合以下 3 点要求： -->
    <!-- (1).包必须以单独的目录而存在。 -->
    <!-- (2).包的顶级目录下要必须包含（package.json）这个包管理配置文件。 -->
    <!-- (3).package.json 中必须包含（name、version、main）这三个属性，分别代表包的（名字、版本号、包）的入口。 -->
    <!-- 注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/zh-Hans/docs/package-json -->

    <!-- 6.11 开发属于自己的包 -->
    <!-- (1).需要实现的功能 -->
    <!-- 格式化日期。 -->
    <!-- 转义 HTML 中的特殊字符。 -->
    <!-- 还原 HTML 中的特殊字符。 -->
    <!-- <script>
        const packageName = require('package-name');
        const dt = packageName.dataFormat(new Date());
        console.log(dt);
        const htmlStr = '<h1 style="color:skyblue;">你好<span>西蒙</span></h1>';
        const str = packageName.htmlEscape(htmlStr);
        console.log(str);
    </script> -->
    <!-- 2.初始化包的基本结构 -->
    <!-- 新建 itheima-tools 文件夹，作为包的根目录。在 itheima-tools 文件夹中，新建如下三个文件： -->
    <!-- index.js     包的入口文件。 -->
    <!-- package.json 包的管理配置文件。 -->
    <!-- README.md    包的说明文档。 -->
    <!-- (1).初始化 package.json -->
    <!-- {
        "name": "package-name",
        "version": "1.0.0",
        "main": "index.js",
        "description": "提供了哪些功能属性，和功能方法。",
        "keywords": ["username", "dateFormat", "escape"],
        "license": "ISC"
    } -->
    <!-- (2).在 index.js 中定义格式化时间的方法 -->
    <!-- <script>
        // 定义或者赋值给共享对象
        module.exports = {
            dateFormat,
            htmlEscape
        };
        // 封装公共函数（格式化时间）
        function dateFormat(dateStr) {
            const dt = new Date(dateStr);
            const ye = dt.getFullYear();
            const mo = zeroFill(dt.getMonth());
            const da = zeroFill(dt.getDate());
            const hh = zeroFill(dt.getHours());
            const mm = zeroFill(dt.getMinutes());
            const ss = zeroFill(dt.getSeconds());
            return `${ye}-${mo}-${da} ${hh}:${mm}:${ss}`;
        }
        // 封装公共函数（补零）
        function zeroFill(number) {
            return number > 9 ? number : '0' + number;
        }
    </script> -->
    <!-- (3).在 index.js 中定义还原 html 的方法 -->
    <!-- <script>
        function htmlEscape(htmlStr) {
            const regExp = /<|>|"&/g;
            return htmlStr.replace(regExp, function (match) {
                switch (match) {
                    case '<':
                        return '&lt;';
                    case '>':
                        return '&gt;';
                    case '"':
                        return '&quot;';
                    case '&':
                        return '&amp;'; 
                }
            });
        }
    </script> -->
    <!-- (4).README.md 文件编写 -->
    <!-- 包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown 的格式写出来，方便用户参考。 -->
    <!-- README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。 -->
    <!-- 我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容： -->
    <!-- 安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议。 -->
    <!-- 
        ## 安装
        npm install package-name
        ## 导入
        const packageName = require('package-name');
        ## 提供内容（格式化时间）
        const dt = dateFormat(new Date());
        console.log(dt);
        ## 提供内容（转义字符）
        ... 
        ## 提供内容（其他）
    -->
    <!-- (5).将不同的功能进行模块拆分 -->
    <!-- 将格式化时间的功能，拆分到 src -> dateFormat.js 中。 -->
    <!-- 将处理 HTML 字符串的功能，拆分到 src -> htmlEscape.js 中。 -->
    <!-- 在 index.js 中，导入两个模块，得到需要向外共享的方法。 -->
    <!-- 在 index.js 中，使用 module.exports 把对应的方法共享出去。 -->

    <!-- 6.12 发布包 -->
    <!-- (1).注册 npm 账号 -->
    <!-- 访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面。 -->
    <!-- 填写账号相关的信息：Full Name、Public Email、Username、Password。 -->
    <!-- 点击 Create an Account 按钮，注册账号。 -->
    <!-- 登录邮箱，点击验证链接，进行账号的验证。 -->
    <!-- (2).登录 npm 账号 -->
    <!-- npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。 -->
    <!-- 注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败。 -->
    <!-- (3).把包发布到 npm 上 -->
    <!-- 将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。 -->
    <!-- (4).删除已发布的包 -->
    <!-- 运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。 -->
    <!-- 注意： -->
    <!-- npm unpublish 命令只能删除 72 小时以内发布的包。 -->
    <!-- npm unpublish 删除的包，在 24 小时内不允许重复发布。 -->
    <!-- 发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包。 -->

    <!-- 七、模块的加载机制 -->
    <!-- 7.1 优先从缓存中加载 -->
    <!-- 模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。 -->
    <!-- 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。 -->
    <!-- 7.2 内置模块的加载机制 -->
    <!-- 内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。 -->
    <!-- 例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。 -->
    <!-- 7.3 自定义模块的加载机制 -->
    <!-- 使用 require() 加载自定义模块时，必须指定以（./ 或 ../）开头的路径标识符。在加载自定义模块时，如果没有指定（./ 或 ../）。  -->
    <!-- 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。 -->
    <!-- 同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件： -->
    <!-- (1).按照确切的文件名进行加载。 -->
    <!-- (2).补全 .js   扩展名进行加载。 -->
    <!-- (3).补全 .json 扩展名进行加载。 -->
    <!-- (4).补全 .node 扩展名进行加载。 -->
    <!-- (5).加载失败，终端报错。 -->
    <!-- 7.4 第三方模块的加载机制 -->
    <!-- 如果传递给 require() 的模块标识符不是一个内置模块，也没有以（./ 或 ../）开头，则 Node.js 会从当前模块的父目录开始，尝试从（/node_modules）文件夹中加载第三方模块。 -->
    <!-- 如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。 -->
    <!-- 例如，假设在 'C:\Users\path\project\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找： -->
    <!-- C:\Users\path\project\node_modules\tools -->
    <!-- C:\Users\path\node_modules\tools -->
    <!-- C:\Users\node_modules\tools -->
    <!-- C:\node_modules\tools -->
    <!-- 7.5 目录作为模块 -->
    <!-- 当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式： -->
    <!-- (1).在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口。 -->
    <!-- (2).如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 -->
    <!-- (3).如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'package-name'。 -->

    <!-- 八、Express -->
    <!-- 8.1 Express 初识 -->
    <!-- (1).Express 概念 -->
    <!-- 官方的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 -->
    <!-- 通俗的理解：Express 作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。 -->
    <!-- Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。 -->
    <!-- Express 的中文官网： http://www.expressjs.com.cn/ -->
    <!-- (2).Express 理解 -->
    <!-- 思考：不使用 Express 能否创建 Web 服务器？ -->
    <!-- 答案：能，使用 Node.js 提供的原生 http 模块即可。 -->
    <!-- 思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？ -->
    <!-- 答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。 -->
    <!-- 思考：http 内置模块与 Express 是什么关系？ -->
    <!-- 答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。 -->
    <!-- (3).Express 作用 -->
    <!-- 对于前端程序员来说，最常见的两种服务器，分别是： -->
    <!-- 1).Web 网站服务器：专门对外提供 Web 网页资源的服务器。 -->
    <!-- 2).API 接口服务器：专门对外提供 API 接口的服务器。 -->
    <!-- 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。 -->
    <!-- (4).Express 安装 -->
    <!-- 在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用： -->
    <!-- # npm install express@4.17.1 -->
    <!-- (5).Express 创建 -->
    <!-- // 0.下载Express依赖包 -->
    <!-- // PS D:\workspace-vscode\nodejs> npm install express@4.17.1 -->
    <!-- // added 58 packages in 6s -->
    <!-- 
    <script>
        // 1.导入Express依赖包
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 3.监听 get 请求
        app.get('/select', function (request, response) {
            // 3.1 获取请求参数静态 json 数据
            const json = request.query;
            console.log(json);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 3.监听 get 请求（Request URL: http://localhost:8080/selectBid/10086）
        app.get('/selectBid/:id', function (request, response) {
            // 3.2 获取请求参数动态 :id 数据
            const dynamicParam = request.params;
            console.log(dynamicParam);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 3.监听 post 请求
        app.post('/insert', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- (5).Express 创建 -->
    <!-- // 0.下载依赖包 -->
    <!-- // PS D:\workspace-vscode\nodejs> npm install express -->
    <!-- // added 58 packages in 6s -->
    <!-- (5).Express 监听get请求 -->
    <!-- 通过 app.get() 方法，可以监听到客户端的get请求，具体的语法格式如下。 -->
    <!-- app.get('请求URL', function(request, response) { /*处理函数*/ }); -->
    <!-- (5).Express 监听post请求 -->
    <!-- 通过 app.post() 方法，可以监听到客户端的post请求，具体的语法格式如下。 -->
    <!-- app.post('请求URL', function(request, response) { /*处理函数*/ }); -->
    <!-- (5).Express 响应内容到客户端 -->
    <!-- 通过 response.send() 方法，可以把处理好的内容，发送给客户端。 -->
    <!-- app.get('/select', function (request, response) { response.send(200); }); -->
    <!-- (6).Express 获取URL中携带的查询参数 -->
    <!-- 通过 request.query 对象属性，可以访问到客户端通过查询字符串的形式，发送到服务器的参数。 -->
    <!-- app.get('/select', function (request, response) { const user = request.query; }); -->
    <!-- (7).Express 获取URL中的动态参数 -->
    <!-- 通过 request.params 对象属性，可以访问到URL中，通过冒号（:）匹配到的动态参数。 -->
    <!-- app.get('/selectById/:id', function (request, response) { const id = request.params; }); -->
    <!-- 
    <script>
        // 1.导入 express
        const express = require('express');
        // 2.创建 web 服务器实例
        const app = express();
        // 4.启动 web 服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 3.监听 get 请求
        app.get('/select', function (request, response) {
            // 3.1 获取请求参数静态 json 数据
            const json = request.query;
            console.log(json);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 3.监听 get 请求（Request URL: http://localhost:8080/selectBid/10086）
        app.get('/selectBid/:id', function (request, response) {
            // 3.2 获取请求参数动态 :id 数据
            const dynamicParam = request.params;
            console.log(dynamicParam);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 3.监听 post 请求
        app.post('/insert', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 通过 response.send(); 方法，可以把处理好的内容发送给客户端。 -->
    <!-- 通过 response.query;  属性，可以访问到客户端通过查询字符串的形式，发送到服务器的参数。 -->
    <!-- 通过 response.params; 属性，可以访问到 URL 中通过冒号（:）匹配到的动态参数。 -->

    <!-- 8.2 Express 静态托管资源 -->
    <!-- (1).express.static() -->
    <!-- express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器。 -->
    <!-- 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了： -->
    <!-- 现在，你就可以访问 public 目录中的所有文件了： -->
    <!-- http://localhost:3000/images/bg.jpg -->
    <!-- http://localhost:3000/css/style.css -->
    <!-- http://localhost:3000/js/login.js -->
    <!-- 注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL中。 -->
    <!-- (2).托管多个静态资源目录 -->
    <!-- 如果要托管多个静态资源目录，请多次调用 express.static() 函数： -->
    <!-- 访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。 -->
    <!-- (3).挂载路径前缀 -->
    <!-- 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式： -->
    <!-- 现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了： -->
    <!-- http://localhost:3000/public/images/kitten.jpg -->
    <!-- http://localhost:3000/public/css/style.css -->
    <!-- http://localhost:3000/public/js/app.js -->
    <!-- (5).Express 创建 -->
    <!-- 下载依赖包 -->
    <!-- # npm install express -->
    <!-- added 58 packages in 6s -->
    <!-- (5).Express 监听get请求 -->
    <!-- 通过 app.get() 方法，可以监听到客户端的get请求，具体的语法格式如下。 -->
    <!-- app.get('请求URL', function(request, response) { /*处理函数*/ }); -->
    <!-- (5).Express 监听post请求 -->
    <!-- 通过 app.post() 方法，可以监听到客户端的post请求，具体的语法格式如下。 -->
    <!-- app.post('请求URL', function(request, response) { /*处理函数*/ }); -->
    <!-- (5).Express 响应内容到客户端 -->
    <!-- 通过 response.send() 方法，可以把处理好的内容，发送给客户端。 -->
    <!-- app.get('/select', function (request, response) { response.send(200); }); -->
    <!-- (6).Express 获取URL中携带的查询参数 -->
    <!-- 通过 request.query 对象属性，可以访问到客户端通过查询字符串的形式，发送到服务器的参数。 -->
    <!-- app.get('/select', function (request, response) { const user = request.query; }); -->
    <!-- (7).Express 获取URL中的动态参数 -->
    <!-- 通过 request.params 对象属性，可以访问到URL中，通过冒号（:）匹配到的动态参数。 -->
    <!-- app.get('/selectById/:id', function (request, response) { const id = request.params; }); -->
    <!-- (8).Express 托管静态资源 -->
    <!-- 通过 express.static() 对象方法，通过它我们可以非常方便地创建一个静态资源服务器。 -->
    <!-- app.use(express.static('public')); -->
    <!-- 如果要托管多个静态资源目录，请多次调用express.static()方法即可。 -->
    <!-- 访问静态资源文件时，express.static()函数会根据目录的添加顺序查找所需要的文件。 -->
    <!-- (9).Express 挂载路径前缀 -->
    <!-- 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式。 -->
    <!-- app.use('./public', express.static('images')); -->
    <!-- app.use('./public', express.static('css')); -->
    <!-- app.use('./public', express.static('js')); -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        app.use('./public', express.static('images'));
        app.use('./public', express.static('css'));
        app.use('./public', express.static('js'));
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听 get 请求
        app.get('/select', function (request, response) {
            // 5.1 获取请求参数静态 json 数据
            const json = request.query;
            console.log(json);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 5.监听 get 请求（Request URL: http://localhost:8080/selectBid/10086）
        app.get('/selectBid/:id', function (request, response) {
            // 5.2 获取请求参数动态 :id 数据
            const dynamicParam = request.params;
            console.log(dynamicParam);
            response.send({name: "Brendan Eich", age: 38, gender: "GG"});
        });
        // 5.监听 post 请求
        app.post('/insert', function (request, response) {
            response.send(200);
        });
    </script> -->

    <!-- 8.3 nodemon -->
    <!-- 1. 为什么要使用 nodemon -->
    <!-- 在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。 -->
    <!-- 现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。 -->
    <!-- 2. 安装 nodemon -->
    <!-- 在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具： -->
    <!-- 3. 使用 nodemon -->
    <!-- 当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。 -->
    <!-- 这样做的坏处是：代码被修改之后，需要手动重启项目。 -->
    <!-- 现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。 -->
    <!-- 这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。 -->
    <!-- # npm install -g nodemon -->

    <!-- 8.4 Express 路由（Route） -->
    <!-- 路由的概念： -->
    <!-- 1. 什么是路由？ -->
    <!-- 广义上来讲，路由就是映射关系。 -->
    <!-- 2. 现实生活中的路由？ -->
    <!-- 按键 1 -> 业务查询 -->
    <!-- 按键 2 -> 手机充值 -->
    <!-- 按键 3 -> 业务办理 -->
    <!-- 按键 4 -> 密码服务与停复机 -->
    <!-- 按键 5 -> 家庭宽带 -->
    <!-- 按键 6 -> 话费流量 -->
    <!-- 按键 8 -> 集团业务 -->
    <!-- 按键 0 -> 人工服务 -->
    <!-- 3. Express 中的路由（Route） -->
    <!-- 在 Express 中的路由指的是客户端的请求与服务器处理函数之间的映射关系。 -->
    <!-- 在 Express 中的路由分 3 部分组成，分别是：请求的类型、请求的URL地址、处理函数。格式如下： -->
    <!-- app.METHOD(PATH, HANDLER); -->
    <!-- app === express() === require('express') -->
    <!-- METHOD === get || post -->
    <!-- PATH === '/select' -->
    <!-- HANDLER === function () {} -->
    <!-- 注册路由模块： -->
    <!-- // 1.导入路由模块 -->
    <!-- const routers = require('./node-router.js'); -->
    <!-- // 2.使用app.use()函数注册路由模块 -->
    <!-- app.use(routers); -->
    <!-- 4. Express 中的路由的例子 -->
    <!-- // 匹配get请求，并且请求url地址是select -->
    <!-- app.get('/select', function (request, response) { const id = request.query; response.sed(id); }); -->
    <!-- // 匹配post请求，并且请求url地址是update -->
    <!-- app.post('/update', function (request, response) { response.send(200); }); -->
    <!-- 5. 路由的匹配过程 -->
    <!-- 每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。 -->
    <!-- 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express会将这次请求，转交给对应的function()函数进行处理。 -->
    <!-- 路由匹配的注意点： -->
    <!-- 1).按照定义的先后顺序进行匹配。 -->
    <!-- 2).请求类型和请求的URL同时匹配成功，才会调用对应的处理函数。 -->
    <!-- 路由的使用： -->
    <!-- 1. 最简单的用法 -->
    <!-- 在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下： -->
    <!-- app.get('/select', function (request, response) { const id = request.query; }); -->
    <!-- app.post('/update', function (request, response) { response.send(200); }); -->
    <!-- 2. 模块化路由 -->
    <!-- 为了方便对路由进行模块化的管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块。 -->
    <!-- 将路由抽离为单独模块的步骤如下： -->
    <!-- 1).创建路由模块对应的.js文件。 -->
    <!-- 2).调用express.Router()函数创建路由对象。 -->
    <!-- 3).向路由对象上挂载具体的路由。 -->
    <!-- 4).使用module.exports向外共享路由对象。 -->
    <!-- 5).使用app.use()函数注册路由模块。 -->
    <!-- 3. 创建路由模块。 -->
    <!-- // 导入路由模块 -->
    <!-- const routers = require('./node-router.js'); -->
    <!-- 4. 注册路由模块。 -->
    <!-- // 使用app.use()函数注册路由模块 -->
    <!-- app.use(routers); -->
    <!-- 5. 为路由模块添加前缀。 -->
    <!-- 类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单： -->
    <!-- app.use('/api', routers); -->
    <!-- 具体实例： -->
    <!-- node-router.js -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        // 2.创建路由模块
        const router = express.Router();
        // 5.监听get请求
        router.get('/select', function (request, response) {
            const query = request.query;
            console.log(query)
            response.send(query);
        });
        // 5.监听get请求
        router.get('/select/:id', function (request, response) {
            const param = request.params;
            console.log(param);
            response.send(param);
        });
        // 5.监听post请求
        router.post('/update', function (request, response) {
            response.send(200);
        });
        // 6.向外导出路由对象（共享成员）
        module.exports = router;
    </script> -->
    <!-- node-app.js -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        app.use('./public', express.static('images'));
        app.use('./public', express.static('css'));
        app.use('./public', express.static('js'));
        const routers = require('./node-js-11');
        app.use(routers);
        app.use('/api', routers);
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
    </script> -->
    
    <!-- 8.5 Express 中间件 -->
    <!-- Express 中间件概念： -->
    <!-- 1. 什么是中间件 -->
    <!-- 中间件（Middleware ），特指业务流程的中间处理环节。 -->
    <!-- 2. 现实生活中的例子 -->
    <!-- 在处理污水的时候，一般都要经过三个处理环节，从而保证处理过后的废水，达到排放标准。 -->
    <!-- 处理污水的这三个中间处理环节，就可以叫做中间件。 -->
    <!-- 3. Express 中间件的调用流程 -->
    <!-- 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。 -->
    <!-- 4. Express 中间件的格式 -->
    <!-- Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下： -->
    <!-- const express = require('express'); -->
    <!-- const app = express(); -->
    <!-- app.get('/', function (request, response, next) {}); -->
    <!-- app.listen(3000); -->
    <!-- 注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 request 和 response。 -->
    <!-- 5. next 函数的作用 -->
    <!-- next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。 -->
    <!-- Express 中间件体验： -->
    <!-- 1. 定义中间件函数 -->
    <!-- 可以通过如下的方式，定义一个最简单的中间件函数： -->
    <!-- // 常量 mw 所指向的就是一个中间件函数 -->
    <!-- const mw = function (request, response, next) { console.log('这是一个最简单的中间件函数'); next(); } -->
    <!-- // i注意：在当前中间件的业务处理完毕后，必须调用 next() 函数。 -->
    <!-- // 表示把流转关系转交给下一个中间件或者路由。 -->
    <!-- <script>
        const express = require('express');
        const app = express();
        const mw = function (request, response, next) {
            console.log(`这是最简单的中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        }
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
    </script> -->
    <!-- 2. 全局生效的中间件 -->
    <!-- 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。 -->
    <!-- 通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下： -->
    <!-- <script>
        const express = require('express');
        const app = express();
        const mw = function (request, response, next) {
            console.log(`这是最简单的中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        }
        // 全局生效的中间件
        app.use(mw);
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        app.get('/select', function (request, response) {
            response.send(200);
        });
        app.post('/update', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 3. 定义全局中间件的简化形式 -->
    <!-- <script>
        app.use(function (request, response, next) {
            console.log(`这是最简单的中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        });
    </script> -->
    <!-- 4. 中间件的作用 -->
    <!-- 多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。 -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        app.use(function (request, response, next) {
            request.statusMessage = 'LiuWeiWei';
            next();
        });
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听get请求
        app.get('/select', function (request, response) {
            const query = request.query;
            console.log(query)
            const message = request.statusMessage;
            response.send(message);
        });
        // 5.监听get请求
        app.get('/select/:id', function (request, response) {
            const param = request.params;
            console.log(param);
            const message = request.statusMessage;
            response.send(message);
        });
        // 5.监听post请求
        app.post('/update', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 5. 定义多个全局中间件 -->
    <!-- 可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下： -->
    <!-- <script>
        app.use(function (request, response, next) {
            console.log(`这是调用的第一个中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        });
        app.use(function (request, response, next) {
            console.log(`这是调用的第二个中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        });
        app.get('/select', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 6. 局部生效的中间件 -->
    <!-- 不使用 app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下： -->
    <!-- <script>
        const mw = function (request, response, next) {
            console.log(`这是最简单的中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        }
        app.get('/select2', mv, function (request, response) {
            response.send(200);
        });
        app.get('/select4', function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 7. 定义多个局部中间件 -->
    <!-- 可以在路由中，通过如下两种等价的方式，使用多个局部中间件： -->
    <!-- // 以下两种写法是"完全等价"的，可根据自己的喜欢，选择任意一种方式进行使用。 -->
    <!-- <script>
        const mw = function (request, response, next) {
            console.log(`这是调用的第一种中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        }
        const mw2 = function (request, response, next) {
            console.log(`这是调用的第二种中间件函数`);
            // 把流转关系，转交给下一个中间件或者路由
            next();
        }
        app.get('/select2', mv, function (request, response) {
            response.send(200);
        });
        app.get('/select4', mv2, function (request, response) {
            response.send(200);
        });
        app.get('/select6', [mv, mv2], function (request, response) {
            response.send(200);
        });
    </script> -->
    <!-- 8. 了解中间件的5个使用注意事项 -->
    <!-- 1).一定要在【路由之前】注册中间件。 -->
    <!-- 2).客户端发送过来的请求，可以【连续调用多个】中间件进行处理。 -->
    <!-- 3).执行完中间件的业务代码之后，不要忘记【调用 next() 函数】。 -->
    <!-- 4).为了防止代码逻辑混乱，调用【 next() 函数后不要再写额外】的代码。 -->
    <!-- 5).连续调用多个中间件时，多个中间件之间，【共享】 request 和 response 对象。 -->
    <!-- // 0.下载Express依赖包 -->
    <!-- // 1.导入Express依赖包 -->
    <!-- // 2.创建web服务器实例 -->
    <!-- // 3.对外提供静态资源（用来注册全局路由或者中间件的） -->
    <!-- // 4.启动web服务器实例 -->
    <!-- // 5.监听get请求（路由） -->
    <!-- // 5.监听post请求（路由） -->
    <!-- 9. Express 中间件分类 -->
    <!-- 为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是： -->
    <!-- (1).【应用级别】的中间件。 -->
    <!-- (2).【路由级别】的中间件。 -->
    <!-- (3).【错误级别】的中间件。 -->
    <!-- (4).【Express内置】的中间件。 -->
    <!-- (5).【第三方】的中间件。 -->
    <!-- 1. 应用级别的中间件 -->
    <!-- 通过 app.use() 或 app.get() 或 app.post() 绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下： -->
    <!-- // 全局中间件 -->
    <!-- app.use(function (request, response, next) { next(); }); -->
    <!-- // 局部中间件 -->
    <!-- app.get('/select', mv, function (request, response) { response.send(200); }); -->
    <!-- 2. 路由级别的中间件 -->
    <!-- 绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。 -->
    <!-- 只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下： -->
    <!-- var express = require('express'); -->
    <!-- var app = express(); -->
    <!-- var routers = express.Router(); -->
    <!-- routers.use(function (request, response, next) { next(); }); -->
    <!-- app.use('/select', routers); -->
    <!-- 3. 错误级别的中间件 -->
    <!-- 错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 -->
    <!-- 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。 -->
    <!-- 注意：错误级别的中间件，必须注册在所有路由（Router）之后哈。其它中间件都注册在路由（Router）之前哈。 -->
    <!-- app.get('/select', function (error, request, response, next) { next(); }); -->
    <!-- app.use(function (error, request, response, next) { next(); }); -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        const mw = function (request, response, next) {
            request.statusMessage = 'LiuWeiWei';
            next();
        };
        const mvErr = function (request, response, next) {
            throw new Error(`服务器内部发生的错误信息`);
        }
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听get请求
        app.get('/select/error', mvErr, function (error, request, response, next) {
            console.log(error.message);
        });
    </script> -->
    <!-- 4. Express内置的中间件 -->
    <!-- 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： -->
    <!-- 1).express.static     快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）。 -->
    <!-- 2).express.json       解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）。 -->
    <!-- 3).express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）。 -->
    <!-- // 配置解析 application/json 格式数据的中间件 -->
    <!-- app.use(express.json()); -->
    <!-- // 配置解析 application/x-www-form-urlencoded 格式数据的内置中间件 -->
    <!-- app.use(express.urlencoded( {extended: false; } )); -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        // 3.解析表单中的json格式的数据
        app.use(express.json());
        // 3.解析表单中的url-encoded格式的数据
        app.use(express.urlencoded({extended:false}));
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听post请求
        app.post('/update', function (request, response) {
            console.log(request.body);
            response.send(200);
        });
    </script> -->
    <!-- 5. 第三方的中间件 -->
    <!-- 非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。 -->
    <!-- 例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下： -->
    <!-- 1).运行 npm install body-parser 安装中间件。 -->
    <!-- 2).使用 require 导入中间件。 -->
    <!-- 3).调用 app.use() 注册并使用中间件。 -->
    <!-- 注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。 -->
    <!-- <script>
        // 0.下载Express依赖包
        // PS D:\workspace-vscode\nodejs> npm install express
        // added 58 packages in 6s
        // 1.导入Express
        const express = require('express');
        const parsers = require('body-parser');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        // 3.解析表单中的json格式的数据
        app.use(express.json());
        // 3.解析表单中的url-encoded格式的数据
        app.use(express.urlencoded({extended:false}));
        app.use(parsers.urlencoded({extended:false}));
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听post请求
        app.post('/update', function (request, response) {
            console.log(request.body);
            response.send(200);
        });
    </script> -->
    <!-- 10. 自定义中间件 -->
    <!-- 1. 需求描述与实现步骤 -->
    <!-- 自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。 -->
    <!-- 实现步骤： -->
    <!-- 1).定义中间件。 -->
    <!-- 2).监听 request 的 data 事件。 -->
    <!-- 3).监听 request 的 end 事件。 -->
    <!-- 4).使用 querystring 模块解析请求体数据。 -->
    <!-- 5).将解析出来的数据对象挂载为 req.body。 -->
    <!-- 6).将自定义中间件封装为模块。 -->
    <!-- 2. 定义中间件 -->
    <!-- 使用 app.use() 来定义全局生效的中间件，代码如下： -->
    <!-- app.use(function (request, response, next) { //中间件的业务逻辑 }); -->
    <!-- 3. 监听 request 的 data 事件 -->
    <!-- 在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。 -->
    <!-- 如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。 -->
    <!-- 所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。 -->
    <!-- // 定义变量，用来存储客户端发送过来的请求数据 -->
    <!-- const str = ''; -->
    <!-- // 监听 request 对象的data事件，客户端发送过来新的请求数据 -->
    <!-- // 拼接请求体数据，隐式转换为字符串 -->
    <!-- request.on('data', function (chunk) { str += chunk; }); -->
    <!-- 4. 监听 request 的 end 事件 -->
    <!-- 当请求体数据接收完毕之后，会自动触发 req 的 end 事件。 -->
    <!-- 因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下： -->
    <!-- request.on('end', function () { console.log(str); }); -->
    <!-- 5. 使用 querystring 模块解析请求体数据 -->
    <!-- Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下： -->
    <!-- // 导入处理querystring的node.js内置模块 -->
    <!-- const qs = require('querystring'); -->
    <!-- // 调用qs.parse()方法，把查询字符串解析为对象 -->
    <!-- const body = qs.parse(str); -->
    <!-- 6. 将解析出来的数据对象挂载为 req.body -->
    <!-- 上游的中间件和下游的中间件及路由之间，共享同一份 request 和 response。因此，我们可以将解析出来的数据，挂载为 request 的自定义属性，命名为 req.body，供下游使用。示例代码如下： -->
    <!-- request.on('end', function () {const body = qs.parse(str); request.body = body; next(); }); -->
    <!-- 7. 将自定义中间件封装为模块 -->
    <!-- 为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下： -->
    <!-- const qs = require('querystring'); -->
    <!-- function bodyParse(request, response, next) { //省略其它代码 }; -->
    <!-- module.exports=bodyParser; -->
    <!-- const bodyParser = require('custom-body-parser.js'); -->
    <!-- app.use(bodyParser); -->
    <!-- 自定义中间件完整实例： -->
    <!-- custom-body-parser.js -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const qs = require('querystring');
        // 3.自定义解析表单数据的中间件
        const bodyParser = function (request, response, next) {
            let str = '';
            request.on('data', function (chunk) {
                str += chunk;
            });
            request.on('end', function () {
                console.log(str);
                const body = qs.parse(str);
                console.log(body);
                request.body = body;
                next();
            });
        };
        // 4.导出成员变量或者成员方法
        module.exports = bodyParser;
    </script> -->
    <!-- node-js-18.js -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        const bodyParser = require('./node-js-17');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        // 3.解析表单中的json格式的数据
        app.use(express.json());
        // 3.解析表单中的url-encoded格式的数据
        app.use(express.urlencoded({extended:false}));
        // 4.将自定义的中间件函数注册为全局可以的中间件
        app.use(bodyParser);
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听post请求
        app.post('/update', function (request, response) {
            console.log(request.body);
            response.send(200);
        });
    </script> -->

    <!-- 8.6 Express 写接口 -->
    <!-- 4.1 创建基本的服务器 -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
    </script> -->
    <!-- 4.2 创建 API 路由模块 -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        // 2.创建路由模块
        const router = express.Router();
        // 6.向外导出路由对象（共享成员）
        module.exports = router;
    </script> -->
    <!-- 4.3 编写 GET 接口 -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 2.创建路由模块
        const router = express.Router();
        // 3.把路由模块注册到app应用上
        app.use('/api', router);
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听get请求（路由模式）
        router.get('/select', function (request, response, next) {
            const query = request.query;
            response.send({
                status: 0,
                message: 'Request successful!',
                data: query
            });
            console.log(200);
        });
        // 6.对外共享成员变量或者成员方法
        module.exports = router;
    </script> -->
    <!-- 4.4 编写 POST 接口 -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        // 2.创建web服务器实例
        const app = express();
        // 2.创建路由模块
        const router = express.Router();
        // 3.解析表单中的json格式的数据
        app.use(express.json());
        // 3.解析表单中的url-encoded格式的数据
        app.use(express.urlencoded({extended:false}));
        // 3.把路由模块注册到app应用上
        app.use('/api', router);
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听post请求（路由模式）
        router.post('/insert', function (request, response, next) {
            const body = request.body;
            response.send({
                status: 200,
                message: "Request successful!",
                data: body
            });
            console.log(200);
        });
        // 6.对外共享成员变量或者成员方法
        module.exports = router;
    </script> -->

    <!-- 4.5 CORS 跨域资源共享 -->
    <!-- 1. 接口的跨域问题 -->
    <!-- 刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。 -->
    <!-- 解决接口跨域问题的方案主要有两种： -->
    <!-- 1).CORS  主流的解决方案，推荐使用。 -->
    <!-- 2).JSONP 有缺陷的解决方案：只支持 GET 请求。 -->
    <!-- 2. 使用 cors 中间件解决跨域问题 -->
    <!-- cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 -->
    <!-- 使用步骤分为如下 3 步： -->
    <!-- 1).运行 npm install cors 安装中间件。 -->
    <!-- 2).使用 const cors = require('cors') 导入中间件。 -->
    <!-- 3).在路由之前调用 app.use(cors()) 配置中间件。 -->
    <!-- 3. 什么是 CORS -->
    <!-- CORS（Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。 -->
    <!-- 浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。 -->
    <!-- 4. CORS 的注意事项 -->
    <!-- 1).CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 -->
    <!-- 2).CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。 -->
    <!-- 5. CORS 响应头部：Access-Control-Allow-Origin -->
    <!-- 响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: -->
    <!-- 其中，origin 参数的值指定了允许访问该资源的外域 URL。 -->
    <!-- 例如，下面的字段值将只允许来自 http://itcast.cn 的请求： -->
    <!-- 5. CORS 响应头部：Access-Control-Allow-Origin -->
    <!-- 如果指定了 Access-Control-Allow-Origin 字段的值为通配符 *，表示允许来自任何域的请求，示例代码如下： -->
    <!-- 6. CORS 响应头部：Access-Control-Allow-Headers -->
    <!-- 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： -->
    <!-- Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type。 -->
    <!-- 只有三个值：application/x-www-form、urlencoded、multipart/form-data、text/plain。 -->
    <!-- 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败。 -->
    <!-- 7. CORS 响应头部：Access-Control-Allow-Methods -->
    <!-- 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 -->
    <!-- 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 -->
    <!-- 示例代码如下： -->
    <!-- // 指定请求类型 -->
    <!-- response.setHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, HEAD'); -->
    <!-- // 允许任何请求类型 -->
    <!-- response.setHeader('Access-Control-Allow-Methods', '*'); -->
    <!-- 8. CORS请求的分类 -->
    <!-- 客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是： -->
    <!-- (1).简单请求。 -->
    <!-- (2).预检请求。 -->
    <!-- 9. 简单请求 -->
    <!-- 同时满足以下两大条件的请求，就属于简单请求： -->
    <!-- 1).请求方式：GET、POST、HEAD 三者之一。 -->
    <!-- 2).HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type。 -->
    <!-- 只有三个值：application/x-www-form、urlencoded、multipart/form-data、text/plain。 -->
    <!-- 10. 预检请求 -->
    <!-- 只要符合以下任何一个条件的请求，都需要进行预检请求： -->
    <!-- 1).请求方式为【 GET、POST、HEAD 之外的请求 Method 类型】。 -->
    <!-- 2).请求头中【包含自定义头部字段】。 -->
    <!-- 3).向服务器发送了【 application/json 格式的数据】。 -->
    <!-- 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。 -->
    <!-- 11. 简单请求和预检请求的区别 -->
    <!-- 简单请求的特点：客户端与服务器之间只会发生一次请求。 -->
    <!-- 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。 -->
    <!-- 实例：CORS 跨域解决 -->
    <!-- 前端.html -->
    <!-- 
    <script src="./js/jquery-3.5.1.js"></script>
    <button id="btn-get">这是get请求</button>
    <button id="btn-post">这是post请求</button>
    <script type="text/javascript">
        // Access to XMLHttpRequest at 'http://localhost:8080/select' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
        // GET http://localhost:8080/select net::ERR_FAILED 404 (Not Found)
        $(document).ready(function () {
            $("#btn-get").on('click', function () {
                $.ajax({
                    url: 'http://localhost:8080/select',
                    async: true,
                    data: '',
                    type: 'GET',
                    dataType: 'text',
                    success: function (data) {
                        console.log(data);
                    },
                    error: function () {
                        console.log(500);
                    }
                });
            });
        });
    </script> -->
    <!-- 后端.js -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // # npm install cors
        // 1.导入Express模块
        const express = require('express');
        const cors = require('cors');
        // 2.创建web服务器实例
        const app = express();
        // 3.解决跨域问题
        app.use(cors());
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听get请求
        app.get('/select', function (request, response, next) {
            response.send(200);
            console.log(200);
        });
        // 5.监听post请求
        app.post('/update', function (request, response) {
            console.log(request.body);
            response.send(200);
        });
    </script> -->
    
    <!-- 4.6 JSONP 接口 -->
    <!-- 1. 回顾 JSONP 的概念与特点 -->
    <!-- 概念：浏览器端通过 <script> 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。 -->
    <!-- 特点： -->
    <!-- 1).JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。 -->
    <!-- 2).JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。 -->
    <!-- 2. 创建 JSONP 接口的注意事项 -->
    <!-- 如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下： -->
    <!-- 3. 实现 JSONP 接口的步骤 -->
    <!-- 1).获取客户端发送过来的回调函数的名字。 -->
    <!-- 2).得到要通过 JSONP 形式发送给客户端的数据。 -->
    <!-- 3).根据前两步得到的数据，拼接出一个函数调用的字符串。 -->
    <!-- 4).把上一步拼接得到的字符串，响应给客户端的 <script> 标签进行解析执行。 -->
    <!-- 4. 实现 JSONP 接口的具体代码。 -->
    <!-- 5. 在网页中使用 jQuery 发起 JSONP 请求。 -->
    <!-- 调用 $.ajax() 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下： -->
    <!-- app.use('/api/jsonp', function (request, response) { //定义JSONP接口具体的实现接口 }); -->
    <!-- // 5.监听get请求
    app.get('/api/query', function (request, response, next) {
        const callbackName = request.query.callback;
        const data = {username: 'LiuWeiWei', password: '12345678'};
        const scriptStr = `${callbackName}(${JSON.stringify(data)})`;
        response.send(scriptStr);
    }); -->
    <!-- <script type="text/javascript">
        // Access to XMLHttpRequest at 'http://localhost:8080/select' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
        // GET http://localhost:8080/select net::ERR_FAILED 404 (Not Found)
        $(document).ready(function () {
            console.log(`jquery version: ` + $.fn.jquery);
        });
        $("#btn-get").on('click', function () {
                $.ajax({
                    url: 'http://localhost:8080/select',
                    async: true,
                    data: '',
                    type: 'GET',
                    dataType: 'jsonp',
                    success: function (data) {
                        console.log(data);
                    },
                    error: function () {
                        console.log(500);
                    }
                });
            });
    </script> -->

    <!-- 九、数据库与身份认证 -->
    <!-- 能够知道如何配置mysql数据库环境 -->
    <!-- 能够认识并且使用常见的sql语句操作数据库 -->
    <!-- 能够在express中操作mysql数据库 -->
    <!-- 能够了解Session实现原理 -->
    <!-- 能够了解jwt实现原理 -->

    <!-- 4.1 在项目中操作数据库的步骤 -->
    <!-- 1).安装操作mysql数据库的第三方模块（mysql）。 -->
    <!-- mysql模块是托管于npm上的第三方模块。 -->
    <!-- mysql模块它提供了在node.js项目中的链接和操作mysql数据库的能力。 -->
    <!-- # npm install mysql -->
    <!-- 2).通过mysql模块连接到Mysql数据库。 -->
    <!-- 在使用mysql模块操作mysql数据库之前，必须先对mysql模块进行必要的配置，主要的配置步骤如下： -->
    <!-- const mysql = require('mysql'); -->
    <!-- const db = mysql.createPool({host:'127.0.0.1', user:'root', password:'12345678', database:'mysql'}); -->
    <!-- 3).通过mysql模块执行sql语句。 -->
    <!-- 测试mysql模块连接数据库是否成功。 -->
    <!-- 调用db.query()函数，指定要执行的sql语句，通过回调函数拿到执行的结果。 -->
    <!-- 查询语句： -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const mysql = require('mysql');
        // 2.创建mysql数据库连接池
        const db = mysql.createPool({
            host: 'localhost',
            user: 'root',
            password: '12345678',
            database: 'other'
        });
        // 3.编写sql脚本
        const sqlStr = 'SELECT * FROM tb_user WHERE 1=1;';
        // 4.执行sql语句
        db.query(sqlStr, function (error, results) {
            if (error) {
                console.log(error.message);
            } else {
                console.log(results);
            }
        });
    </script> -->
    <!-- 新增语句： -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const mysql = require('mysql');
        // 2.创建mysql数据库连接池
        const db = mysql.createPool({
            host: 'localhost',
            user: 'root',
            password: '12345678',
            database: 'other'
        });
        // 3.编写sql脚本
        const addSql = 'INSERT INTO tb_user (username, password) VALUES (?, ?);';
        const addVal = {username:'LiuWeiWei', password:'12345678'};
        // 4.执行sql语句
        db.query(addSql, [addVal.username, addVal.password], function (error, results) {
            if (error) {
                console.log(error.message);
            } else {
                if (results.affectedRows === 1) {
                    console.log(results);
                } else {
                    console.log(500);
                }
            }
        });
    </script> -->
    <!-- 3).插入数据的便捷方式。 -->
    <!-- 向表中新增数据时，如果数据是对象的每个属性，和数据库字段一一对应，则可以通过如下方式快速插入数据。 -->
    <!-- const user = {username:'liuweiwei', password:'12345678'}; -->
    <!-- const sqls = 'INSERT INTO tb_user SET ?;'; -->
    <!-- db.query(sqls, user, function (error, results) {if(error){console.log(error.message);}}); -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const mysql = require('mysql');
        // 2.创建mysql数据库连接池
        const db = mysql.createPool({
            host: 'localhost',
            user: 'root',
            password: '12345678',
            database: 'other'
        });
        // 3.编写sql脚本
        const addSql = 'INSERT INTO tb_user SET ?;';
        const addVal = {username:'liuweiwei', password:'12345678'};
        // 4.执行sql语句
        db.query(addSql, addVal, function (error, results) {
            if (error) {
                console.log(error.message);
            } else {
                if (results.affectedRows === 1) {
                    console.log(results);
                } else {
                    console.log(500);
                }
            }
        });
    </script> -->
    <!-- 删除语句： -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const mysql = require('mysql');
        // 2.创建mysql数据库连接池
        const db = mysql.createPool({
            host: 'localhost',
            user: 'root',
            password: '12345678',
            database: 'other'
        });
        // 3.编写sql脚本
        const delSql = 'DELETE FROM tb_user WHERE id=?;';
        const delVal = {id:'10086'};
        // 4.执行sql语句
        db.query(delSql, [delVal.id], function (error, results) {
            if (error) {
                console.log(error.message);
            } else {
                if (results.affectedRows === 1) {
                    console.log(results);
                } else {
                    console.log(500);
                }
            }
        });
    </script> -->
    <!-- 更新语句： -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const mysql = require('mysql');
        // 2.创建mysql数据库连接池
        const db = mysql.createPool({
            host: 'localhost',
            user: 'root',
            password: '12345678',
            database: 'other'
        });
        // 3.编写sql脚本
        const updSql = 'UPDATE tb_user SET username=?, password=? WHERE id=?;';
        const updVal = {username:'LiuWeiWei', password:'12345678', id:'10086'};
        // 4.执行sql语句
        db.query(updSql, [updVal.username, updVal.password, updVal.id], function (error, results) {
            if (error) {
                console.log(error.message);
            } else {
                if (results.affectedRows === 1) {
                    console.log(results);
                } else {
                    console.log(500);
                }
            }
        });
    </script> -->

    <!-- 5.1 Web 开发模式 -->
    <!-- 目前主流的 Web 开发模式有两种，分别是： -->
    <!-- 1).基于服务端渲染的传统web开发模式。 -->
    <!-- 2).基于前后端分离的新型web开发模式。 -->
    <!-- 1.服务端渲染的web开发模式 -->
    <!-- 服务端渲染的概念，服务器发送给客户端的html页面，是在服务器通过字符中的拼接，动态生成的。 -->
    <!-- 因此，客户端不需要使用ajax这样的技术额外请求页面的数据。代码示例如下： -->
    <!-- const user = {username:'LiuWeiWei', password:'12345678'}; -->
    <!-- const html = `<p>姓名：${user.username}，密码：${user.password}</p>`; -->
    <!-- app.get('/index.html', function (request, response) { response.send(html); }); -->
    <!-- 2.服务端渲染的优缺点 -->
    <!-- 优点： -->
    <!-- 1).前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 -->
    <!-- 2).有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 -->
    <!-- 缺点： -->
    <!-- 1).占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 -->
    <!-- 2).不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。     -->
    <!-- 3.前后端分离的 Web 开发模式 -->
    <!-- 前后端分离的概念：前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。 -->
    <!-- 简而言之，前后端分离的 Web 开发模式，就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式。 -->
    <!-- 4.前后端分离的优缺点 -->
    <!-- 优点： -->
    <!-- 1).开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。 -->
    <!-- 2).用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。 -->
    <!-- 3).减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 -->
    <!-- 缺点： -->
    <!-- 1).不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。 -->
    <!-- 2).解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！ -->
    <!-- 5.如何选择web开发模式 -->
    <!-- 1).不谈业务场景而盲目选择使用何种开发模式都是耍流氓。 -->
    <!-- 2).比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染； -->
    <!-- 3).而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。 -->
    <!-- 4).另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。 -->
    
    <!-- 5.2 身份认证 -->
    <!-- 1. 什么是身份认证 -->
    <!-- 1).身份认证（Authentication）又称【身份验证】、【鉴权】，是指通过一定的手段，完成对用户身份的确认。 -->
    <!-- 2).日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。 -->
    <!-- 3).在 Web 开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。 -->
    <!-- 2. 为什么需要身份认证 -->
    <!-- 1).身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。例如，你去找快递员取快递，你要怎么证明这份快递是你的。 -->
    <!-- 2).在互联网项目开发中，如何对用户的身份进行认证，是一个值得深入探讨的问题。例如，如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。 -->
    <!-- 3. 不同开发模式下的身份认证 -->
    <!-- 对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案： -->
    <!-- 1).服务端渲染推荐使用 【Session 认证机制】。 -->
    <!-- 2).前后端分离推荐使用 【JWT 认证机制】。 -->

    <!-- 5.3 Session 认证机制 -->
    <!-- 1. HTTP 协议的无状态性 -->
    <!-- 了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。 -->
    <!-- HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。 -->
    <!-- 2. 如何突破 HTTP 无状态的限制 -->
    <!-- 对于超市来说，为了方便收银员在进行结算时给 VIP 用户打折，超市可以为每个 VIP 用户发放会员卡。 -->
    <!-- 注意：现实生活中的会员卡身份认证方式，在 Web 开发中的专业术语叫做 Cookie。 -->
    <!-- 3. 什么是 Cookie -->
    <!-- Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 -->
    <!-- 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。 -->
    <!-- Cookie的几大特性： -->
    <!-- 1).自动发送。 -->
    <!-- 2).域名独立。 -->
    <!-- 3).过期时限。 -->
    <!-- 4).4KB限制。 -->
    <!-- 4. Cookie 在身份认证中的作用 -->
    <!-- 客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。 -->
    <!-- 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。 -->
    <!-- 5. Cookie 不具有安全性 -->
    <!-- 由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。 -->
    <!-- 因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。 -->
    <!-- 注意：千万不要使用 Cookie 存储重要且隐私的数据。比如用户的身份信息、密码等。 -->
    <!-- 6. 提高身份认证的安全性 -->
    <!-- 为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡，才能被正常使用。 -->
    <!-- 这种（会员卡 + 刷卡认证）的设计理念，就是 Session 认证机制的精髓。 -->
    <!-- 7. Session 的工作原理 -->
    <!-- 浏览器，客户端登录，提交账号和密码到服务器。 -->
    <!-- 服务器，验证账号和密码，将登录成功后的信息存储在服务器的内存中，同时生成对应的Cookie字符串，将生成的Cookie响应给客户端。 -->
    <!-- 浏览器，自动把Cookie存储在当前域名下。 -->
    <!-- 浏览器，客户端再次发起请求时，通过请求头自动把当前域名下所有可用的Cookie发送给服务器。 -->
    <!-- 服务器，根据请求头中携带的Cookie，从内存中查找对应的用户信息。 -->
    <!-- 服务器，用户的认证成功后，服务器针对当前用户生成特定的响应内容。 -->
    <!-- 服务器，响应把当前用户对应的页面内容响应给浏览器。 -->

    <!-- 5.4 在 Express 中使用 Session 认证 -->
    <!-- 1. 安装 express-session 中间件 -->
    <!-- 在 Express 项目中，只需要安装 express-session 中间件，即可在项目中使用 Session 认证： -->
    <!-- # npm install express-session -->
    <!-- 2. 配置 express-session 中间件 -->
    <!-- express-session 中间件安装成功后，需要通过 app.use() 来注册 session 中间件，示例代码如下： -->
    <!-- const session = require('express-session'); -->
    <!-- app.use(session({secret:'keyboard cat', resave: false, saveUninitialized: true})); -->
    <!-- 3. 向 session 中存数据 -->
    <!-- 当 express-session 中间件配置成功后，即可通过 req.session 来访问和使用 session 对象，从而存储用户的关键信息： -->
    <!-- app.post('/api/login', function (request, response) {
            if (request.body.username !== 'admin' || request.body.password !== '123456') {
                return response.send({status: 1, message: `Login failed!`});
            }
            request.session.user = request.body;
            request.session.islogin = true;
            response.send({status: 0, message: `Login succeeded!`});
        });
    -->
    <!-- 4. 从 session 中取数据 -->
    <!-- 可以直接从 req.session 对象上获取之前存储的数据，示例代码如下： -->
    <!-- app.get('/api/username', function (request, response) {
            if (!request.session.islogin) {
                return response.send({status: 1, message: `Login failed!`});
            }
            response.send({status: 0, message: 'Login succeeded!', username: request.session.user.username});
        });
    -->
    <!-- 5. 清空 session -->
    <!-- 调用 req.session.destroy() 函数，即可清空服务器保存的 session 信息。 -->
    <!-- app.post('/api/logout', function (request, response) {
            request.session.destroy();
            response.send({status: 0, message: `Logout succeeded!`});
        });
    -->
    <!-- 完整实例： -->
    <!-- <script>
        // 0.下载Express依赖包
        // # npm install express
        // 1.导入Express模块
        const express = require('express');
        const session = require('express-session');
        // 2.创建web服务器实例
        const app = express();
        // 3.对外提供静态资源（用来注册全局中间件的）
        app.use(express.static('./public'));
        app.use(express.static('./static'));
        // 3.解析表单中的json格式的数据
        app.use(express.json());
        // 3.解析表单中的url-encoded格式的数据
        app.use(express.urlencoded({extended:false}));
        // 3.注册会话session中间件
        app.use(session({
            secret: 'keyboard cat',
            resave: false,
            saveUninitialized: true
        }));
        // 4.启动web服务器实例
        app.listen(8080, function () {
            console.log(`express server running at http://localhost:8080/`);
        });
        // 5.监听get请求
        app.get('/api/username', function (request, response) {
            if (!request.session.islogin) {
                return response.send({status: 1, message: `Login failed!`});
            }
            response.send({status: 0, message: 'Login succeeded!', username: request.session.user.username});
        });
        // 5.监听post请求
        app.post('/api/login', function (request, response) {
            if (request.body.username !== 'admin' || request.body.password !== '123456') {
                return response.send({status: 1, message: `Login failed!`});
            }
            request.session.user = request.body;
            request.session.islogin = true;
            response.send({status: 0, message: `Login succeeded!`});
        });
        // 5.监听get请求
        app.post('/api/logout', function (request, response) {
            request.session.destroy();
            response.send({status: 0, message: `Logout succeeded!`});
        });
    </script> -->
    
    <!-- 5.5 JWT 认证机制 -->
    <!-- 1.了解 Session 认证的局限性 -->
    <!-- Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 -->
    <!-- 注意： -->
    <!-- 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 -->
    <!-- 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。 -->
    <!-- 2. 什么是 JWT -->
    <!-- JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。 -->
    <!-- 3. JWT 的工作原理 -->
    <!-- 浏览器，客户端登录，提交账号和密码。 -->
    <!-- 服务器，验证账号和密码，验证通过之后，将用户的信息对象，经过加密之后生成Token字符串。 -->
    <!-- 服务器，响应将生成的Token发送给客户端。 -->
    <!-- 浏览器，将Token存储到LocalStorage或者SessionStorage对象当中。 -->
    <!-- 浏览器，客户端再次发起请求时，通过请求头的Authorization字段，将Token发送给服务器。 -->
    <!-- 服务器，把Token字符串还原成用户的信息对象，用户的身份认证成功后，服务器针对当前用户生成特定的响应内容。 -->
    <!-- 服务器，响应把当前用户对应的页面内容响应给浏览器。 -->
    <!-- 总结：用户的信息通过Token字符串的形成，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。 -->
    <!-- 4. JWT 的组成部分 -->
    <!-- JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。 -->
    <!-- 三者之间使用英文的点号（"."）分隔，格式如下： -->
    <!-- Header.Payload.Signature -->
    <!-- 头部.有效荷载.签名 -->
    <!-- 下面是 JWT 字符串的示例： -->
    <!-- 6. JWT 的三个部分各自代表的含义 -->
    <!-- JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。 -->
    <!-- 其中： -->
    <!-- Header     部分只是安全性相关的部分，只是为了保证 Token 的安全性。 -->
    <!-- Payload    部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 -->
    <!-- Signature  部分只是安全性相关的部分，只是为了保证 Token 的安全性。 -->
    <!-- 7. JWT 的使用方式 -->
    <!-- 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。 -->
    <!-- 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP  -->
    <!-- 请求头的 Authorization 字段中，格式如下： -->
    <!-- Authorization: Bearer <token> -->

    <!-- 5.6 在 Express 中使用 JWT -->
    <!-- 1. 安装 JWT 相关的包 -->
    <!-- 运行如下命令，安装如下两个 JWT 相关的包： -->
    <!-- # npm install jsonwebtoken  -->
    <!-- # npm install express-jwt -->
    <!-- 其中： -->
    <!-- (1).jsonwebtoken 用于生成 JWT 字符串。 -->
    <!-- (2).express-jwt  用于再将 JWT 字符串解析还原成 JSON 对象。 -->
    <!-- 2. 导入 JWT 相关的包 -->
    <!-- 使用 require() 函数，分别导入 JWT 相关的两个包： -->
    <!-- const jwt = require('jsonwebtoken'); -->
    <!-- const expressJWT = require('express-jwt'); -->
    <!-- 3. 定义 secret 密钥 -->
    <!-- 为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的 secret 密钥。 -->
    <!-- (1).当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串。 -->
    <!-- (2).当再把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密。 -->
    <!-- const secretKey = 'Lww@1234'; -->
    <!-- 4. 在登录成功后生成 JWT 字符串 -->
    <!-- 调用 jsonwebtoken 包提供的 sign() 方法，将用户的信息加密成 JWT 字符串，响应给客户端： -->
    <!-- app.post('/api/login', function (request, response) {
        response.send({
            status: 200,
            message: `Login succeeded!`,
            token: jwt.sign({username:user.username}, secretKey, {expiresIn:'30s'})
        })
    }); -->
    <!-- 5. 将 JWT 字符串还原为 JSON 对象 -->
    <!-- 客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证。 -->
    <!-- 此时，服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象： -->
    <!-- // 使用 app.use() 函数来注册中间件 -->
    <!-- // 使用 expressJWT( {secret:secretKey} ) 函数就是来解析Token的中间件  -->
    <!-- // 使用 unless( {path:[/^\/api\//]} ) 函数用来指定哪些接口不需要访问权限 -->
    <!-- app.use(expressJWT({secret: secretKey}).unless({path: [/^\/api\//]})); -->
    <!-- 6. 使用 req.user 获取用户信息 -->
    <!-- 当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息了， -->
    <!-- 示例代码如下： -->
    <!-- app.get('/api/getinfo', function (request, response) {
        console.log(request.user);
        response.send({
            status: 200,
            message: `Get user information succeeded!`,
            data: request.user
        });
    }); -->
    <!-- 7. 捕获解析 JWT 失败后产生的错误 -->
    <!-- 当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。 -->
    <!-- 我们可以通过 Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下： -->
    <!-- app.use(function (error, request, response, next) {
        if (error.name === 'UnauthorizedError') {
            return response.send({
                status: 400,
                message: `Invalid Token!`
            });
        }
        response.send({
            status: 500,
            message: `Internal error!`
        });
    }); -->




</body>

</html>