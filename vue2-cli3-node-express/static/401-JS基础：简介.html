<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS基础：简介</title>
</head>

<body>
    <!-- JS 部分 -->

    <!-- JS 作用 -->
    <!-- 网页特效(监听用户的一些行为让网页作出对应的反馈) -->
    <!-- 表单验证(针对表单数据的合法性进行判断) -->
    <!-- 数据交互(获取后台的数据渲染到前端) -->
    <!-- 服务端编程(node.js) -->
    <!-- JS 组成 -->
    <!-- ECMAScript: 规定了js基础语法核心知识。比如：变量、分支语句、循环语句、对象等等。 -->
    <!-- Web APIs DOM: 操作文档。比如对页面元素进行移动、大小、添加删除等操作。 -->
    <!-- Web APIs BOM: 操作浏览器。比如页面弹窗，检测窗口宽度、存储数据到浏览器等等。 -->
    <!-- JS 用法 -->
    <!-- 使用 内联的 JavaScript 函数。 -->
    <!-- 使用 <head>或者<body>中的 JavaScript 函数。 -->
    <!-- 使用 外部的 JavaScript 函数。 -->
    <!-- JS 注释 -->
    <!-- 使用 //    开头的单行注释。快捷键：Ctrl + /。 -->
    <!-- 使用 /* */ 包裹的多行注释。快捷键：Shift + Ctrl + A。 -->
    <!-- JS 结束符 -->
    <!-- 使用 分号（;）为结束符。换行为默认结束符。 -->
    <!-- JS 字面量 -->
    <!-- 使用 3.14 为数字字面量。 -->
    <!-- 使用 双引号"白马王子" 单引号'黑马攻城狮' 为字符串字面量。 -->
    <!-- 使用 大括号对象 {} 中括号数组 [] 尖括号标签<> 等等字面量。 -->
    <!-- JS 输入/输出 -->
    <!-- 使用 window.prompt()   方法显示可提示用户输入的对话框。 -->
    <!-- 使用 element.innerHTML 属性写入到 HTML 元素。 -->
    <!-- 使用 window.alert()    方法弹出警告框。 -->
    <!-- 使用 document.write()  方法将内容写到 HTML 文档中。 -->
    <!-- 使用 console.log()     方法写入到浏览器的控制台。 -->
    <!-- JS 变量 -->
    <!-- 使用 var   关键字声明的变量。在函数外声明作用域是全局变量，在函数内声明作用域是局部变量。变量必须以字母开头，变量也能以（$）和（_）符号开头，变量名称对大小写敏感。 -->
    <!-- 使用 let   关键字定义的限定范围内作用域的变量。只在 let 命令所在的代码块内有效。 -->
    <!-- 使用 const 关键字来定义一个常量。一旦声明，常量的值就不能改变。 -->
    <!-- JS 数据类型 -->
    <!-- 使用 number    基础数据类型赋值的是数字类型。JS 中的正数、负数、小数等等统一称为数字类型。 -->
    <!-- 使用 string    基础数据类型赋值的是字符串类型。通过单引号（''）、双引号（""）或反引号（``）包裹的数据都叫字符串类型。 -->
    <!-- 使用 boolean   基础数据类型赋值的是布尔类型。布尔（逻辑）类型只能有两个值真（true）或假（false）。 -->
    <!-- 使用 undefined 基础数据类型返回值的是未定义类型。只声明变量，不赋值的情况下，变量的默认值为 undefined 这个值表示变量不含有值。 -->
    <!-- 使用 null      基础数据类型返回值的是空值类型。可以通过将变量的值设置为 null 来清空变量。 -->
    <!-- 使用 object    引用数据类型返回的值是对象。对象由花括号（{}）分隔，对象属性以名称和值对的形式（Key:Value）来定义，属性之间由逗号（,）分隔。 -->
    <!-- 使用 array     引用数据类型返回的值是数组。数组由中括号（[]）分隔，每个值之间由逗号（,）分隔。返回也是对象：object。 -->
    <!-- 使用 function  引用数据类型返回的值是函数。函数就是包裹在花括号中的代码块，前面使用了关键词 function。 -->
    <!-- JS 运算符 -->
    <!-- 使用 + - * / %            符号来表示数学运算符（算术运算符），主要包括加、减、乘、除、取余（求模）。 -->
    <!-- 使用 = += -= *= /= %=     符号来表示赋值运算符，对变量进行赋值的运算符。 -->
    <!-- 使用 > < >= <= == === !== 符号来表示比较运算符，比较两个数据大小、是否相等。 -->
    <!-- 使用 i++ ++i i-- --i      符号来表示一元运算符，能够使用一元运算符做自增（自减）运算。 -->
    <!-- 使用 && ||                符号来表示逻辑运算符，逻辑运算符用来解决多重条件判断。 -->
    <!-- JS 分支/循环 -->
    <!-- 使用 if (condition) { }                                   语句只有当指定条件为 true 时，使用该语句来执行代码。 -->
    <!-- 使用 if (condition) { } else { }                          语句当条件为 true 时执行代码，当条件为 false 时执行其他代码。 -->
    <!-- 使用 if (condition) { } else if (condition) else {}       语句使用该语句来选择多个代码块之一来执行。 -->
    <!-- 使用 switch (key) {case value: break; default: break;}    语句用于基于不同的条件来执行不同的动作。 -->
    <!-- 使用 while (condition) { }                                语句只要指定条件为 true，循环就可以一直执行代码块。 -->
    <!-- 使用 do { } while (condition);                            语句循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。 -->
    <!-- 使用 for (let i = 0; i < array.length; i++) { array[i]; } 语句循环代码块一定的次数。 -->
    <!-- 使用 array.forEach(element => { });                       语句循环代码块一定的次数。 -->
    <!-- 使用 for (const key in object) { object[key]; }           语句循环遍历对象的属性。 -->
    <!-- 使用 for (const iterator of object) { }                   语句循环遍历对象的属性。 -->
    <!-- JS 数组 -->
    <!-- 使用 array = new Array();                                 语句创建数组，基于 new 关键字。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- 使用 array = [];                                          语句创建数组，基于中括号 []。数组是一种可以按顺序保存数据的数据类型。 -->
    <!-- JS 操作符 -->
    <!-- 使用 typeof                                               操作符来检测变量的数据类型。 -->
    <!-- 使用 typeof                                               操作符来检测 null 是一个只有一个值的特殊类型。表示一个空对象引用。会返回 object。 -->
    <!-- 使用 typeof                                               操作检测一个没有设置值的变量。会返回 undefined。 -->
    <!-- JS 类型转换 -->
    <!-- 隐式转换：某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 -->
    <!-- 显式转换：为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 -->
    <!-- 使用 Number(x)                                            方法将字符串转换成数字类型。 -->
    <!-- 使用 parseInt(x)                                          方法将字符串转换成数字类型。 -->
    <!-- 使用 parseFloat(x)                                        方法将字符串转换成数字类型。 -->
    <!-- 使用 String(x)                                            方法将其他类型转换成字符串类型。 -->
    <!-- 使用 x.toString()                                         方法将其他类型转换成字符串类型。 -->
    <!-- JS 正则表达式 -->
    <!-- 语法 /正则表达式主体/修饰符(可选)                           正则表达式（Regular Expression）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 -->
    <!-- 使用 s.search(/RegExp/i)                                  正则表达式搜索 RegExp 字符串，且不区分大小写。 -->
    <!-- 使用 s.replace(/RegExp/i, "RegularExpression")            正则表达式且不区分大小写将字符串中的 RegExp 替换为 RegularExpression。 -->
    <!-- 使用 i                                                    修饰符执行对大小写不敏感的匹配。 -->
    <!-- 使用 g                                                    修饰符执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 -->
    <!-- 使用 m                                                    修饰符执行多行匹配。 -->
    <!-- 使用 [abc]                                                表达式查找方括号之间的任何字符。 -->
    <!-- 使用 [0-9]                                                表达式查找任何从 0 至 9 的数字。 -->
    <!-- 使用 (x|y)                                                表达式查找任何以 | 分隔的选项。 -->
    <!-- 使用 \d                                                   元字符查找数字。 -->
    <!-- 使用 \s                                                   元字符查找空白字符。 -->
    <!-- 使用 \b                                                   元字符匹配单词边界。 -->
    <!-- 使用 \uxxxx                                               元字符查找以十六进制数 xxxx 规定的 Unicode 字符。 -->
    <!-- 使用 n+                                                   量词匹配任何包含至少一个 n 的字符串。 -->
    <!-- 使用 n*                                                   量词匹配任何包含零个或多个 n 的字符串。 -->
    <!-- 使用 n?                                                   量词匹配任何包含零个或一个 n 的字符串。 -->
    <!-- 使用 RegExp                                               对象是一个预定义了属性和方法的正则表达式对象。 -->
    <!-- 使用 test()                                               方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 -->
    <!-- 使用 exec()                                               方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 -->
    <!-- JS 异常 -->
    <!-- 使用 try                                                  语句允许我们定义在执行时进行错误测试的代码块。 -->
    <!-- 使用 catch                                                语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 -->
    <!-- 使用 finally                                              语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 -->
    <!-- 使用 throw                                                语句创建自定义错误。或者叫做创建或者抛出异常（Exception）。 -->
    <!-- JS 关键字 -->
    <!-- 使用 break                                                关键字 -->
    <!-- 使用 continue                                             关键字 -->
    <!-- 使用 return                                               关键字 -->
    <!-- 使用 typeof                                               关键字 -->
    <!-- 使用 this                                                 关键字 -->
    <!-- 使用 var                                                  关键字 -->
    <!-- 使用 let                                                  关键字 -->
    <!-- 使用 const                                                关键字 -->
    <!-- 使用 void                                                 关键字 -->
    <!-- JS 异步编程 -->
    <!-- 同步 sync                                                 相对的概念。 -->
    <!-- 异步 async                                                相对的概念。 -->
    <!-- 使用 Promise                                              对象是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 -->
    <!-- 使用 new Promise(function(resolve, reject){setTimeout(function(){}, 1000);})     异步函数是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。 -->
    <!-- JS 函数 -->
    <!-- 使用 function functionname(parameters) { return parameters; }                    声明函数。函数声明后不会立即执行，会在我们需要的时候调用到。 -->
    <!-- 使用 x = function (a, b) { return a * b; };                                      匿名函数（函数表达式）。函数存储在变量中，不需要函数名称，通常通过变量名来调用。 -->
    <!-- 使用 new Function("a", "b", "return a * b");                                     构造函数。函数同样可以通过内置的 JavaScript 函数构造器 Function() 定义。 -->
    <!-- 使用 (function () { var x = "callback"; })();                                    自调用函数（立即执行函数）。函数表达式可以"自调用"，自调用表达式会自动调用。如果表达式后面紧跟 () 则会自动调用。不能自调用声明的函数。 -->
    <!-- 使用 (function () { var x = "callback"; }());                                    自调用函数（立即执行函数）。函数实际上是一个匿名自我调用的函数（没有函数名）。 -->
    <!-- 使用 (parameters) => { return x * y; }                                           箭头函数。ES6 新增了箭头函数。箭头函数表达式的语法比普通函数表达式更简洁。 -->
    <!-- 使用 function callback() { return a * b; } window.setInterval(callback(), 1000); 回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- 使用 window.addEventListener('click', function () { return a * b; });            回调函数。函数当作参数传递给另外一个函数，这个函数就是回调函数。 -->
    <!-- JS 闭包 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。 -->
    <!-- 使用 x = (function () {var i = 0; return function () {return i += 1;}})();       x 变量可以作为一个函数使用。它 function () {return i += 1;} 可以访问函数上一层作用域的计数器。这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 -->
    <!-- JS 类 -->
    <!-- 使用 class Parent { property: "value", method: function () { } }                 使用 class 关键字来创建一个类，类是用于创建对象的模板。类体在一对大括号 {} 中，在大括号 {} 中定义类成员的位置，如方法或构造函数。每个类中包含了一个特殊的方法 constructor()，它是类的构造函数。这种方法用于创建和初始化一个由 class 创建的对象。 -->
    <!-- 使用 new Parent()                                                                使用 new 关键字来创建对象。创建对象时会自动调用构造函数方法 constructor()。 -->
    <!-- 使用 class Children extends Parent { }                                           使用 extends 关键字继承类。这个已有的类称为基类（父类），新建的类称为派生类（子类）。 -->
    <!-- 使用 static method() { }                                                         使用 static 关键字修改的方法是静态方法，又叫类方法，属于类的，但不属于对象。通过（类名.方法名）调用静态方法。静态方法不能在对象上调用，只能在类中调用。 -->
    <!-- JS 对象 -->
    <!-- 使用 Console 对象提供了浏览器控制台调试的接口。在不同浏览器上它的工作方式可能不一样，但通常都会提供一套共性的功能。 -->

    <!-- 查询官网<MDN>：https://developer.mozilla.org/zh-CN/docs/Web/API/ -->
    <!-- HTML DOM Console 对象 -->
    <!-- Console 对象提供了浏览器控制台调试的接口。在不同浏览器上它的工作方式可能不一样，但通常都会提供一套共性的功能。 -->
    <!-- Properties/Methods                            Description -->
    <!-- console.assert()                              如果第一个参数为 false ，则将消息和堆栈跟踪记录到控制台。 -->
    <!-- console.clear()                               清空控制台，并输出 Console was cleared。 -->
    <!-- console.count()                               以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。 -->
    <!-- console.countReset()                          重置指定标签的计数器值。 -->
    <!-- console.debug()                               在控制台打印一条 "debug" 级别的消息。 -->
    <!-- console.dir()                                 显示一个由特定的 Javascript 对象列表组成的可交互列表。这个列表可以使用三角形隐藏和显示来审查子对象的内容。 -->
    <!-- console.dirxml()                              打印 XML/HTML 元素表示的指定对象，否则显示 JavaScript 对象视图。 -->
    <!-- console.error()                               打印一条错误信息，使用方法可以参考 string substitution。 -->
    <!-- console.exception()                           非标准。已弃用。error() 方法的别称。 -->
    <!-- console.group()                               创建一个新的内联 group, 后续所有打印内容将会以子层级的形式展示。调用 groupEnd()来闭合组。 -->
    <!-- console.groupCollapsed()                      创建一个新的内联 group。使用方法和 group() 相同，不同的是，groupCollapsed() 方法打印出来的内容默认是折叠的。调用groupEnd()来闭合组。 -->
    <!-- console.groupEnd()                            闭合当前内联 group。 -->
    <!-- console.info()                                打印资讯类说明信息，使用方法可以参考 string substitution。 -->
    <!-- console.log()                                 打印内容的通用方法，使用方法可以参考 string substitution。 -->
    <!-- console.profile()                             非标准。 -->
    <!-- console.profileEnd()                          非标准。 -->
    <!-- console.table()                               将列表型的数据打印成表格。 -->
    <!-- console.time()                                启动一个以入参作为特定名称的计时器，在显示页面中可同时运行的计时器上限为 10,000. -->
    <!-- console.timeEnd()                             结束特定的 计时器 并以毫秒打印其从开始到结束所用的时间。 -->
    <!-- console.timeLog()                             打印特定 计时器 所运行的时间。 -->
    <!-- console.timeStamp()                           非标准。添加一个标记到浏览器的 Timeline 或 Waterfall 工具。 -->
    <!-- console.trace()                               输出一个 stack trace。 -->
    <!-- console.warn()                                打印一个警告信息，可以使用 string substitution 和额外的参数。 -->

    <!-- 1.1 什么是 JS -->
    <!-- JavaScript 已经由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化。 -->
    <!-- JavaScript 是 Web 的编程语言。所有现代的 HTML 页面都可以使用 JavaScript。 -->
    <!-- JavaScript 非常容易学。本教程将教你学习从初级到高级 JavaScript 知识。 -->
    <!-- <button type="button" onclick="displayDate()">显示日期</button>
    <p id="demo">点击后显示日期到此处</p>
    <script>
        function displayDate() {
            document.getElementById("demo").innerHTML = Date();
        }
    </script> -->
    <!-- 1.2 为什么学习 JS -->
    <!-- JavaScript 是 web 开发人员必须学习的 3 门语言中的一门： -->
    <!-- (1).HTML 定义了网页的内容。 -->
    <!-- (2).CSS  描述了网页的布局。 -->
    <!-- (3).JS   控制了网页的行为。 -->
    <!-- 1.1 JS 输入流 -->
    <!-- <script>
        // 提示符prompt
        var value = window.prompt('请输入你的数字：');
        console.log(value);
    </script> -->
    <!-- 1.2 JS 输出流 -->
    <!-- 可以识别标签。 -->
    <!-- <script>
        // 写入文档中
        document.write("<h1>这是一个标题</h1>");
        document.write("<p>这是一个段落吧</p>");
        // 警示框
        window.alert('窗口弹出警示框');
        // 控制台
        console.log('控制台输出内容');
    </script> -->
    <!-- 提示：只能在 HTML 输出中使用 document.write，如果您在文档加载后使用该方法，会覆盖整个文档。 -->
    <!-- 1.3 JS 对事件的反应 -->
    <!-- <button type="button" onclick="alert('点击弹出窗口')">点击事件</button> -->
    <!-- 1.4 JS 改变 HTML 内容 -->
    <!-- // 查找元素 -->
    <!-- x = document.getElementById("demo"); -->
    <!-- // 改变内容 -->
    <!-- x.innerHTML = "Hello JavaScript"; -->
    <!-- <button type="button" onclick="myFunction()">点击事件</button>
    <p id="demo">JS 能改变 HTML 元素的内容</p>
    <script>
        function myFunction() {
            var x = document.getElementById("demo");
            x.innerHTML = "Hello JavaScript!";
        }
    </script> -->
    <!-- 1.5 JS 改变 HTML 图像 -->
    <!-- <img id="myimage" onclick="changeImage()" src="/images/pic_bulboff.gif" width="100" height="180">
    <script>
        function changeImage() {
            var element = document.getElementById('myimage');
            if (element.src.match("bulbon")) {
                element.src = "./images/pic_bulboff.gif";
            }
            else {
                element.src = "./images/pic_bulbon.gif";
            }
        }
    </script> -->
    <!-- 1.6 JS 改变 HTML 样式 -->
    <!-- <button type="button" onclick="myFunction()">点击这里</button>
    <p id="demo">JS 能改变 HTML 元素的样式</p>
    <script>
        function myFunction() {
            var element = document.getElementById("demo");
            element.style.color = "#ff0000";
        }
    </script> -->
    <!-- 1.7 JS 验证输入 -->
    <!-- <input id="input" type="text">
    <button type="button" onclick="myFunction()">点击这里</button>
    <script>
        function myFunction() {
            var v = document.getElementById("input").value;
            if (v == "" || isNaN(v)) {
                alert("不是数字");
            } else {
                alert("输入正确");
            }
        }
    </script> -->
    <!-- 以上实例只是普通的验证，如果要在生产环境中使用，需要严格判断，如果输入的空格，或者连续空格 isNaN 是判别不出来的。可以添加正则来判断： -->
    <!-- <input id="demo" type="text">
    <button type="button" onclick="myFunction()">点击这里</button>
    <script>
        function myFunction() {
            var value = document.getElementById("demo").value;
            if (isNaN(value) || value.replace(/(^\s*)|(\s*$)/g, "") == "") {
                alert("不是数字");
            } else {
                alert("就是数字");
            }
        }
    </script> -->

    <!-- 1.1 JS 简介 -->
    <!-- JavaScript 已经由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化。 -->
    <!-- JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 -->
    <!-- JavaScript 是脚本语言： -->
    <!-- JavaScript 是一种轻量级的编程语言。 -->
    <!-- JavaScript 是可插入 HTML 页面的编程代码。 -->
    <!-- JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 -->
    <!-- 1.2 JS 作用 -->
    <!-- 网页特效 (监听用户的一些行为让网页作出对应的反馈) -->
    <!-- 表单验证 (针对表单数据的合法性进行判断) -->
    <!-- 数据交互 (获取后台的数据, 渲染到前端) -->
    <!-- 服务端编程 (node.js) -->
    <!-- 1.3 JS 组成 -->
    <!-- ECMAScript: -->
    <!-- 规定了js基础语法核心知识。 -->
    <!-- 比如：变量、分支语句、循环语句、对象等等。 -->
    <!-- Web APIs: -->
    <!-- DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作。 -->
    <!-- BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等。 -->
    <!-- 1.4 JS 用法（书写位置） -->
    <!-- (1).行内的 JavaScript。 -->
    <!-- (2).<head>或者<body>中的 JavaScript。 -->
    <!-- (3).外部的 JavaScript。 -->
    <!-- 注意：书写的位置尽量写到文档末尾</body>结尾标签前面。 -->
    <!-- 注意：外部 JS 标签中间不要写代码，否则会被忽略。 -->
    <!-- 1.5 JS 结束符 -->
    <!-- (1).代表语句结束。 -->
    <!-- (1).结束符使用英文分号 ; 表示。 -->
    <!-- (1).可写可不写（现在不写结束符的程序员越来越多）。 -->
    <!-- (1).换行符（回车）会被识别成结束符 ,所以一个完整的语句，不要手动换行。 -->
    <!-- (1).因此在实际开发中有许多人主张书写 JavaScript 代码时省略结束符。 -->
    <!-- (1).但为了风格统一，要写结束符就每句都写，要么每句都不写，按照团队要求。 -->
    <!-- 1.6 JS 注释 -->
    <!-- JavaScript 注释可用于提高代码的可读性。 -->
    <!-- JavaScript 不会执行注释。 -->    
    <!-- 我们可以添加注释来对 JavaScript 进行解释，或者提高代码的可读性。 -->
    <!-- 单行注释以 // 开头。快捷键：Ctrl + /。 -->
    <!-- 多行注释以 /* */ 包裹。快捷键：Shift + Ctrl + A。 -->
    <!-- 1.7 JS 字面量 -->
    <!-- 在计算机科学中，字面量（Literal）是在计算机中描述 事与物。 -->
    <!-- 比如：1000 此时 1000 就是数字字面量。 -->
    <!-- 比如：双引号"白马王子" 单引号'黑马攻城狮' 就是字符串字面量。 -->
    <!-- 比如：数组的表达形式对象大括号 {} 数组中括号 [] 标签小括号 <> 字面量等等。 -->
    <!-- 1.8 JS 输入输出 -->
    <!-- (1).输出语法： -->
    <!-- 使用 document.write('') 向 body 内输出内容。如果输出的内容写的是标签，也会被解析成网页元素。 -->
    <!-- 使用 window.alert('') 页面弹出警告对话框。 -->
    <!-- 使用 console.log('') 控制台输出语法，程序员调试使用。 -->
    <!-- (2).输入语法： -->
    <!-- 使用 window.prompt('') 显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字。 -->

    <!-- 一、变量 -->
    <!-- 目标：理解变量是计算机存储数据的"容器"。 -->
    <!-- 思考：怎么理解变量？它的主要作用是什么？ -->
    <!-- 回答：一个容器。用来存储数据的。 -->
    <!-- 思考：变量是通过哪个关键字来声明的变量？如何赋值？ -->
    <!-- 回答：变量通过 let 关键字来声明变量。通过 = 等于号来实现赋值。 -->
    <!-- 回答：变量通过变量名来获得里面的数据。 -->
    <!-- 1.1 JS 声明变量 -->
    <!-- 语法： -->
    <!-- let 变量名; -->
    <!-- 声明变量有两部分构成：声明关键字、变量名（标识）。 -->
    <!-- let 即关键字 (let: 允许、许可、让、要)，所谓关键字是系统提供的专门用来声明（定义）变量的词语。 -->
    <!-- 举例: -->
    <!-- let age; -->
    <!-- age 即变量的名称，也叫标识符。 -->
    <!-- 1.2 JS 变量赋值 -->
    <!-- 定义了一个变量后，你就能够初始化它（赋值）。在变量名之后跟上一个等于号（=），然后是数值。 -->
    <!-- 注意：是通过变量名来获得变量里面的数据。 -->
    <!-- 注意：也可以声明变量的时候同时给变量初始化。 -->
    <!-- let age = 22; -->
    <!-- 1.3 JS 更新变量 -->
    <!-- 变量赋值后，还可以通过简单地给它一个不同的值来更新它。 -->
    <!-- 注意： let 不允许多次声明一个变量。 -->
    <!-- 1.4 JS 声明多个变量 -->
    <!-- 变量赋值后，还可以通过简单地给它一个不同的值来更新它。 -->
    <!-- let age = 22, username = 'pink'; -->
    <!-- 1.5 JS 变量的本质 -->
    <!-- 内存：计算机中存储数据的地方，相当于一个空间。 -->
    <!-- 变量：是程序在内存中申请的一块用来存放数据的小空间。 -->
    <!-- 1.6 JS 变量命名规则与规范 -->
    <!-- 规则：必须遵守，不遵守报错。 -->
    <!-- 规范：建议，不遵守不会报错，但不符合业内通识。 -->
    <!-- (1).规则： -->
    <!-- 不能用关键字。 -->
    <!-- 关键字：有特殊含义的字符，JavaScript 内置的一些英语词汇。例如：let、var、if、for 等等。 -->
    <!-- 只能用下划线、字母、数字、$组成，且数字不能开头。 -->
    <!-- 字母严格区分大小写，如 Age 和 age 是不同的变量。 -->
    <!-- (2).规范： -->
    <!-- 起名要有意义。 -->
    <!-- 遵守小驼峰命名法。 -->
    <!-- 第一个单词首字母小写，后面每个单词首字母大写。例：userName。 -->
    <!-- 1.7 let 和 var 的区别： -->
    <!-- let 为了解决 var 的一些问题。 -->
    <!-- var 声明： -->
    <!-- 可以先使用，再声明（不合理）。 -->
    <!-- var 声明过的变量可以重复声明（不合理）。 -->
    <!-- 比如变量提升、全局变量、没有块级作用域等等。 -->
    <!-- 结论：以后声明变量我们统一使用 let。 -->
    <!-- 1.8 JS 变量拓展 -->
    <!-- 使用 let variable = 22; 声明一个变量。 -->
    <!-- 使用 let array = []; 声明一个数组。 -->
    <!-- <script>
        let age;
        let address;
        age = 24;
        address = "广东省深圳市南山区大冲商务中心A座1110室";
        console.log('Age:' + age + ',Address:' + address);
        let username;
        username = window.prompt('请输入你的名字：');
        console.log('Username:' + username + ',Age:' + age);
    </script> -->

    <!-- 二、数据类型 -->
    <!-- 计算机世界中的万事万物都是数据。 -->
    <!-- 计算机程序可以处理大量的数据，为什么要给数据分类？ -->
    <!-- (1).更加充分和高效的利用内存。 -->
    <!-- (2).也更加方便程序员的使用数据。 -->
    <!-- 2.1 JS 数据类型 -->
    <!-- (1).基础数据类型 -->
    <!-- number              数字类型 -->
    <!-- string              字符串类型 -->
    <!-- boolean             布尔类型 -->
    <!-- undefined           未定义类型 -->
    <!-- null                空类型 -->
    <!-- (2).引用数据类型 -->
    <!-- object              对象类型 -->
    <!-- function            函数类型 -->
    <!-- array               数组类型 -->

    <!-- 2.2 JS 数字类型（Number） -->
    <!-- 即我们数学中学习到的数字，可以是整数、小数、正数、负数。 -->
    <!-- let score = 100; -->
    <!-- let price = 9.9; -->
    <!-- let temperature = -40; -->
    <!-- 注意：JS 中的正数、负数、小数等等统一称为数字类型。 -->
    <!-- 注意：JS   是弱数据类型，变量到底属于那种类型，只有赋值之后，我们才能确认。 -->
    <!-- 注意：Java 是强数据类型，例如 int a = 3 必须是整数。 -->

    <!-- 2.2 JS 字符串类型（String） -->
    <!-- 通过单引号（''）、双引号（""）或反引号（``）包裹的数据都叫字符串，单引号和双引号没有本质上的区别。 -->
    <!-- 推荐使用单引号。 -->
    <!-- let user_name = 'pink'; -->
    <!-- let gender = "男"; -->
    <!-- let str = '124'; -->
    <!-- let s = ''; -->
    <!-- 注意事项： -->
    <!-- (1).无论单引号或是双引号必须成对使用。 -->
    <!-- (2).单引号/双引号可以互相嵌套，但是不以自已嵌套自已（口诀：外双内单，或者外单内双）。 -->
    <!-- (3).必要时可以使用转义符反斜杠（\），输出单引号或双引号。 -->
    <!-- 字符串拼接： -->
    <!-- (1).作用 -->
    <!-- 拼接字符串和变量。 -->
    <!-- 在没有它之前，要拼接变量比较麻烦。 -->
    <!-- (2).符号 -->
    <!-- 反引号（``）。 -->
    <!-- 在英文输入模式下按键盘的 tab 键上方那个键（最左边那个键）。 -->
    <!-- 内容拼接变量时，用 ${} 包住变量。 -->

    <!-- 2.2 JS 布尔类型（Boolean） -->
    <!-- 表示肯定或否定时在计算机中对应的是布尔类型数据。 -->
    <!-- 它有两个固定的值 true 和 false，表示肯定的数据用 true（真），表示否定的数据用 false（假）。 -->
    <!-- let flag = true; -->
    <!-- flag = false; -->

    <!-- 2.2 JS 未定义类型（Undefined） -->
    <!-- 未定义是比较特殊的类型，只有一个值 undefined。 -->
    <!-- 思考：什么情况出现未定义类型？ -->
    <!-- 回答：只声明变量，不赋值的情况下，变量的默认值为：undefined，一般很少【直接】为某个变量赋值为：undefined。 -->
    <!-- let age; -->
    <!-- document.write(age); -->
    <!-- 使用场景： -->
    <!-- 开发中经常声明一个变量，等待传送过来的数据。 -->
    <!-- 如果不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来。 -->
    <!-- 未定义是比较特殊的类型，只有一个值：undefined。 -->
    <!-- 总结使用： -->
    <!-- let age; console.log(age);             只声明，不赋值。结果：Undefined -->
    <!-- console.log(age);                      不声明，不赋值，直接使用。结果：报错 -->
    <!-- age = 22; console.log(age);            不声明，只赋值。结果：10（不建议） -->

    <!-- 2.2 JS 空类型（Null） -->
    <!-- null 表示值为空。 -->
    <!-- let object = null; -->
    <!-- null 和 undefined 区别： -->
    <!-- 1. undefined 表示没有赋值。 -->
    <!-- 2. null 表示赋值了，但是内容为空。 -->
    <!-- null 开发中的使用场景： -->
    <!-- 官方：把 null 作为尚未创建的对象。 -->
    <!-- 通俗：将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个 null。 -->

    <!-- 2.3 JS 对象类型（Object） -->
    <!-- 对象由花括号（{}）分隔。 -->
    <!-- 在括号内部，对象的属性以名称和值对的形式（name : value）来定义。 -->
    <!-- 属性之间由逗号（,）分隔。 -->
    <!-- var person = {firstname:"John", lastname:"Doe", id:5566}; -->
    <!-- 上面例子中的对象（person）有三个属性：firstname、lastname 以及 id。 -->
    <!-- 空格和折行无关紧要。声明可横跨多行： -->
    <!-- var person = { -->
    <!--     firstname: "John", -->
    <!--     lastname: "Doe", -->
    <!--     id: 10086 -->
    <!-- }; -->
    <!-- 对象属性有两种寻址方式： -->
    <!-- name = person.lastname; -->
    <!-- name = person["lastname"]; -->

    <!-- 2.3 JS 函数类型（Function） -->
    <!-- 函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 -->
    <!-- 语法： -->
    <!-- 函数就是包裹在花括号中的代码块，前面使用了关键词：function。 -->
    <!-- function functionname() { -->
    <!--     // 执行代码 -->
    <!-- } -->
    <!-- 当调用该函数时，会执行函数内的代码。 -->
    <!-- 可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 -->
    <!-- 注意：JS 对大小写敏感，关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。 -->
    <!-- 调用： -->
    <!-- 在调用函数时，您可以向其传递值，这些值被称为参数。 -->
    <!-- 这些参数可以在函数中使用。 -->
    <!-- 可以发送任意多的参数是由逗号（,）分隔： -->
    <!-- myFunction(argument1, argument2); -->
    <!-- 当您声明函数时，请把参数作为变量来声明： -->
    <!-- function myFunction(var1, var2) { -->
    <!--     // 执行代码 -->
    <!-- } -->
    <!-- 变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。 -->
    <!-- 返回值： -->
    <!-- 有时，我们会希望函数将值返回调用它的地方。 -->
    <!-- 通过使用 return 语句就可以实现。 -->
    <!-- 在使用 return 语句时，函数会停止执行，并返回指定的值。 -->
    <!-- function myFunction() { -->
    <!--     var x = 5; -->
    <!--     return x; -->
    <!-- } -->
    <!-- 上面的函数会返回值：5。 -->
    <!-- 注意：整个 JS 并不会停止执行，仅仅是函数。JS 将继续执行代码，从调用函数的地方。 -->
    <!-- 函数调用将被返回值取代： -->
    <!-- var y = myFunction(); -->
    <!-- y 变量的值是：5，也就是函数 "myFunction()" 所返回的值。 -->

    <!-- 2.3 JS 数组类型（Array） -->
    <!-- 数组创建方式一： -->
    <!-- var cities = new Array(); -->
    <!-- cities[0] = "北京市"; -->
    <!-- cities[1] = "上海市"; -->
    <!-- cities[2] = "广州市"; -->
    <!-- 数组创建方式二： -->
    <!-- var cities = new Array("北京市", "上海市", "广州市"); -->
    <!-- 数组创建方式三： -->
    <!-- var cities = ["北京市", "上海市", "广州市"]; -->
    <!-- <script>
        var cities = new Array();
        cities[0] = "北京市";
        cities[1] = "上海市";
        cities[2] = "广州市";
        var cities = new Array("北京市", "上海市", "广州市");
        var cities = ["北京市", "上海市", "广州市"];
    </script> -->

    <!-- 2.4 JS 数据类型测试 -->
    <!-- (1).通过 console.log() 控制台方法输出语句检测数据类型。 -->
    <!-- <script>
        let age = 18;
        let username = 'Andy Lau';
        let flag = false;
        let buy;
        console.log(age);
        console.log(username);
        console.log(flag);
        console.log(buy);
    </script> -->
    <!-- 控制台语句经常用于测试结果来使用。 -->
    <!-- 可以看出数字型和布尔型颜色为蓝色，字符串和undefined颜色为灰色。 -->
    <!-- (2).通过 typeof 关键字检测数据类型。 -->
    <!-- <script>
        let age = 18;
        let username = 'Andy Lau';
        let flag = false;
        let buy;
        console.log(typeof age);
        console.log(typeof username);
        console.log(typeof flag);
        console.log(typeof buy);
    </script> -->
    <!-- 控制台语句经常用于测试结果来使用。 -->
    <!-- 可以看出数字类型number和布尔类型boolean，字符串类型string和未定义类型undefined。 -->

    <!-- 2.5 JS 数据类型转换 -->
    <!-- JavaScript是弱数据类型： JavaScript也不知道变量到底属于那种数据类型，只有赋值了才清楚。 -->
    <!-- 坑：使用表单 prompt 标识符关键字获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算。 -->
    <!-- console.log('200' + '400'); -->
    <!-- <script>
        var i = window.prompt("请输入第一个数字：");
        var j = window.prompt("请输入第二个数字：");
        console.log(i + j);
    </script> -->
    <!-- 输出结果：200400 -->
    <!-- 注意：此时需要转换变量的数据类型。 -->
    <!-- 解决：通俗来说，就是把一种数据类型的变量转换成我们需要的数据类型。 -->
    <!-- 1.隐式转换； -->
    <!-- 某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 -->
    <!-- 规则： -->
    <!-- 使用加号（+）两边只要有一个是字符串，都会把另外一个转成字符串。 -->
    <!-- 除了加号（+）以外的算术运算符，比如减号（-）、乘号（*）、除号（/）等等都会把数据转成数字类型。 -->
    <!-- 缺点： -->
    <!-- 转换类型不明确，靠经验才能总结。 -->
    <!-- 技巧： -->
    <!-- 加号（+）作为正号解析可以转换成：Number。 -->
    <!-- 2.显式转换； -->
    <!-- 编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。 -->
    <!-- 为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 -->
    <!-- 概念： -->
    <!-- 自己写代码告诉系统该转成什么类型。 -->
    <!-- 转换为数字型： -->
    <!-- (1).console.log(Number(x)); -->
    <!-- 转成数字类型。 -->
    <!-- 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字。 -->
    <!-- NaN 也是 number 类型的数据，代表非数字。 -->
    <!-- (2).console.log(parseInt(x)); -->
    <!-- 只保留整数。 -->
    <!-- (3).console.log(parseFloat(x)); -->
    <!-- 可以保留小数。 -->
    <!-- <script>
        var x = '12306';
        console.log(Number(x));
        console.log(parseInt(x));
        console.log(parseFloat(x));
    </script> -->
    <!-- 概念： -->
    <!-- 自己写代码告诉系统该转成什么类型。 -->
    <!-- 转换为字符型： -->
    <!-- 1.String(数据) -->
    <!-- console.log(String(x)); -->
    <!-- 2.变量.soString(数据) -->
    <!-- console.log(x.toString()); -->
    <!-- <script>
        var x = 12306;
        console.log(String(x));
        console.log(x.toString());
    </script> -->

    <!-- 三、运算符 -->
    <!-- 3.1 算术运算符 -->
    <!-- 目标：掌握算术运算符，能写出一些具备运算能力的小程序。 -->
    <!-- 数学运算符也叫算术运算符，主要包括加、减、乘、除、取余（求模）。 -->
    <!-- +    ：求和 -->
    <!-- -    ：求差 -->
    <!-- *    ：求积 -->
    <!-- /    ：求商 -->
    <!-- %    ：取模（取余数） -->
    <!-- 开发中经常作为某个数字是否被整除。 -->
    <!-- 目标：能说出JavaScript算术运算符执行的优先级顺序。 -->
    <!-- 同时使用多个运算符编写程序时，会按着某种顺序先后执行，我们称为优先级。 -->
    <!-- JavaScript中 优先级越高越先被执行，优先级相同时以书从左向右执行。 -->
    <!-- 乘、除、取余优先级相同 -->
    <!-- 加、减优先级相同 -->
    <!-- 乘、除、取余优先级大于加、减 -->
    <!-- 使用 () 可以提升优先级 -->
    <!-- 总结：先乘除后加减，有括号先算括号里面的。 -->
    <!-- 提问： -->
    <!-- <script>
        console.log(1 + 2 * 3); 
        console.log(10 - 8 / 2); 
        console.log(2 % 5 + 4 * 2); 
    </script> -->

    <!-- 3.2 赋值运算符 -->
    <!-- 赋值运算符：对变量进行赋值的运算符。 -->
    <!-- 已经学过的赋值运算符等号（=）将等号右边的值赋予给左边, 要求左边必须是一个容器。 -->
    <!-- 其他赋值运算符： -->
    <!-- =     ：等于 -->
    <!-- +=    ：加等 -->
    <!-- -=    ：减等 -->
    <!-- *=    ：乘等 -->
    <!-- /=    ：除等 -->
    <!-- %=    ：余等 -->
    <!-- 使用这些运算符可以在对变量赋值时进行快速操作。 -->
    <!-- 提问： -->
    <!-- <script>
        var x = 20;
        console.log(x = x + 1);
        var y = 20;
        console.log(y += 1);
    </script> -->

    <!-- 3.3 一元运算符 -->
    <!-- 目标： 能够使用一元运算符做自增运算。 -->
    <!-- 众多的 JS 的运算符可以根据所需表达式的个数，分为一元运算符、二元运算符、三元运算符。 -->
    <!-- 二元运算符： -->
    <!-- let x = 20; -->
    <!-- let y = 40; -->
    <!-- let z = x + y; -->
    <!-- 一元运算符： -->
    <!-- let x = 20; -->
    <!-- x++; -->
    <!-- console.log(x); -->
    <!-- 问题：正负号，以前让一个变量每次 +1 ，以前我们做的呢？ -->
    <!-- let x = 20; -->
    <!-- x = x + 1; -->
    <!-- console.log(x); -->
    <!-- 目标： 能够使用一元运算符做自增运算。 -->
    <!-- 我们可以有更简便的写法了 -->
    <!-- 自增： -->
    <!-- 符号：++  -->
    <!-- 作用：让变量的值 +1 -->
    <!-- 自减： -->
    <!-- 符号：-- -->
    <!-- 作用：让变量的值 -1 -->
    <!-- 使用场景： -->
    <!-- 经常用于计数来使用。比如进行 10 次操作，用它来计算进行了多少次了。 -->
    <!-- 目标：能够使用一元运算符做自增运算。 -->
    <!-- 自增运算符的用法： -->
    <!-- 前置自增： -->
    <!-- 每执行 1 次，当前变量数值加 1。 -->
    <!-- 其作用相当于：num += 1 -->
    <!-- 后置自增： -->
    <!-- 每执行 1 次，当前变量数值加 1。 -->
    <!-- 其作用相当于：num += 1 -->
    <!-- 注意：前置自增或者自减和后置自增或者自减，单独使用就没有区别。 -->
    <!-- <script>
        let x = 1;
        ++x;
        console.log(x);
        let y = 1;
        y++;
        console.log(y);
        let a = 2;
        --a;
        console.log(a);
        let b = 2;
        b--;
        console.log(b);
    </script> -->
    <!-- 目标：能够说出自增与减运算符前置或后置的差异。 -->
    <!-- 自增运算符的用法： -->
    <!-- 后置自增： -->
    <!-- (1).先自加再使用（记忆口诀：++在前就先加）。 -->
    <!-- 前置自增： -->
    <!-- (2).先使用再自加（记忆口诀：++在后就后加）。 -->
    <!-- <script>
        let i = 1;
        console.log(++i + 2);
        let j = 1;
        console.log(j++ + 2);
    </script> -->
    <!-- 自增运算符的用法： -->
    <!-- (1).前置自增和后置自增独立使用时二者并没有差别。 -->
    <!-- (2).一般开发中我们都是独立使用。 -->
    <!-- (3).后面 i++ 后置自增会使用相对较多。 -->
    <!-- <script>
        let i = 1;
        console.log(i++ + ++i + i);
    </script> -->

    <!-- 3.4 比较运算符 -->
    <!-- 比较运算符的介绍： -->
    <!-- 作用：作用：比较两个数据大小、是否相等。 -->
    <!-- 实际运用例： -->
    <!-- 目标: 能使用常见的比较运算符进行比较运算。 -->
    <!-- 比较运算符的使用： -->
    <!-- 比较运算符： -->
    <!-- >      ：左边是否大于右边 -->
    <!-- <      ：左边是否小于右边 -->
    <!-- >=     ：左边是否大于或等于右边 -->
    <!-- <=     ：左边是否小于或等于右边 -->
    <!-- ==     ：左右两边是否相等 -->
    <!-- ===    ：左右两边是否类型和值都相等 -->
    <!-- !==    ：左右两边是否不全等 -->
    <!-- 注意：比较结果为 boolean 布尔类型，即只会得到真（true）或假（false）。 -->
    <!-- 比较运算符的细节： -->
    <!-- 字符串比较，是比较的字符对应的 ASCII 码。 -->
    <!-- 从左往右依次比较。 -->
    <!-- 如果第一位一样再比较第二位，以此类推。 -->
    <!-- 比较的少，了解即可。 -->
    <!-- NaN不等于任何值，包括它本身。 -->
    <!-- 尽量不要比较小数，因为小数有精度问题。 -->
    <!-- 不同类型之间比较会发生隐式转换。 -->
    <!-- 最终把数据隐式转换转成 number 类型再比较。 -->
    <!-- 所以开发中，如果进行准确的比较我们更喜欢 === 或者 !==。 -->
    <!-- = 和 == 和 === 三者的区别： -->
    <!-- =   是赋值。 -->
    <!-- ==  是判断。只要求值相等，不要求数据类型一样即可返回：true。 -->
    <!-- === 是全等。要求值和数据类型都一样返回的才是：true。 -->

    <!-- 3.5 逻辑运算符 -->
    <!-- 目标：能说出短路运算符的运算规则。 -->
    <!-- 逻辑运算符的介绍： -->
    <!-- 提问：如果我想判断一个数据大于 5 且小于 10，怎么办？ -->
    <!-- 错误写法：5 < 数据 < 10 -->
    <!-- 逻辑运算符用来解决多重条件判断。 -->
    <!-- 逻辑运算符的使用： -->
    <!-- 逻辑运算符： -->
    <!-- && 逻辑与。并且。符号两边都为True，结果才为True -->
    <!-- || 逻辑或。或者。符号两边有一个是True，结果就为True -->
    <!-- !  逻辑非。取反。True变False，False变True -->
    <!-- 逻辑运算符里的短路： -->
    <!-- 短路：只存在于 && 和 || 中，当满足一定条件会让右边代码不执行。 -->
    <!-- && 左边为 false 就短路（就不满足了呀）。 -->
    <!-- || 左边为 true  就短路（就满足了呀）。 -->
    <!-- 原因：通过左边能得到整个式子的结果，因此没必要再判断右边。 -->
    <!-- 运算结果：无论 && 还是 || 运算结果都是最后被执行的表达式值，一般用在变量赋值。 -->

    <!-- 3.6 运算符优先级 -->
    <!-- 目标：掌握运算符优先级，能判断运算符执行的顺序。 -->
    <!-- 优先级： -->
    <!-- 逗号运算符 < 赋值运算符 < 逻辑运算符 < 相等运算符 < 关系运算符 < 算数运算符 < 一元运算符 < 小括号。 -->
    <!-- ()                      小括号 -->
    <!-- ++ -- !                 一元运算符 -->
    <!-- before * / after + -    算数运算符 -->
    <!-- > >= < <=               关系运算符 -->
    <!-- == != ===               相等运算符 -->
    <!-- before && after ||      逻辑运算符 -->
    <!-- =                       赋值运算符 -->
    <!-- ,                       逗号运算符 -->

    <!-- 四、分支语句 -->
    <!-- 表达式：表达式是一组代码的集合，JavaScript解释器会将其计算出一个结果。 -->
    <!-- 语句：JS 整句或命令，JS 语句是以分号结束（可以省略）。 -->
    <!-- 表达式和语句的区别： -->
    <!-- 表达式计算出一个值。比如：3 + 5; x = 7 -->
    <!-- 语句用来自行以使某件事发生（做什么事）。 -->
    <!-- 程序三大流程控制： -->
    <!-- 顺序 -->
    <!-- 分支 -->
    <!-- 循环 -->
    <!-- (0).三元运算符； -->
    <!-- 条件 ? 满足条件执行的代码 : 不满足条件执行的代码; -->
    <!-- (1).分支语句； -->
    <!-- if (condition) { 满足条件要执行的代码 } -->
    <!-- if (condition) { 满足条件要执行的代码 } else { 满足条件要执行的代码 } -->
    <!-- 括号内的条件为 true 时，进入大括号里执行代码。 -->
    <!-- 小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型。 -->
    <!-- switch (key) {
        case value1:
            // 满足条件要执行的代码
            break;
        case value2:
            // 满足条件要执行的代码
            break;
        case value3:
            // 满足条件要执行的代码
            break;
        default:
            // 满足条件要执行的代码
            break;
    } -->
    <!-- switch (key) {case value: break; default: break;} -->
    <!-- 释义： -->
    <!-- 找到跟小括号里数据全等的 case 值，并执行里面对应的代码。 -->
    <!-- 若没有全等 === 的则执行 default 里的代码。 -->
    <!-- 例：数据若跟值 2 全等，则执行代码 2。 -->
    <!-- 注意： -->
    <!-- switch case 语句一般用于等值判断，不适合于区间判断。 -->
    <!-- switch case 一般需要配合 break 关键字使用，没有 break 会造成 case 穿透。 -->
    <!-- (2).循环语句； -->
    <!-- for (let index = 0; index < array.length; index++) {
        const element = array[index];
        // 要重复执行的代码（循环体）
    } -->
    <!-- array.forEach(element => {
        // 要重复执行的代码（循环体）
    }); -->
    <!-- for (const key in object) {
        if (Object.hasOwnProperty.call(object, key)) {
            const element = object[key];
            // 要重复执行的代码（循环体）
        }
    } -->
    <!-- for (const iterator of object) {
        // 要重复执行的代码（循环体）
    } -->
    <!-- for 循环嵌套（双层 for 循环）： -->
    <!-- for (let i = 0; i < array.length; i++) {
        const external = j[index];
        for (let j = 0; j < array.length; j++) {
            const internal = j[index];
            // 要重复执行的代码（循环体）
        }
    } -->
    <!-- for 循环和 while 循环有什么区别： -->
    <!-- 当如果 明确了 循环的次数的时候推荐使用 for   循环。 -->
    <!-- 当如果 不明确 循环的次数的时候推荐使用 while 循环。 -->
    <!-- while (condition) {
        // 要重复执行的代码（循环体）
    } -->
    <!-- do {
        // 要重复执行的代码（循环体）
    } while (condition); -->
    <!-- 释义： -->
    <!-- 跟 if 语句很像，都要满足小括号里的条件为true才会进入执行代码。 -->
    <!-- 跟 while 大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到。 -->
    <!-- 小括号判断条件，直到括号内条件不满足，即跳出。 -->
    <!-- break continue return 三者的区别： -->
    <!-- break    ：跳出所在的循环。 -->
    <!-- continue ：结束本次循环，继续下次循环。 -->
    <!-- return   ：跳出所在的函数。 -->
    <!-- 断点调试（debug）： -->
    <!-- 作用：学习时可以帮助更好的理解代码运行，工作时可以更快找到 bug。 -->
    <!-- (0).浏览器打开调试界面。 -->
    <!-- (1).按 F12 打开开发者工具。 -->
    <!-- (2).点到 sources 一栏。 -->
    <!-- (3).选择代码文件。 -->
    <!-- 断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来。 -->

    <!-- 五、数组 -->
    <!-- 思考：能说出数组是什么 -->
    <!-- 数组（Array）是一种可以按顺序保存数据的数据类型。 -->
    <!-- 目标：能够声明数组并且能够获取里面的数据。 -->
    <!-- 5.1 创建数组 -->
    <!-- 语法： -->
    <!-- var array = new Array(); -->
    <!-- array[0] = "element-0"; -->
    <!-- array[1] = "element-1"; -->
    <!-- array[2] = "element-2"; -->
    <!-- 语法： -->
    <!-- var array = new Array("element-0", "element-1", "element-2"); -->
    <!-- 语法： -->
    <!-- var array = ["element-0", "element-1", "element-2"]; -->
    <!-- 说明： -->
    <!-- 数组是按顺序保存，所以每个数据都有自己的编号。 -->
    <!-- 计算机中的编号从 0 下标开始，所以小明的编号为 0，小刚编号为 1，以此类推。 -->
    <!-- 在数组中，数据的编号也叫索引或下标。 -->
    <!-- 数组可以存储任意类型的数据。 -->
    <!-- 5.2 数组取值 -->
    <!-- 数组名[下标] -->
    <!-- 实例： -->
    <!-- array[0]; -->
    <!-- 通过下标取数据。 -->
    <!-- 取出来是什么类型的，就根据这种类型特点来访问。 -->
    <!-- 术语： -->
    <!-- 元素：数组中保存的每个数据都叫数组元素。 -->
    <!-- 下标：数组中数据的编号。 -->
    <!-- 长度：数组中数据的个数，通过数组的 length 属性获得。 -->
    <!-- 5.3 遍历数组 -->
    <!-- let array = ["element-0", "element-1", "element-2"];
    for (let index = 0; index < array.length; index++) {
        const element = array[index];
        console.log(element);
    } -->
    <!-- 5.4 操作数组 -->
    <!-- (1).数组新增数据 -->
    <!-- 使用 数组.push()    方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度（重点）。 -->
    <!-- array.push("element-0", "element-1", "element-2"); -->
    <!-- 使用 数组.unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。 -->
    <!-- array.unshift("element-0", "element-1", "element-2"); -->
    <!-- (2).数组删除数据 -->
    <!-- 使用 数组.pop()    方法从数组中删除最后一个元素，并返回该元素的值。 -->
    <!-- array.pop(); -->
    <!-- 使用 数组.shift()  方法从数组中删除的第一个元素，并返回该元素的值。 -->
    <!-- array.shift(); -->
    <!-- 使用 数组.splice() 方法从数组中删除从下标位置的指定元素。 -->
    <!-- array.splice(start, deleteCount); -->
    <!-- (3).数组修改数据 -->
    <!-- (4).数组查询数据 -->

    <!-- 六、函数 -->
    <!-- 目标：通过这段代码封装成函数，体会函数的好处。 -->
    <!-- 函数：function，是被设计为执行特定任务的代码块。 -->
    <!-- 能说出为什么需要函数？ -->
    <!-- 可以实现代码复用，提高开发效率。 -->
    <!-- 函数是用那个关键字声明的？ -->
    <!-- 关键字：function。 -->
    <!-- 为什么要有参数的函数？ -->
    <!-- 若函数完成功能需要调用者传入数据，那么就需要用有参数的函数。 -->
    <!-- 这样可以极大提高函数的灵活性。 -->
    <!-- 说明： -->
    <!-- 函数可以把具有相同或相似逻辑的代码"包裹"起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。 -->
    <!-- (1).声明函数（重点） -->
    <!-- function 函数名() {
        // 函数体
    }
    函数名();
     -->
    <!-- function 函数名(参数列表) {
        // 函数体
    }
    函数名();
     -->
    <!-- (1).匿名函数（了解） -->
    <!-- 将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为函数表达式。 -->
    <!-- 其中函数的形参和实参使用跟具名函数一致。 -->
    <!-- let func = function () {
        // 函数体
    }
    func();
    -->
    <!-- (1).立即执行函数（重点） -->
    <!-- 场景: 避免全局变量之间的污染。 -->
    <!-- 注意：多个立即执行函数要用分号（;）隔开，要不然会报错。 -->
    <!-- (function () {
        // 函数体
    })(); -->
    <!-- (function () {
        // 函数体
    } ()); -->
    <!-- 立即执行函数有什么作用？回答：防止变量污染。 -->
    <!-- 立即执行函数需要调用吗？有什么注意事项呢？回答：无需调用，立即执行，其实本质已经调用。回答：多个立即执行函数之间用分号隔开。 -->
    <!-- 函数命名规范： -->
    <!-- 1、和变量命名基本一致。 -->
    <!-- 2、尽量小驼峰式命名法。 -->
    <!-- 3、前缀应该为动词。 -->
    <!-- 4、命名建议：常用动词约。 -->
    <!-- (2).调用函数 -->
    <!-- 函数名(); -->
    <!-- 注意：声明（定义）的函数必须调用才会真正被执行，使用括号 () 调用函数。 -->
    <!-- 函数体： -->
    <!-- 函数体是函数的构成部分，它负责将相同或相似代码"包裹"起来，直到函数调用时函数体内的代码才会被执行。 -->
    <!-- 函数的功能代码都要写在函数体当中。 -->
    <!-- (3).函数参数： -->
    <!-- 1、传入数据列表。 -->
    <!-- 1、声明这个函数需要传入几个数据。 -->
    <!-- 1、多个数据用逗号（,）隔开。 -->
    <!-- 形式参数和实际参数： -->
    <!-- 形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）。 -->
    <!-- 实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）。 -->
    <!-- 形参可以理解为是在这个函数内声明的变量（比如 num1 = 10）实参可以理解为是给这个变量赋值。 -->
    <!-- 开发中尽量保持形参和实参个数一致。 -->
    <!-- 我们曾经使用过的 alert('打印'), parseInt('11'), Number('11') 本质上都是函数调用的传参。 -->
    <!-- (3).函数返回值 -->
    <!-- 有返回值函数的概念： -->
    <!-- 当调用某个函数，这个函数会返回一个结果出来。 -->
    <!-- 这就是有返回值的函数。 -->
    <!-- 当函数需要返回数据出去时，用 return 关键字。 -->
    <!-- 细节： -->
    <!-- 1、在函数体中使用 return 关键字能将内部的执行结果交给函数外部使用。 -->
    <!-- 2、函数内部只能出现 1 次 return，并且 return 后面代码不会再被执行，所以 return 后面的数据不要换行写。 -->
    <!-- 3、return 会立即结束当前函数。 -->
    <!-- 4、函数可以没有 return，这种情况函数默认返回值为 undefined。 -->
    <!-- (4).函数作用域 -->
    <!-- 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 -->
    <!-- 作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 -->
    <!-- 1、全局作用域：全局有效。作用于所有代码执行的环境（整个 script 标签内部）或者一个独立的 js 文件。 -->
    <!-- 2、局部作用域：局部有效。作用于函数内的代码环境，就是局部作用域。因为跟函数有关系，所以也称为函数作用域。 -->
    <!-- 3、块级作用域：大括号内部有效。块作用域由 { } 大括号包括，if 语句和 for 语句里面的 { } 大括号等等。 -->
    <!-- (5).变量作用域 -->
    <!-- 1、全局变量：函数外部 let 声明的变量。全局变量在任何区域都可以访问和修改。 -->
    <!-- 2、局部变量：函数内部 let 声明的变量。局部变量只能在当前函数内部访问和修改。 -->
    <!-- 3、块级变量：大括号 {} 内部 let 声明的变量。let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 -->
    <!-- (6).作用域链 -->
    <!-- 1、只要是代码，就至少有一个作用域。 -->
    <!-- 2、写在函数内部的局部作用域。 -->
    <!-- 3、如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 -->
    <!-- 4、根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 -->
    <!-- 变量访问原则是什么： -->
    <!-- 作用域链：采取就近原则的方式来查找变量最终的值。 -->
    <!-- <script>
        // 声明函数
        function funcA() {
            let num = 124;
            function funcB() {
                console.log('what?' + num);
            }
            funcB();
        }
        // 此处赋值跟前端以及后面调用没毛关系
        let num = 480;
        funcA();
        // 匿名函数
        let func = function funcA() {
            let num = 124;
            function funcB() {
                console.log('what?' + num);
            }
            funcB();
        }
        func();
    </script> -->

    <!-- 七、对象 -->
    <!-- 对象（object）：JavaScript 里的一种数据类型。 -->
    <!-- (1).对象声明 -->
    <!-- let 对象名 = {
        属性名: 属性值,
        方法名：函数
    } -->
    <!-- 对象有属性和方法组成： -->
    <!-- 属性：信息或叫特征（名词）。比如：手机尺寸、颜色、重量等。 -->
    <!-- 方法：功能或叫行为（动词）。比如：手机打电话、发短信、玩游戏。 -->
    <!-- 属性： -->
    <!-- 数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。 -->
    <!-- 属性都是成对出现的，包括属性名和值，它们之间使用英文分号（:）分隔。 -->
    <!-- 多个属性之间使用英文逗号（,）分隔。 -->
    <!-- 属性就是依附在对象上的变量（外面是变量，对象内是属性）。 -->
    <!-- 属性名可以使用 "" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等。 -->
    <!-- (2).属性访问 -->
    <!-- 1、点 形式。对象.属性; -->
    <!-- 2、[] 形式。对象['属性']; -->
    <!-- 声明对象，并添加了若干属性后，可以使用 . 或 [] 获得对象中属性对应的值，我称之为属性访问。 -->
    <!-- 简单理解就是获得对象里面的属性值。 -->
    <!-- 方法： -->
    <!-- 数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。 -->
    <!-- 方法是由方法名和函数两部分构成，它们之间使用英文分号（:）分隔。 -->
    <!-- 多个属性之间使用英文逗号（,）分隔。 -->
    <!-- 方法是依附在对象中的函数。 -->
    <!-- 方法名可以使用双引号（""）或者单引号（''），一般情况下省略，除非名称遇到特殊符号如空格、中横线等。 -->
    <!-- (2).方法访问 -->
    <!-- 1、点 形式。对象.方法() -->
    <!-- 声明对象，并添加了若干方法后，可以使用 . 调用对象中函数，我称之为方法调用。 -->
    <!-- 注意： 千万别忘了给方法名后面加小括号。 -->
    <!-- (3).对象操作 -->
    <!-- 增加属性： -->
    <!-- 1.person.age = 24; -->
    <!-- 2.person['address'] = "广东省深圳市南山区大冲商务中心A座1110室"; -->
    <!-- 也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活。 -->
    <!-- <script>
        let person = {
            username: "LiuWeiWei",
            basketball: function () {
                return "He can play basketball";
            }
        };
        console.log(person.username);
        console.log(person.basketball());
        person.age = 24;
        person['address'] = "广东省深圳市南山区大冲商务中心A座1110室";
        console.log(person);
    </script> -->
    <!-- 新增方法： -->
    <!-- 3.person.football = function () { return "He can play football"; } -->
    <!-- 也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活。 -->
    <!-- 注意：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。 -->
    <!-- <script>
        let person = {
            username: "LiuWeiWei",
            basketball: function () {
                return "He can play basketball";
            }
        };
        console.log(person.username);
        console.log(person.basketball());
        person.age = 24;
        person['address'] = "广东省深圳市南山区大冲商务中心A座1110室";
        person.football = function () {
            return "He can play football";
        }
        console.log(person);
    </script> -->
    <!-- (4).遍历对象 -->
    <!-- 对象没有像数组一样的 length 属性，所以无法确定长度。 -->
    <!-- 对象里面是无序的键值对, 没有规律，不像数组里面有规律的下标。 -->
    <!-- let object = {
        username: "LiuWeiWei",
        basketball: function () {
            return "He can play basketball";
        }
    };
    for (const key in object) {
        if (Object.hasOwnProperty.call(object, key)) {
            const objectKey   = key;
            const objectValue = object[key];
        }
    } -->
    <!-- 一般不用这种方式遍历数组、主要是用来遍历对象。 -->
    <!-- 重点记住： key 是获得对象的属性名，对象名[key] 是获得对象的属性值。 -->
    <!-- (5).内置对象 -->
    <!-- 思考：内置对象是什么？ -->
    <!-- JavaScript 内部提供的对象，包含各种属性和方法给开发者调用。 -->
    <!-- 思考：我们之前用过内置对象吗？ -->
    <!-- 内置对象 Document 文档对象。 -->
    <!-- document.write() -->
    <!-- 内置对象 Console 控制台对象。 -->
    <!-- console.log() -->
    <!-- Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。 -->
    <!-- Math 用于 Number 类型。它不支持 BigInt。 -->
    <!-- 描述： -->
    <!-- 与其他全局对象不同的是，Math 不是一个构造器。Math 的所有属性与方法都是静态的。 -->
    <!-- 引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。Math 的常量是使用 JavaScript 中的全精度浮点数来定义的。 -->
    <!-- 属性： -->
    <!-- Math.E           欧拉常数，也是自然对数的底数，约等于 2.718。 -->
    <!-- Math.LN2         2 的自然对数，约等于 0.693。 -->
    <!-- Math.LN10        10 的自然对数，约等于 2.303。 -->
    <!-- Math.LOG2E       以 2 为底的 E 的对数，约等于 1.443。 -->
    <!-- Math.LOG10E      以 10 为底的 E 的对数，约等于 0.434。 -->
    <!-- Math.PI          圆周率，一个圆的周长和直径之比，约等于 3.14159。 -->
    <!-- Math.SQRT1_2     二分之一 ½ 的平方根，同时也是 2 的平方根的倒数，约等于 0.707。 -->
    <!-- Math.SQRT2       2 的平方根，约等于 1.414。 -->
    <!-- 方法： -->
    <!-- Math.abs(x)                  返回一个数的绝对值。 -->
    <!-- Math.acos(x)                 返回一个数的反余弦值。 -->
    <!-- Math.acosh(x)                返回一个数的反双曲余弦值。 -->
    <!-- Math.asin(x)                 返回一个数的反正弦值。 -->
    <!-- Math.asinh(x)                返回一个数的反双曲正弦值。 -->
    <!-- Math.atan(x)                 返回一个数的反正切值。 -->
    <!-- Math.atanh(x)                返回一个数的反双曲正切值。 -->
    <!-- Math.atan2(y, x)             返回 y/x 的反正切值。 -->
    <!-- Math.cbrt(x)                 返回一个数的立方根。 -->
    <!-- Math.ceil(x)                 返回大于一个数的最小整数，即一个数向上取整后的值。 -->
    <!-- Math.clz32(x)                返回一个 32 位整数的前导零的数量。 -->
    <!-- Math.cos(x)                  返回一个数的余弦值。 -->
    <!-- Math.cosh(x)                 返回一个数的双曲余弦值。 -->
    <!-- Math.exp(x)                  返回欧拉常数的参数次方，E^x，其中 x 为参数，E 是欧拉常数（2.718...，自然对数的底数）。 -->
    <!-- Math.expm1(x)                返回 exp(x) - 1 的值。 -->
    <!-- Math.floor(x)                返回小于一个数的最大整数，即一个数向下取整后的值。 -->
    <!-- Math.fround(x)               返回最接近一个数的单精度浮点型表示。 -->
    <!-- Math.hypot([x[, y[, ...]]])  返回其所有参数平方和的平方根。 -->
    <!-- Math.imul(x, y)              返回 32 位整数乘法的结果。 -->
    <!-- Math.log(x)                  返回一个数的自然对数（㏒e，即 ㏑）。 -->
    <!-- Math.log1p(x)                返回一个数加 1 的和的自然对数（㏒e，即 ㏑）。 -->
    <!-- Math.log10(x)                返回一个数以 10 为底数的对数。 -->
    <!-- Math.log2(x)                 返回一个数以 2 为底数的对数。 -->
    <!-- Math.max([x[, y[, ...]]])    返回零到多个数值中最大值。 -->
    <!-- Math.min([x[, y[, ...]]])    返回零到多个数值中最小值。 -->
    <!-- Math.pow(x, y)               返回一个数的 y 次幂。 -->
    <!-- Math.random()                返回一个 0 到 1 之间的伪随机数。 -->
    <!-- Math.round(x)                返回四舍五入后的整数。 -->
    <!-- Math.sign(x)                 返回一个数的符号，得知一个数是正数、负数还是 0。 -->
    <!-- Math.sin(x)                  返回一个数的正弦值。 -->
    <!-- Math.sinh(x)                 返回一个数的双曲正弦值。 -->
    <!-- Math.sqrt(x)                 返回一个数的平方根。 -->
    <!-- Math.tan(x)                  返回一个数的正切值。 -->
    <!-- Math.tanh(x)                 返回一个数的双曲正切值。 -->
    <!-- Math.toSource()              返回字符串 "Math"。 -->
    <!-- Math.trunc(x)                返回一个数的整数部分，直接去除其小数点及之后的部分。 -->
    <!-- 在线文档<MDN>： -->
    <!-- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math -->
    <!-- 操作： -->
    <!-- 如何生成0-10的随机数呢？ -->
    <!-- Math.floor(Math.random() * (10 + 1)); -->
    <!-- 如何生成5-10的随机数？ -->
    <!-- Math.floor(Math.random() * (5 + 1)) + 5; -->
    <!-- 如何生成N-M之间的随机数？ -->
    <!-- Math.floor(Math.random() * (M - N + 1)) + N; -->
    <!-- JS 关键字 -->
    <!-- 在JavaScript中有特殊意义的词汇：let var function if else switch case break -->
    <!-- JS 保留字 -->
    <!-- 在目前的JavaScript中没意义，但未来可能会具有特殊意义的词汇：int short long char -->
    <!-- JS 标识符 -->
    <!-- 变量名、函数名的另一种叫法。无 -->
    <!-- JS 表达式 -->
    <!-- 能产生值的代码，一般配合运算符出现。10+3 age>=18 -->
    <!-- JS 语句 -->
    <!-- 一句代码也称之为一条语句，一般按用途还会分类：输出语句、声明语句、分支语句。无 -->
    <!-- 重点：基本数据类型和引用数据类型的存储方式 -->
    <!-- 简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 -->
    <!-- 基本数据类型：简单数据类型，在存储时变量中存储的是值本身，因此叫做值类型。string，number，boolean，undefined，null -->
    <!-- 引用数据类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型。通过 new 关键字创建的对象（系统对象、自定义对象），如：Object、Array、Date 等。 -->
    <!-- 1、简单数据类型的内存分配： -->
    <!-- 值类型（简单数据类型）： string ，number，boolean，undefined，null。 -->
    <!-- 值类型变量的数据直接存放在变量（栈空间）中。 -->
    <!-- 2、复杂数据类型的内存分配： -->
    <!-- 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等。 -->
    <!-- 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中。 -->
    <!-- 重点：堆栈空间分配区别： -->
    <!-- 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。 -->
    <!-- 1、简单数据类型存放到栈里面。 -->
    <!-- 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 -->
    <!-- 2、引用数据类型存放到堆里面。 -->

    


    <!-- ---------------------------------------- 华丽的分割线 ---------------------------------------- -->




</body>

</html>